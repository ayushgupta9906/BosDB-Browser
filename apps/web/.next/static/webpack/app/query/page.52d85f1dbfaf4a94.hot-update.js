"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/query/page",{

/***/ "(app-pages-browser)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: function() { return /* binding */ checkoutBranch; },\n/* harmony export */   commitChanges: function() { return /* binding */ commitChanges; },\n/* harmony export */   createBranch: function() { return /* binding */ createBranch; },\n/* harmony export */   generateInverseSQL: function() { return /* binding */ generateInverseSQL; },\n/* harmony export */   getBranches: function() { return /* binding */ getBranches; },\n/* harmony export */   getCommitHistory: function() { return /* binding */ getCommitHistory; },\n/* harmony export */   getPendingChanges: function() { return /* binding */ getPendingChanges; },\n/* harmony export */   parseQueryForChanges: function() { return /* binding */ parseQueryForChanges; },\n/* harmony export */   trackChange: function() { return /* binding */ trackChange; },\n/* harmony export */   trackSchemaChange: function() { return /* binding */ trackSchemaChange; }\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: \"\".concat(operation.charAt(0).toUpperCase() + operation.slice(1), \" table \").concat(tableName, \" by \").concat(author.name),\n        query: sql\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Helper to extract the next identifier after a keyword/phrase\n    const getIdentifierAfter = (keyword, fromQuery)=>{\n        const regex = new RegExp(\"\".concat(keyword, \"\\\\s+(?:IF\\\\s+NOT\\\\s+EXISTS\\\\s+|IF\\\\s+EXISTS\\\\s+)?([^\\\\s\\\\(\\\\);]+)\"), \"i\");\n        const match = fromQuery.match(regex);\n        return match ? match[1] : \"unknown\";\n    };\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const tableName = getIdentifierAfter(\"CREATE\\\\s+TABLE\", cleanQuery);\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Create table \".concat(tableName),\n            query\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const tableName = getIdentifierAfter(\"ALTER\\\\s+TABLE\", cleanQuery);\n        // Try to identify if it's ADD/DROP column for better rollback\n        let schemaUpdate = undefined;\n        if (normalizedQuery.includes(\"ADD COLUMN\")) schemaUpdate = \"ADD COLUMN\";\n        else if (normalizedQuery.includes(\"DROP COLUMN\")) schemaUpdate = \"DROP COLUMN\";\n        else if (normalizedQuery.includes(\"MODIFY\") || normalizedQuery.includes(\"ALTER COLUMN\")) schemaUpdate = \"MODIFY COLUMN\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Alter table \".concat(tableName),\n            query,\n            schemaUpdate\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const tableName = getIdentifierAfter(\"DROP\\\\s+TABLE\", cleanQuery);\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Drop table \".concat(tableName),\n            query\n        };\n    }\n    // Database changes\n    const dbMatch = cleanQuery.match(/(CREATE|DROP)\\s+DATABASE\\s+([^\\\\s\\\\(\\\\);]+)/i);\n    if (dbMatch) {\n        const op = dbMatch[1].toUpperCase();\n        const name = dbMatch[2];\n        return {\n            type: \"SCHEMA\",\n            operation: op,\n            targetType: \"DATABASE\",\n            target: name,\n            description: \"\".concat(op === \"CREATE\" ? \"Create\" : \"Drop\", \" database \").concat(name),\n            query\n        };\n    }\n    // Truncate\n    if (normalizedQuery.includes(\"TRUNCATE TABLE\") || normalizedQuery.startsWith(\"TRUNCATE \")) {\n        const tableName = getIdentifierAfter(\"TRUNCATE\\\\s+(?:TABLE\\\\s+)?\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"TRUNCATE\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Truncate table \".concat(tableName),\n            query\n        };\n    }\n    // Rename\n    if (normalizedQuery.includes(\"RENAME TABLE\")) {\n        const match = cleanQuery.match(/RENAME\\s+TABLE\\s+([^\\\\s,]+)\\s+TO\\s+([^\\\\s,;]+)/i);\n        if (match) {\n            return {\n                type: \"SCHEMA\",\n                operation: \"RENAME\",\n                targetType: \"TABLE\",\n                target: match[2],\n                previousIdentifier: match[1],\n                tableName: match[2].replace(/[`\"\\[\\]]/g, \"\"),\n                description: \"Rename table \".concat(match[1], \" to \").concat(match[2]),\n                query\n            };\n        }\n    }\n    // Procedure/Function/View Schema changes\n    const schemaObjMatch = cleanQuery.match(/(CREATE|ALTER)\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|ROUTINE|TRIGGER|INDEX)\\s+([^\\\\s\\\\(\\\\);]+)/i);\n    if (schemaObjMatch) {\n        const op = schemaObjMatch[1].toUpperCase();\n        const type = schemaObjMatch[2].toUpperCase();\n        const name = schemaObjMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: op,\n            targetType: type,\n            target: name,\n            description: \"\".concat(op === \"CREATE\" ? \"Create\" : \"Alter\", \" \").concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    const dropObjMatch = cleanQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|ROUTINE|TRIGGER|INDEX)\\s+(?:IF\\s+EXISTS\\s+)?([^\\\\s\\\\(\\\\);]+)/i);\n    if (dropObjMatch) {\n        const type = dropObjMatch[1].toUpperCase();\n        const name = dropObjMatch[2];\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            targetType: type,\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    // Permissions\n    if (normalizedQuery.startsWith(\"GRANT \") || normalizedQuery.startsWith(\"REVOKE \")) {\n        const op = normalizedQuery.startsWith(\"GRANT \") ? \"GRANT\" : \"REVOKE\";\n        return {\n            type: \"PERMISSION\",\n            operation: op,\n            target: \"database\",\n            description: \"\".concat(op, \" permission: \").concat(cleanQuery.substring(0, 50), \"...\"),\n            query\n        };\n    }\n    // Data changes (DML)\n    if (normalizedQuery.startsWith(\"INSERT INTO\")) {\n        const tableName = getIdentifierAfter(\"INSERT\\\\s+INTO\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"INSERT\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Insert \".concat(affectedRows || 1, \" row(s) into \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const tableName = getIdentifierAfter(\"UPDATE\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Update \".concat(affectedRows || \"unknown\", \" row(s) in \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const tableName = getIdentifierAfter(\"DELETE\\\\s+FROM\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Delete \".concat(affectedRows || \"unknown\", \" row(s) from \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    return null;\n}\n/**\r\n * Generate inverse SQL to undo a change\r\n */ function generateInverseSQL(change) {\n    const { type, operation, target, query, tableName, targetType, previousIdentifier, schemaUpdate, oldValues } = change;\n    // Helper to format values for SQL\n    const formatSqlValue = (v)=>{\n        if (v === null || v === undefined) return \"NULL\";\n        // Handle dates (including stringified dates from JSON)\n        if (v instanceof Date) return \"'\".concat(v.toISOString().replace(\"T\", \" \").replace(\"Z\", \"\").split(\".\")[0], \"'\");\n        if (typeof v === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(v)) {\n            const d = new Date(v);\n            if (!isNaN(d.getTime())) {\n                return \"'\".concat(d.toISOString().replace(\"T\", \" \").replace(\"Z\", \"\").split(\".\")[0], \"'\");\n            }\n        }\n        // Handle numbers (including stringified numbers that should be literal)\n        if (typeof v === \"number\") return v;\n        if (typeof v === \"string\" && /^-?\\d+(\\.\\d+)?$/.test(v) && v.length < 15) {\n            return v;\n        }\n        if (typeof v === \"string\") return \"'\".concat(v.replace(/'/g, \"''\"), \"'\");\n        if (typeof v === \"boolean\") return v ? \"1\" : \"0\";\n        if (typeof v === \"object\") return \"'\".concat(JSON.stringify(v).replace(/'/g, \"''\"), \"'\");\n        return v;\n    };\n    // SCHEMA ROLLBACKS\n    if (type === \"SCHEMA\") {\n        if (operation === \"CREATE\") {\n            const objType = targetType || \"TABLE\";\n            return \"DROP \".concat(objType, \" IF EXISTS \").concat(target, \";\");\n        }\n        if (operation === \"DROP\") {\n            if (query && (query.toUpperCase().includes(\"CREATE\") || query.toUpperCase().includes(\"ALTER\"))) {\n                return query;\n            }\n            return \"-- Manual restore required for dropped \".concat(targetType || \"OBJECT\", \" \").concat(target);\n        }\n        if (operation === \"ALTER\") {\n            if (targetType === \"TABLE\" && schemaUpdate) {\n                if (schemaUpdate === \"ADD COLUMN\") {\n                    const colMatch = query === null || query === void 0 ? void 0 : query.match(/ADD\\s+COLUMN\\s+([^\\\\s\\\\(\\\\)]+)/i);\n                    if (colMatch) return \"ALTER TABLE \".concat(target, \" DROP COLUMN \").concat(colMatch[1], \";\");\n                }\n            }\n            return \"-- Manual undo required for ALTER \".concat(targetType || \"OBJECT\", \" \").concat(target);\n        }\n        if (operation === \"RENAME\") {\n            if (targetType === \"TABLE\" && previousIdentifier) {\n                return \"RENAME TABLE \".concat(target, \" TO \").concat(previousIdentifier, \";\");\n            }\n        }\n    }\n    // DATA ROLLBACKS\n    if (type === \"DATA\") {\n        const table = tableName || target;\n        if (operation === \"UPDATE\" && oldValues && oldValues.length > 0) {\n            return oldValues.map((row)=>{\n                const keys = Object.keys(row);\n                // Try to find a primary key or identifier\n                const idCol = keys.find((k)=>k.toLowerCase() === \"id\" || k.toLowerCase() === \"uuid\") || keys.find((k)=>k.toLowerCase().endsWith(\"_id\") || k.toLowerCase().endsWith(\"id\")) || keys[0];\n                const idVal = formatSqlValue(row[idCol]);\n                const assignment = keys.filter((k)=>k !== idCol).map((k)=>\"\".concat(k, \" = \").concat(formatSqlValue(row[k]))).join(\", \");\n                return \"UPDATE \".concat(table, \" SET \").concat(assignment, \" WHERE \").concat(idCol, \" = \").concat(idVal, \";\");\n            }).join(\"\\n\");\n        }\n        if (operation === \"DELETE\" && oldValues && oldValues.length > 0) {\n            return oldValues.map((row)=>{\n                const keys = Object.keys(row);\n                const cols = keys.join(\", \");\n                const vals = keys.map((k)=>formatSqlValue(row[k])).join(\", \");\n                return \"INSERT INTO \".concat(table, \" (\").concat(cols, \") VALUES (\").concat(vals, \");\");\n            }).join(\"\\n\");\n        }\n        if (operation === \"TRUNCATE\") {\n            return \"-- Manual data restore required for truncated table \".concat(target, \".\");\n        }\n    }\n    // DATABASE ROLLBACKS\n    if (targetType === \"DATABASE\") {\n        if (operation === \"CREATE\") return \"DROP DATABASE \".concat(target, \";\");\n        return \"-- Manual database restore required for \".concat(target, \".\");\n    }\n    // PERMISSION ROLLBACKS\n    if (type === \"PERMISSION\") {\n        if (operation === \"GRANT\") return (query === null || query === void 0 ? void 0 : query.replace(/GRANT/i, \"REVOKE\").replace(/ TO /i, \" FROM \")) + \";\" || 0;\n        if (operation === \"REVOKE\") return (query === null || query === void 0 ? void 0 : query.replace(/REVOKE/i, \"GRANT\").replace(/ FROM /i, \" TO \")) + \";\" || 0;\n    }\n    return null;\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/pending?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/commit?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/branches?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdmNzLWhlbHBlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBa0JEOztDQUVDLEdBQ00sZUFBZUEsWUFBWUMsWUFBb0IsRUFBRUMsTUFBc0I7SUFDMUUsSUFBSTtRQUNBLE1BQU1DLE1BQU0sb0JBQW9CO1lBQzVCQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjQztZQUFPO1FBQ2hEO0lBQ0osRUFBRSxPQUFPTyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO0lBQzdDO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGtCQUNsQlYsWUFBb0IsRUFDcEJXLFNBQXNDLEVBQ3RDQyxTQUFpQixFQUNqQkMsR0FBVyxFQUNYQyxNQUFvQztJQUVwQyxNQUFNYixTQUF5QjtRQUMzQmMsTUFBTTtRQUNOSixXQUFXQSxVQUFVSyxXQUFXO1FBQ2hDQyxRQUFRTDtRQUNSQTtRQUNBTSxhQUFhLEdBQW1FTixPQUFoRUQsVUFBVVEsTUFBTSxDQUFDLEdBQUdILFdBQVcsS0FBS0wsVUFBVVMsS0FBSyxDQUFDLElBQUcsV0FBeUJOLE9BQWhCRixXQUFVLFFBQWtCLE9BQVpFLE9BQU9PLElBQUk7UUFDM0dDLE9BQU9UO0lBQ1g7SUFFQSxNQUFNZCxZQUFZQyxjQUFjQztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU3NCLHFCQUFxQkQsS0FBYSxFQUFFRSxZQUFxQjtJQUNyRSwyQkFBMkI7SUFDM0IsTUFBTUMsYUFBYUgsTUFBTUksT0FBTyxDQUFDLDZCQUE2QixJQUFJQyxJQUFJO0lBQ3RFLE1BQU1DLGtCQUFrQkgsV0FBV1QsV0FBVztJQUU5QywrREFBK0Q7SUFDL0QsTUFBTWEscUJBQXFCLENBQUNDLFNBQWlCQztRQUN6QyxNQUFNQyxRQUFRLElBQUlDLE9BQU8sR0FBVyxPQUFSSCxTQUFR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LE9BQU9qRixPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDTSxlQUFleUYsZUFBZWpHLFlBQW9CLEVBQUVxQixJQUFZO0lBQ25FLElBQUk7UUFDQSxNQUFNd0QsV0FBVyxNQUFNM0UsTUFBTSxxQkFBcUI7WUFDOUNDLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRVA7Z0JBQWNxQjtnQkFBTTJFLFFBQVE7WUFBVztRQUNsRTtRQUNBLE1BQU1SLFNBQVMsTUFBTVgsU0FBU0UsSUFBSTtRQUNsQyxPQUFPUyxPQUFPQyxPQUFPO0lBQ3pCLEVBQUUsT0FBT2pGLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi92Y3MtaGVscGVyLnRzP2JjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFZDUyBJbnRlZ3JhdGlvbiBIZWxwZXJcclxuICogQXV0b21hdGljYWxseSB0cmFja3MgZGF0YWJhc2UgY2hhbmdlcyBmb3IgdmVyc2lvbiBjb250cm9sXHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhYmFzZUNoYW5nZSB7XHJcbiAgICB0eXBlOiAnU0NIRU1BJyB8ICdEQVRBJyB8ICdQRVJNSVNTSU9OJyB8ICdBRE1JTic7XHJcbiAgICBvcGVyYXRpb246ICdDUkVBVEUnIHwgJ0FMVEVSJyB8ICdEUk9QJyB8ICdJTlNFUlQnIHwgJ1VQREFURScgfCAnREVMRVRFJyB8ICdSRU5BTUUnIHwgJ1RSVU5DQVRFJyB8ICdHUkFOVCcgfCAnUkVWT0tFJztcclxuICAgIHRhcmdldFR5cGU/OiAnVEFCTEUnIHwgJ1ZJRVcnIHwgJ1BST0NFRFVSRScgfCAnRlVOQ1RJT04nIHwgJ1JPVVRJTkUnIHwgJ1RSSUdHRVInIHwgJ0lOREVYJyB8ICdEQVRBQkFTRScgfCAnU0NIRU1BJyB8ICdDT0xVTU4nIHwgJ1VTRVInIHwgJ1JPTEUnO1xyXG4gICAgdGFyZ2V0OiBzdHJpbmc7XHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gICAgcXVlcnk/OiBzdHJpbmc7XHJcbiAgICB0YWJsZU5hbWU/OiBzdHJpbmc7XHJcbiAgICBhZmZlY3RlZFJvd3M/OiBudW1iZXI7XHJcbiAgICAvLyBBZHZhbmNlZCBtZXRhZGF0YSBmb3Igcm9sbGJhY2tcclxuICAgIG9sZFZhbHVlcz86IGFueVtdOyAvLyBGb3IgVVBEQVRFL0RFTEVURSByb2xsYmFja1xyXG4gICAgb2xkU2NoZW1hPzogYW55OyAgIC8vIEZvciBBTFRFUi9EUk9QIHJvbGxiYWNrXHJcbiAgICBwcmV2aW91c0lkZW50aWZpZXI/OiBzdHJpbmc7IC8vIEZvciBSRU5BTUVcclxuICAgIHNjaGVtYVVwZGF0ZT86IHN0cmluZzsgLy8gU3BlY2lmaWMgcGFydCBvZiBzY2hlbWEgdXBkYXRlZCAoZS5nLiBcIkFERCBDT0xVTU5cIilcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgZGF0YWJhc2UgY2hhbmdlIGZvciB2ZXJzaW9uIGNvbnRyb2xcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQ6IHN0cmluZywgY2hhbmdlOiBEYXRhYmFzZUNoYW5nZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvcGVuZGluZycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbm5lY3Rpb25JZCwgY2hhbmdlIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB0cmFjayBjaGFuZ2U6JywgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgYSBzY2hlbWEgY2hhbmdlIChDUkVBVEUsIEFMVEVSLCBEUk9QIHRhYmxlKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrU2NoZW1hQ2hhbmdlKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBvcGVyYXRpb246ICdjcmVhdGUnIHwgJ2FsdGVyJyB8ICdkcm9wJyxcclxuICAgIHRhYmxlTmFtZTogc3RyaW5nLFxyXG4gICAgc3FsOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1cclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBjaGFuZ2U6IERhdGFiYXNlQ2hhbmdlID0ge1xyXG4gICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLnRvVXBwZXJDYXNlKCkgYXMgJ0NSRUFURScgfCAnQUxURVInIHwgJ0RST1AnLFxyXG4gICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgIHRhYmxlTmFtZSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3BlcmF0aW9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3BlcmF0aW9uLnNsaWNlKDEpfSB0YWJsZSAke3RhYmxlTmFtZX0gYnkgJHthdXRob3IubmFtZX1gLFxyXG4gICAgICAgIHF1ZXJ5OiBzcWxcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgdHJhY2tDaGFuZ2UoY29ubmVjdGlvbklkLCBjaGFuZ2UpO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgU1FMIHF1ZXJ5IHRvIGRldGVjdCBjaGFuZ2UgdHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnlGb3JDaGFuZ2VzKHF1ZXJ5OiBzdHJpbmcsIGFmZmVjdGVkUm93cz86IG51bWJlcik6IERhdGFiYXNlQ2hhbmdlIHwgbnVsbCB7XHJcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIHRyaW1cclxuICAgIGNvbnN0IGNsZWFuUXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfC0tLio/XFxuL2csICcnKS50cmltKCk7XHJcbiAgICBjb25zdCBub3JtYWxpemVkUXVlcnkgPSBjbGVhblF1ZXJ5LnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gSGVscGVyIHRvIGV4dHJhY3QgdGhlIG5leHQgaWRlbnRpZmllciBhZnRlciBhIGtleXdvcmQvcGhyYXNlXHJcbiAgICBjb25zdCBnZXRJZGVudGlmaWVyQWZ0ZXIgPSAoa2V5d29yZDogc3RyaW5nLCBmcm9tUXVlcnk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtrZXl3b3JkfVxcXFxzKyg/OklGXFxcXHMrTk9UXFxcXHMrRVhJU1RTXFxcXHMrfElGXFxcXHMrRVhJU1RTXFxcXHMrKT8oW15cXFxcc1xcXFwoXFxcXCk7XSspYCwgJ2knKTtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGZyb21RdWVyeS5tYXRjaChyZWdleCk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAndW5rbm93bic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRhYmxlIFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdDUkVBVEUgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignQ1JFQVRFXFxcXHMrVEFCTEUnLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogJ1RBQkxFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZTogdGFibGVOYW1lLnJlcGxhY2UoL1tgXCJcXFtcXF1dL2csICcnKSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDcmVhdGUgdGFibGUgJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0FMVEVSIFRBQkxFJykpIHtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBnZXRJZGVudGlmaWVyQWZ0ZXIoJ0FMVEVSXFxcXHMrVEFCTEUnLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICAvLyBUcnkgdG8gaWRlbnRpZnkgaWYgaXQncyBBREQvRFJPUCBjb2x1bW4gZm9yIGJldHRlciByb2xsYmFja1xyXG4gICAgICAgIGxldCBzY2hlbWFVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnQUREIENPTFVNTicpKSBzY2hlbWFVcGRhdGUgPSAnQUREIENPTFVNTic7XHJcbiAgICAgICAgZWxzZSBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEUk9QIENPTFVNTicpKSBzY2hlbWFVcGRhdGUgPSAnRFJPUCBDT0xVTU4nO1xyXG4gICAgICAgIGVsc2UgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnTU9ESUZZJykgfHwgbm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdBTFRFUiBDT0xVTU4nKSkgc2NoZW1hVXBkYXRlID0gJ01PRElGWSBDT0xVTU4nO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQUxURVInLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiAnVEFCTEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEFsdGVyIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBzY2hlbWFVcGRhdGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0RST1AgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignRFJPUFxcXFxzK1RBQkxFJywgY2xlYW5RdWVyeSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0RST1AnLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiAnVEFCTEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgdGFibGUgJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERhdGFiYXNlIGNoYW5nZXNcclxuICAgIGNvbnN0IGRiTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC8oQ1JFQVRFfERST1ApXFxzK0RBVEFCQVNFXFxzKyhbXlxcXFxzXFxcXChcXFxcKTtdKykvaSk7XHJcbiAgICBpZiAoZGJNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IG9wID0gZGJNYXRjaFsxXS50b1VwcGVyQ2FzZSgpIGFzIGFueTtcclxuICAgICAgICBjb25zdCBuYW1lID0gZGJNYXRjaFsyXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcCxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogJ0RBVEFCQVNFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3AgPT09ICdDUkVBVEUnID8gJ0NyZWF0ZScgOiAnRHJvcCd9IGRhdGFiYXNlICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ1bmNhdGVcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ1RSVU5DQVRFIFRBQkxFJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1RSVU5DQVRFICcpKSB7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gZ2V0SWRlbnRpZmllckFmdGVyKCdUUlVOQ0FURVxcXFxzKyg/OlRBQkxFXFxcXHMrKT8nLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ1RSVU5DQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogJ1RBQkxFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZTogdGFibGVOYW1lLnJlcGxhY2UoL1tgXCJcXFtcXF1dL2csICcnKSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBUcnVuY2F0ZSB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVuYW1lXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdSRU5BTUUgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvUkVOQU1FXFxzK1RBQkxFXFxzKyhbXlxcXFxzLF0rKVxccytUT1xccysoW15cXFxccyw7XSspL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdSRU5BTUUnLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZTogJ1RBQkxFJyxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbWF0Y2hbMl0sXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c0lkZW50aWZpZXI6IG1hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgdGFibGVOYW1lOiBtYXRjaFsyXS5yZXBsYWNlKC9bYFwiXFxbXFxdXS9nLCAnJyksXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFJlbmFtZSB0YWJsZSAke21hdGNoWzFdfSB0byAke21hdGNoWzJdfWAsXHJcbiAgICAgICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZWR1cmUvRnVuY3Rpb24vVmlldyBTY2hlbWEgY2hhbmdlc1xyXG4gICAgY29uc3Qgc2NoZW1hT2JqTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC8oQ1JFQVRFfEFMVEVSKVxccysoPzpPUlxccytSRVBMQUNFXFxzKyk/KFBST0NFRFVSRXxGVU5DVElPTnxWSUVXfFJPVVRJTkV8VFJJR0dFUnxJTkRFWClcXHMrKFteXFxcXHNcXFxcKFxcXFwpO10rKS9pKTtcclxuICAgIGlmIChzY2hlbWFPYmpNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IG9wID0gc2NoZW1hT2JqTWF0Y2hbMV0udG9VcHBlckNhc2UoKSBhcyBhbnk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYU9iak1hdGNoWzJdLnRvVXBwZXJDYXNlKCkgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBzY2hlbWFPYmpNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcCxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogdHlwZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3AgPT09ICdDUkVBVEUnID8gJ0NyZWF0ZScgOiAnQWx0ZXInfSAke3R5cGUudG9Mb3dlckNhc2UoKX0gJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcm9wT2JqTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9EUk9QXFxzKyhQUk9DRURVUkV8RlVOQ1RJT058VklFV3xST1VUSU5FfFRSSUdHRVJ8SU5ERVgpXFxzKyg/OklGXFxzK0VYSVNUU1xccyspPyhbXlxcXFxzXFxcXChcXFxcKTtdKykvaSk7XHJcbiAgICBpZiAoZHJvcE9iak1hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGRyb3BPYmpNYXRjaFsxXS50b1VwcGVyQ2FzZSgpIGFzIGFueTtcclxuICAgICAgICBjb25zdCBuYW1lID0gZHJvcE9iak1hdGNoWzJdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogdHlwZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgJHt0eXBlLnRvTG93ZXJDYXNlKCl9ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVybWlzc2lvbnNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnR1JBTlQgJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1JFVk9LRSAnKSkge1xyXG4gICAgICAgIGNvbnN0IG9wID0gbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0dSQU5UICcpID8gJ0dSQU5UJyA6ICdSRVZPS0UnO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdQRVJNSVNTSU9OJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcCxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnZGF0YWJhc2UnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3B9IHBlcm1pc3Npb246ICR7Y2xlYW5RdWVyeS5zdWJzdHJpbmcoMCwgNTApfS4uLmAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEYXRhIGNoYW5nZXMgKERNTClcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnSU5TRVJUIElOVE8nKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignSU5TRVJUXFxcXHMrSU5UTycsIGNsZWFuUXVlcnkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdEQVRBJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnSU5TRVJUJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZTogdGFibGVOYW1lLnJlcGxhY2UoL1tgXCJcXFtcXF1dL2csICcnKSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBJbnNlcnQgJHthZmZlY3RlZFJvd3MgfHwgMX0gcm93KHMpIGludG8gJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIGFmZmVjdGVkUm93c1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdVUERBVEUnKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignVVBEQVRFJywgY2xlYW5RdWVyeSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdVUERBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVwZGF0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBpbiAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBnZXRJZGVudGlmaWVyQWZ0ZXIoJ0RFTEVURVxcXFxzK0ZST00nLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWU6IHRhYmxlTmFtZS5yZXBsYWNlKC9bYFwiXFxbXFxdXS9nLCAnJyksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRGVsZXRlICR7YWZmZWN0ZWRSb3dzIHx8ICd1bmtub3duJ30gcm93KHMpIGZyb20gJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIGFmZmVjdGVkUm93c1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBpbnZlcnNlIFNRTCB0byB1bmRvIGEgY2hhbmdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJbnZlcnNlU1FMKGNoYW5nZTogRGF0YWJhc2VDaGFuZ2UpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IHsgdHlwZSwgb3BlcmF0aW9uLCB0YXJnZXQsIHF1ZXJ5LCB0YWJsZU5hbWUsIHRhcmdldFR5cGUsIHByZXZpb3VzSWRlbnRpZmllciwgc2NoZW1hVXBkYXRlLCBvbGRWYWx1ZXMgfSA9IGNoYW5nZTtcclxuXHJcbiAgICAvLyBIZWxwZXIgdG8gZm9ybWF0IHZhbHVlcyBmb3IgU1FMXHJcbiAgICBjb25zdCBmb3JtYXRTcWxWYWx1ZSA9ICh2OiBhbnkpID0+IHtcclxuICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHJldHVybiAnTlVMTCc7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBkYXRlcyAoaW5jbHVkaW5nIHN0cmluZ2lmaWVkIGRhdGVzIGZyb20gSlNPTilcclxuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBgJyR7di50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1QnLCAnICcpLnJlcGxhY2UoJ1onLCAnJykuc3BsaXQoJy4nKVswXX0nYDtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0vLnRlc3QodikpIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKHYpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGQuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAnJHtkLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnVCcsICcgJykucmVwbGFjZSgnWicsICcnKS5zcGxpdCgnLicpWzBdfSdgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgbnVtYmVycyAoaW5jbHVkaW5nIHN0cmluZ2lmaWVkIG51bWJlcnMgdGhhdCBzaG91bGQgYmUgbGl0ZXJhbClcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSByZXR1cm4gdjtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIC9eLT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodikgJiYgdi5sZW5ndGggPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHJldHVybiBgJyR7di5yZXBsYWNlKC8nL2csIFwiJydcIil9J2A7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHJldHVybiB2ID8gJzEnIDogJzAnO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHJldHVybiBgJyR7SlNPTi5zdHJpbmdpZnkodikucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgO1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTQ0hFTUEgUk9MTEJBQ0tTXHJcbiAgICBpZiAodHlwZSA9PT0gJ1NDSEVNQScpIHtcclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnQ1JFQVRFJykge1xyXG4gICAgICAgICAgICBjb25zdCBvYmpUeXBlID0gdGFyZ2V0VHlwZSB8fCAnVEFCTEUnO1xyXG4gICAgICAgICAgICByZXR1cm4gYERST1AgJHtvYmpUeXBlfSBJRiBFWElTVFMgJHt0YXJnZXR9O2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdEUk9QJykge1xyXG4gICAgICAgICAgICBpZiAocXVlcnkgJiYgKHF1ZXJ5LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0NSRUFURScpIHx8IHF1ZXJ5LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0FMVEVSJykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGAtLSBNYW51YWwgcmVzdG9yZSByZXF1aXJlZCBmb3IgZHJvcHBlZCAke3RhcmdldFR5cGUgfHwgJ09CSkVDVCd9ICR7dGFyZ2V0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdBTFRFUicpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdUQUJMRScgJiYgc2NoZW1hVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hVXBkYXRlID09PSAnQUREIENPTFVNTicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xNYXRjaCA9IHF1ZXJ5Py5tYXRjaCgvQUREXFxzK0NPTFVNTlxccysoW15cXFxcc1xcXFwoXFxcXCldKykvaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbE1hdGNoKSByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGFyZ2V0fSBEUk9QIENPTFVNTiAke2NvbE1hdGNoWzFdfTtgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBgLS0gTWFudWFsIHVuZG8gcmVxdWlyZWQgZm9yIEFMVEVSICR7dGFyZ2V0VHlwZSB8fCAnT0JKRUNUJ30gJHt0YXJnZXR9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ1JFTkFNRScpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdUQUJMRScgJiYgcHJldmlvdXNJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFJFTkFNRSBUQUJMRSAke3RhcmdldH0gVE8gJHtwcmV2aW91c0lkZW50aWZpZXJ9O2A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gREFUQSBST0xMQkFDS1NcclxuICAgIGlmICh0eXBlID09PSAnREFUQScpIHtcclxuICAgICAgICBjb25zdCB0YWJsZSA9IHRhYmxlTmFtZSB8fCB0YXJnZXQ7XHJcblxyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdVUERBVEUnICYmIG9sZFZhbHVlcyAmJiBvbGRWYWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVzLm1hcChyb3cgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHByaW1hcnkga2V5IG9yIGlkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkQ29sID0ga2V5cy5maW5kKGsgPT4gay50b0xvd2VyQ2FzZSgpID09PSAnaWQnIHx8IGsudG9Mb3dlckNhc2UoKSA9PT0gJ3V1aWQnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGtleXMuZmluZChrID0+IGsudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnX2lkJykgfHwgay50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCdpZCcpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGtleXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRWYWwgPSBmb3JtYXRTcWxWYWx1ZShyb3dbaWRDb2xdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0ga2V5c1xyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoayA9PiBrICE9PSBpZENvbClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGsgPT4gYCR7a30gPSAke2Zvcm1hdFNxbFZhbHVlKHJvd1trXSl9YClcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFVQREFURSAke3RhYmxlfSBTRVQgJHthc3NpZ25tZW50fSBXSEVSRSAke2lkQ29sfSA9ICR7aWRWYWx9O2A7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0RFTEVURScgJiYgb2xkVmFsdWVzICYmIG9sZFZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZXMubWFwKHJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocm93KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHMgPSBrZXlzLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxzID0ga2V5cy5tYXAoayA9PiBmb3JtYXRTcWxWYWx1ZShyb3dba10pKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJTlNFUlQgSU5UTyAke3RhYmxlfSAoJHtjb2xzfSkgVkFMVUVTICgke3ZhbHN9KTtgO1xyXG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdUUlVOQ0FURScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAtLSBNYW51YWwgZGF0YSByZXN0b3JlIHJlcXVpcmVkIGZvciB0cnVuY2F0ZWQgdGFibGUgJHt0YXJnZXR9LmA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERBVEFCQVNFIFJPTExCQUNLU1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09ICdEQVRBQkFTRScpIHtcclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnQ1JFQVRFJykgcmV0dXJuIGBEUk9QIERBVEFCQVNFICR7dGFyZ2V0fTtgO1xyXG4gICAgICAgIHJldHVybiBgLS0gTWFudWFsIGRhdGFiYXNlIHJlc3RvcmUgcmVxdWlyZWQgZm9yICR7dGFyZ2V0fS5gO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBFUk1JU1NJT04gUk9MTEJBQ0tTXHJcbiAgICBpZiAodHlwZSA9PT0gJ1BFUk1JU1NJT04nKSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0dSQU5UJykgcmV0dXJuIHF1ZXJ5Py5yZXBsYWNlKC9HUkFOVC9pLCAnUkVWT0tFJykucmVwbGFjZSgvIFRPIC9pLCAnIEZST00gJykgKyAnOycgfHwgbnVsbDtcclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnUkVWT0tFJykgcmV0dXJuIHF1ZXJ5Py5yZXBsYWNlKC9SRVZPS0UvaSwgJ0dSQU5UJykucmVwbGFjZSgvIEZST00gL2ksICcgVE8gJykgKyAnOycgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwZW5kaW5nIGNoYW5nZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdDaGFuZ2VzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUNoYW5nZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL3BlbmRpbmc/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhbmdlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBwZW5kaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbW1pdCBwZW5kaW5nIGNoYW5nZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21taXRDaGFuZ2VzKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgbmFtZTogc3RyaW5nOyBlbWFpbDogc3RyaW5nIH1cclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBhd2FpdCBnZXRQZW5kaW5nQ2hhbmdlcyhjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9jb21taXQnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcixcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21taXQgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGNvbW1pdCBoaXN0b3J5IGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21taXRIaXN0b3J5KGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2NvbW1pdD9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gZGF0YS5jb21taXRzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNvbW1pdCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYnJhbmNoZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2JyYW5jaGVzP2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBkYXRhLmJyYW5jaGVzIHx8IFtdLCBjdXJyZW50QnJhbmNoOiBkYXRhLmN1cnJlbnRCcmFuY2ggfHwgJ21haW4nIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYnJhbmNoZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBbXSwgY3VycmVudEJyYW5jaDogJ21haW4nIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgYnJhbmNoXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NyZWF0ZScgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGJyYW5jaDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogIFxyXG4gKiBDaGVja291dCBhIGJyYW5jaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrb3V0QnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NoZWNrb3V0JyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVja291dCBicmFuY2g6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidHJhY2tDaGFuZ2UiLCJjb25uZWN0aW9uSWQiLCJjaGFuZ2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsInRyYWNrU2NoZW1hQ2hhbmdlIiwib3BlcmF0aW9uIiwidGFibGVOYW1lIiwic3FsIiwiYXV0aG9yIiwidHlwZSIsInRvVXBwZXJDYXNlIiwidGFyZ2V0IiwiZGVzY3JpcHRpb24iLCJjaGFyQXQiLCJzbGljZSIsIm5hbWUiLCJxdWVyeSIsInBhcnNlUXVlcnlGb3JDaGFuZ2VzIiwiYWZmZWN0ZWRSb3dzIiwiY2xlYW5RdWVyeSIsInJlcGxhY2UiLCJ0cmltIiwibm9ybWFsaXplZFF1ZXJ5IiwiZ2V0SWRlbnRpZmllckFmdGVyIiwia2V5d29yZCIsImZyb21RdWVyeSIsInJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJpbmNsdWRlcyIsInRhcmdldFR5cGUiLCJzY2hlbWFVcGRhdGUiLCJ1bmRlZmluZWQiLCJkYk1hdGNoIiwib3AiLCJzdGFydHNXaXRoIiwicHJldmlvdXNJZGVudGlmaWVyIiwic2NoZW1hT2JqTWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImRyb3BPYmpNYXRjaCIsInN1YnN0cmluZyIsImdlbmVyYXRlSW52ZXJzZVNRTCIsIm9sZFZhbHVlcyIsImZvcm1hdFNxbFZhbHVlIiwidiIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidGVzdCIsImQiLCJpc05hTiIsImdldFRpbWUiLCJsZW5ndGgiLCJvYmpUeXBlIiwiY29sTWF0Y2giLCJ0YWJsZSIsIm1hcCIsInJvdyIsImtleXMiLCJPYmplY3QiLCJpZENvbCIsImZpbmQiLCJrIiwiZW5kc1dpdGgiLCJpZFZhbCIsImFzc2lnbm1lbnQiLCJmaWx0ZXIiLCJqb2luIiwiY29scyIsInZhbHMiLCJnZXRQZW5kaW5nQ2hhbmdlcyIsInJlc3BvbnNlIiwiZGF0YSIsImpzb24iLCJjaGFuZ2VzIiwiY29tbWl0Q2hhbmdlcyIsIm1lc3NhZ2UiLCJwZW5kaW5nIiwic25hcHNob3QiLCJzY2hlbWEiLCJ0YWJsZXMiLCJ0aW1lc3RhbXAiLCJyZXN1bHQiLCJzdWNjZXNzIiwiZ2V0Q29tbWl0SGlzdG9yeSIsImNvbW1pdHMiLCJnZXRCcmFuY2hlcyIsImJyYW5jaGVzIiwiY3VycmVudEJyYW5jaCIsImNyZWF0ZUJyYW5jaCIsImFjdGlvbiIsImNoZWNrb3V0QnJhbmNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/vcs-helper.ts\n"));

/***/ })

});