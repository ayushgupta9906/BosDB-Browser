"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/query/page",{

/***/ "(app-pages-browser)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: function() { return /* binding */ checkoutBranch; },\n/* harmony export */   commitChanges: function() { return /* binding */ commitChanges; },\n/* harmony export */   createBranch: function() { return /* binding */ createBranch; },\n/* harmony export */   generateRollbackSQL: function() { return /* binding */ generateRollbackSQL; },\n/* harmony export */   getBranches: function() { return /* binding */ getBranches; },\n/* harmony export */   getCommitHistory: function() { return /* binding */ getCommitHistory; },\n/* harmony export */   getPendingChanges: function() { return /* binding */ getPendingChanges; },\n/* harmony export */   parseQueryForChanges: function() { return /* binding */ parseQueryForChanges; },\n/* harmony export */   trackChange: function() { return /* binding */ trackChange; },\n/* harmony export */   trackSchemaChange: function() { return /* binding */ trackSchemaChange; }\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: \"\".concat(operation.charAt(0).toUpperCase() + operation.slice(1), \" table \").concat(tableName, \" by \").concat(author.name),\n        query: sql\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const match = cleanQuery.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: tableName,\n            tableName,\n            description: \"Create table \".concat(tableName),\n            query\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const match = cleanQuery.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: tableName,\n            tableName,\n            description: \"Alter table \".concat(tableName),\n            query\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const match = cleanQuery.match(/DROP\\s+TABLE\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: tableName,\n            tableName,\n            description: \"Drop table \".concat(tableName),\n            query\n        };\n    }\n    // Procedure/Function/View Schema changes\n    const procMatch = cleanQuery.match(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|ROUTINE)\\s+([`\"]?)(\\w+)\\2/i);\n    if (procMatch) {\n        const type = procMatch[1].toUpperCase();\n        const name = procMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create \".concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    const dropProcMatch = cleanQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|ROUTINE)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\2/i);\n    if (dropProcMatch) {\n        const type = dropProcMatch[1].toUpperCase();\n        const name = dropProcMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    // Data changes (DML) - typically start with the keyword\n    if (normalizedQuery.startsWith(\"INSERT INTO\")) {\n        const match = cleanQuery.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"INSERT\",\n            target: tableName,\n            tableName,\n            description: \"Insert \".concat(affectedRows || 1, \" row(s) into \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const match = cleanQuery.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName,\n            description: \"Update \".concat(affectedRows || \"unknown\", \" row(s) in \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const match = cleanQuery.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName,\n            description: \"Delete \".concat(affectedRows || \"unknown\", \" row(s) from \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    return null;\n}\n/**\r\n * Detect DDL/DML and generate rollback SQL using regex patterns\r\n */ function generateRollbackSQL(query, metadata) {\n    const q = query.trim().replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const upper = q.toUpperCase();\n    // 1. DDL: CREATE/DROP/RENAME TABLE\n    if (upper.startsWith(\"CREATE TABLE\")) {\n        const match = q.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP TABLE IF EXISTS \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP TABLE\")) {\n        // If we captured the original CREATE SQL in metadata\n        if (metadata === null || metadata === void 0 ? void 0 : metadata.originalCreateSQL) return metadata.originalCreateSQL;\n        return \"MANUAL\"; // Destructive without snapshot\n    }\n    if (upper.includes(\"RENAME TABLE\") || upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME TO\")) {\n        const match = q.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return match ? \"ALTER TABLE \".concat(match[5], \" RENAME TO \").concat(match[3], \";\") : \"MANUAL\";\n    }\n    // 2. DDL: COLUMN OPERATIONS\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"ADD\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:COLUMN\\s+)?([`\"]?)(\\w+)\\3/i);\n        return match ? \"ALTER TABLE \".concat(match[2], \" DROP COLUMN \").concat(match[4], \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"DROP COLUMN\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+DROP\\s+COLUMN\\s+([`\"]?)(\\w+)\\3/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.columnDefinition)) {\n            return \"ALTER TABLE \".concat(match[2], \" ADD COLUMN \").concat(metadata.columnDefinition, \";\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME COLUMN\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+COLUMN\\s+([`\"]?)(\\w+)\\3\\s+TO\\s+([`\"]?)(\\w+)\\5/i);\n        return match ? \"ALTER TABLE \".concat(match[2], \" RENAME COLUMN \").concat(match[6], \" TO \").concat(match[4], \";\") : \"MANUAL\";\n    }\n    // 3. DML: INSERT/UPDATE/DELETE\n    if (upper.startsWith(\"INSERT INTO\")) {\n        const match = q.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.primaryKey)) {\n            const table = match[2];\n            const pk = metadata.primaryKey;\n            const conditions = Object.entries(pk).map((param)=>{\n                let [col, val] = param;\n                return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n            }).join(\" AND \");\n            return \"DELETE FROM \".concat(table, \" WHERE \").concat(conditions, \";\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"DELETE FROM\")) {\n        const match = q.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.rows)) {\n            const table = match[2];\n            // Recursively generate INSERTS for all deleted rows\n            return metadata.rows.map((row)=>{\n                const cols = Object.keys(row).join(\", \");\n                const vals = Object.values(row).map((v)=>typeof v === \"string\" ? \"'\".concat(v, \"'\") : v).join(\", \");\n                return \"INSERT INTO \".concat(table, \" (\").concat(cols, \") VALUES (\").concat(vals, \");\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"UPDATE\")) {\n        const match = q.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.oldRows)) {\n            const table = match[2];\n            return metadata.oldRows.map((row)=>{\n                const pk = metadata.primaryKeyFields.reduce((acc, f)=>({\n                        ...acc,\n                        [f]: row[f]\n                    }), {});\n                const set = Object.entries(row).map((param)=>{\n                    let [col, val] = param;\n                    return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n                }).join(\", \");\n                const where = Object.entries(pk).map((param)=>{\n                    let [col, val] = param;\n                    return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n                }).join(\" AND \");\n                return \"UPDATE \".concat(table, \" SET \").concat(set, \" WHERE \").concat(where, \";\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    // 4. VIEWS / INDEX / PROCEDURES\n    if (upper.startsWith(\"CREATE VIEW\")) {\n        const match = q.match(/CREATE\\s+VIEW\\s+([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP VIEW \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"CREATE INDEX\")) {\n        const match = q.match(/CREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP INDEX \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"CREATE PROCEDURE\") || upper.startsWith(\"CREATE FUNCTION\")) {\n        const match = q.match(/CREATE\\s+(PROCEDURE|FUNCTION)\\s+([`\"]?)(\\w+)\\2/i);\n        return match ? \"DROP \".concat(match[1], \" \").concat(match[3], \";\") : \"MANUAL\";\n    }\n    // 5. PERMISSIONS\n    if (upper.startsWith(\"GRANT\")) {\n        return q.replace(/GRANT/i, \"REVOKE\").replace(/TO/i, \"FROM\");\n    }\n    if (upper.startsWith(\"REVOKE\")) {\n        return q.replace(/REVOKE/i, \"GRANT\").replace(/FROM/i, \"TO\");\n    }\n    // 6. DB / SCHEMA\n    if (upper.startsWith(\"CREATE DATABASE\")) return q.replace(/CREATE/i, \"DROP\");\n    if (upper.startsWith(\"CREATE SCHEMA\")) return q.replace(/CREATE/i, \"DROP\");\n    return \"MANUAL\";\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/pending?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/commit?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/branches?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdmNzLWhlbHBlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBaUJEOztDQUVDLEdBQ00sZUFBZUEsWUFBWUMsWUFBb0IsRUFBRUMsTUFBc0I7SUFDMUUsSUFBSTtRQUNBLE1BQU1DLE1BQU0sb0JBQW9CO1lBQzVCQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjQztZQUFPO1FBQ2hEO0lBQ0osRUFBRSxPQUFPTyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO0lBQzdDO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGtCQUNsQlYsWUFBb0IsRUFDcEJXLFNBQXNDLEVBQ3RDQyxTQUFpQixFQUNqQkMsR0FBVyxFQUNYQyxNQUFvQztJQUVwQyxNQUFNYixTQUF5QjtRQUMzQmMsTUFBTTtRQUNOSixXQUFXQSxVQUFVSyxXQUFXO1FBQ2hDQyxRQUFRTDtRQUNSQTtRQUNBTSxhQUFhLEdBQW1FTixPQUFoRUQsVUFBVVEsTUFBTSxDQUFDLEdBQUdILFdBQVcsS0FBS0wsVUFBVVMsS0FBSyxDQUFDLElBQUcsV0FBeUJOLE9BQWhCRixXQUFVLFFBQWtCLE9BQVpFLE9BQU9PLElBQUk7UUFDM0dDLE9BQU9UO0lBQ1g7SUFFQSxNQUFNZCxZQUFZQyxjQUFjQztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU3NCLHFCQUFxQkQsS0FBYSxFQUFFRSxZQUFxQjtJQUNyRSwyQkFBMkI7SUFDM0IsTUFBTUMsYUFBYUgsTUFBTUksT0FBTyxDQUFDLDZCQUE2QixJQUFJQyxJQUFJO0lBQ3RFLE1BQU1DLGtCQUFrQkgsV0FBV1QsV0FBVztJQUU5Qyx1QkFBdUI7SUFDdkIsSUFBSVksZ0JBQWdCQyxRQUFRLENBQUMsaUJBQWlCO1FBQzFDLE1BQU1DLFFBQVFMLFdBQVdLLEtBQUssQ0FBQztRQUMv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LGVBQWUrRSxlQUFldkYsWUFBb0IsRUFBRXFCLElBQVk7SUFDbkUsSUFBSTtRQUNBLE1BQU02QyxXQUFXLE1BQU1oRSxNQUFNLHFCQUFxQjtZQUM5Q0MsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFUDtnQkFBY3FCO2dCQUFNaUUsUUFBUTtZQUFXO1FBQ2xFO1FBQ0EsTUFBTVIsU0FBUyxNQUFNWixTQUFTRSxJQUFJO1FBQ2xDLE9BQU9VLE9BQU9DLE9BQU87SUFDekIsRUFBRSxPQUFPdkUsT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxPQUFPO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3Zjcy1oZWxwZXIudHM/YmM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVkNTIEludGVncmF0aW9uIEhlbHBlclxyXG4gKiBBdXRvbWF0aWNhbGx5IHRyYWNrcyBkYXRhYmFzZSBjaGFuZ2VzIGZvciB2ZXJzaW9uIGNvbnRyb2xcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFiYXNlQ2hhbmdlIHtcclxuICAgIGlkPzogc3RyaW5nO1xyXG4gICAgdHlwZTogJ1NDSEVNQScgfCAnREFUQScgfCAnQUNMJyB8ICdTWVNURU0nO1xyXG4gICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyB8ICdBTFRFUicgfCAnRFJPUCcgfCAnSU5TRVJUJyB8ICdVUERBVEUnIHwgJ0RFTEVURScgfCAnUkVOQU1FJyB8ICdUUlVOQ0FURScgfCAnR1JBTlQnIHwgJ1JFVk9LRSc7XHJcbiAgICB0YXJnZXQ6IHN0cmluZztcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgICBxdWVyeTogc3RyaW5nO1xyXG4gICAgcm9sbGJhY2tTUUw6IHN0cmluZyB8ICdNQU5VQUwnO1xyXG4gICAgc3RhdHVzOiAnQVBQTElFRCcgfCAnUkVWRVJURUQnO1xyXG4gICAgdGFibGVOYW1lPzogc3RyaW5nO1xyXG4gICAgYWZmZWN0ZWRSb3dzPzogbnVtYmVyO1xyXG4gICAgbWV0YWRhdGE/OiBhbnk7XHJcbiAgICB0aW1lc3RhbXA/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFjayBhIGRhdGFiYXNlIGNoYW5nZSBmb3IgdmVyc2lvbiBjb250cm9sXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2tDaGFuZ2UoY29ubmVjdGlvbklkOiBzdHJpbmcsIGNoYW5nZTogRGF0YWJhc2VDaGFuZ2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvdmNzL3BlbmRpbmcnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIGNoYW5nZSB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdHJhY2sgY2hhbmdlOicsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgc2NoZW1hIGNoYW5nZSAoQ1JFQVRFLCBBTFRFUiwgRFJPUCB0YWJsZSlcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja1NjaGVtYUNoYW5nZShcclxuICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxyXG4gICAgb3BlcmF0aW9uOiAnY3JlYXRlJyB8ICdhbHRlcicgfCAnZHJvcCcsXHJcbiAgICB0YWJsZU5hbWU6IHN0cmluZyxcclxuICAgIHNxbDogc3RyaW5nLFxyXG4gICAgYXV0aG9yOiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9XHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgY2hhbmdlOiBEYXRhYmFzZUNoYW5nZSA9IHtcclxuICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbi50b1VwcGVyQ2FzZSgpIGFzICdDUkVBVEUnIHwgJ0FMVEVSJyB8ICdEUk9QJyxcclxuICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGAke29wZXJhdGlvbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wZXJhdGlvbi5zbGljZSgxKX0gdGFibGUgJHt0YWJsZU5hbWV9IGJ5ICR7YXV0aG9yLm5hbWV9YCxcclxuICAgICAgICBxdWVyeTogc3FsXHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IHRyYWNrQ2hhbmdlKGNvbm5lY3Rpb25JZCwgY2hhbmdlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIFNRTCBxdWVyeSB0byBkZXRlY3QgY2hhbmdlIHR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5Rm9yQ2hhbmdlcyhxdWVyeTogc3RyaW5nLCBhZmZlY3RlZFJvd3M/OiBudW1iZXIpOiBEYXRhYmFzZUNoYW5nZSB8IG51bGwge1xyXG4gICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCB0cmltXHJcbiAgICBjb25zdCBjbGVhblF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3wtLS4qP1xcbi9nLCAnJykudHJpbSgpO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0gY2xlYW5RdWVyeS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIC8vIFRhYmxlIFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdDUkVBVEUgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvQ1JFQVRFXFxzK1RBQkxFXFxzKyg/OklGXFxzK05PVFxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQUxURVInLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEFsdGVyIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEUk9QIFRBQkxFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RST1BcXHMrVEFCTEVcXHMrKD86SUZcXHMrRVhJU1RTXFxzKyk/KFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRHJvcCB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VkdXJlL0Z1bmN0aW9uL1ZpZXcgU2NoZW1hIGNoYW5nZXNcclxuICAgIGNvbnN0IHByb2NNYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0NSRUFURVxccysoPzpPUlxccytSRVBMQUNFXFxzKyk/KFBST0NFRFVSRXxGVU5DVElPTnxWSUVXfFJPVVRJTkUpXFxzKyhbYFwiXT8pKFxcdyspXFwyL2kpO1xyXG4gICAgaWYgKHByb2NNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBwcm9jTWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvY01hdGNoWzNdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BQcm9jTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9EUk9QXFxzKyhQUk9DRURVUkV8RlVOQ1RJT058VklFV3xST1VUSU5FKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChkcm9wUHJvY01hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGRyb3BQcm9jTWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gZHJvcFByb2NNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERhdGEgY2hhbmdlcyAoRE1MKSAtIHR5cGljYWxseSBzdGFydCB3aXRoIHRoZSBrZXl3b3JkXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0lOU0VSVFxccytJTlRPXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdJTlNFUlQnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEluc2VydCAke2FmZmVjdGVkUm93cyB8fCAxfSByb3cocykgaW50byAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1VQREFURScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9VUERBVEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ1VQREFURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVXBkYXRlICR7YWZmZWN0ZWRSb3dzIHx8ICd1bmtub3duJ30gcm93KHMpIGluICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnREVMRVRFIEZST00nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvREVMRVRFXFxzK0ZST01cXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRGVsZXRlICR7YWZmZWN0ZWRSb3dzIHx8ICd1bmtub3duJ30gcm93KHMpIGZyb20gJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIGFmZmVjdGVkUm93c1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgRERML0RNTCBhbmQgZ2VuZXJhdGUgcm9sbGJhY2sgU1FMIHVzaW5nIHJlZ2V4IHBhdHRlcm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeTogc3RyaW5nLCBtZXRhZGF0YT86IGFueSk6IHN0cmluZyB8ICdNQU5VQUwnIHtcclxuICAgIGNvbnN0IHEgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3wtLS4qP1xcbi9nLCAnJykudHJpbSgpO1xyXG4gICAgY29uc3QgdXBwZXIgPSBxLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gMS4gRERMOiBDUkVBVEUvRFJPUC9SRU5BTUUgVEFCTEVcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdDUkVBVEUgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQ1JFQVRFXFxzK1RBQkxFXFxzKyg/OklGXFxzK05PVFxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHttYXRjaFsyXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdEUk9QIFRBQkxFJykpIHtcclxuICAgICAgICAvLyBJZiB3ZSBjYXB0dXJlZCB0aGUgb3JpZ2luYWwgQ1JFQVRFIFNRTCBpbiBtZXRhZGF0YVxyXG4gICAgICAgIGlmIChtZXRhZGF0YT8ub3JpZ2luYWxDcmVhdGVTUUwpIHJldHVybiBtZXRhZGF0YS5vcmlnaW5hbENyZWF0ZVNRTDtcclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7IC8vIERlc3RydWN0aXZlIHdpdGhvdXQgc25hcHNob3RcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ1JFTkFNRSBUQUJMRScpIHx8ICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnUkVOQU1FIFRPJykpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBxLm1hdGNoKC8oUkVOQU1FXFxzK1RBQkxFfEFMVEVSXFxzK1RBQkxFKVxccysoW2BcIl0/KShcXHcrKVxcMlxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDQvaSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gYEFMVEVSIFRBQkxFICR7bWF0Y2hbNV19IFJFTkFNRSBUTyAke21hdGNoWzNdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMi4gRERMOiBDT0xVTU4gT1BFUkFUSU9OU1xyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdBREQnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDFcXHMrQUREXFxzKyg/OkNPTFVNTlxccyspPyhbYFwiXT8pKFxcdyspXFwzL2kpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IGBBTFRFUiBUQUJMRSAke21hdGNoWzJdfSBEUk9QIENPTFVNTiAke21hdGNoWzRdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdEUk9QIENPTFVNTicpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBxLm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMVxccytEUk9QXFxzK0NPTFVNTlxccysoW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICBpZiAobWF0Y2ggJiYgbWV0YWRhdGE/LmNvbHVtbkRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke21hdGNoWzJdfSBBREQgQ09MVU1OICR7bWV0YWRhdGEuY29sdW1uRGVmaW5pdGlvbn07YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnUkVOQU1FIENPTFVNTicpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBxLm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMVxccytSRU5BTUVcXHMrQ09MVU1OXFxzKyhbYFwiXT8pKFxcdyspXFwzXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw1L2kpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IGBBTFRFUiBUQUJMRSAke21hdGNoWzJdfSBSRU5BTUUgQ09MVU1OICR7bWF0Y2hbNl19IFRPICR7bWF0Y2hbNF19O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyAzLiBETUw6IElOU0VSVC9VUERBVEUvREVMRVRFXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnSU5TRVJUIElOVE8nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvSU5TRVJUXFxzK0lOVE9cXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1ldGFkYXRhPy5wcmltYXJ5S2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IHBrID0gbWV0YWRhdGEucHJpbWFyeUtleTtcclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IE9iamVjdC5lbnRyaWVzKHBrKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoW2NvbCwgdmFsXSkgPT4gYCR7Y29sfSA9ICR7dHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBgJyR7dmFsfSdgIDogdmFsfWApXHJcbiAgICAgICAgICAgICAgICAuam9pbignIEFORCAnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RhYmxlfSBXSEVSRSAke2NvbmRpdGlvbnN9O2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnREVMRVRFIEZST00nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvREVMRVRFXFxzK0ZST01cXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1ldGFkYXRhPy5yb3dzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGdlbmVyYXRlIElOU0VSVFMgZm9yIGFsbCBkZWxldGVkIHJvd3NcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLnJvd3MubWFwKChyb3c6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29scyA9IE9iamVjdC5rZXlzKHJvdykuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHMgPSBPYmplY3QudmFsdWVzKHJvdykubWFwKHYgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3Z9J2AgOiB2KS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJTlNFUlQgSU5UTyAke3RhYmxlfSAoJHtjb2xzfSkgVkFMVUVTICgke3ZhbHN9KTtgO1xyXG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdVUERBVEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvVVBEQVRFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ub2xkUm93cykge1xyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEub2xkUm93cy5tYXAoKHJvdzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwayA9IG1ldGFkYXRhLnByaW1hcnlLZXlGaWVsZHMucmVkdWNlKChhY2M6IGFueSwgZjogc3RyaW5nKSA9PiAoeyAuLi5hY2MsIFtmXTogcm93W2ZdIH0pLCB7fSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBPYmplY3QuZW50cmllcyhyb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2NvbCwgdmFsXSkgPT4gYCR7Y29sfSA9ICR7dHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBgJyR7dmFsfSdgIDogdmFsfWApXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aGVyZSA9IE9iamVjdC5lbnRyaWVzKHBrKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtjb2wsIHZhbF0pID0+IGAke2NvbH0gPSAke3R5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gYCcke3ZhbH0nYCA6IHZhbH1gKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgQU5EICcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBVUERBVEUgJHt0YWJsZX0gU0VUICR7c2V0fSBXSEVSRSAke3doZXJlfTtgO1xyXG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDQuIFZJRVdTIC8gSU5ERVggLyBQUk9DRURVUkVTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFZJRVcnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQ1JFQVRFXFxzK1ZJRVdcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gYERST1AgVklFVyAke21hdGNoWzJdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIElOREVYJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0NSRUFURVxccysoPzpVTklRVUVcXHMrKT9JTkRFWFxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBgRFJPUCBJTkRFWCAke21hdGNoWzJdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFBST0NFRFVSRScpIHx8IHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBGVU5DVElPTicpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBxLm1hdGNoKC9DUkVBVEVcXHMrKFBST0NFRFVSRXxGVU5DVElPTilcXHMrKFtgXCJdPykoXFx3KylcXDIvaSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gYERST1AgJHttYXRjaFsxXX0gJHttYXRjaFszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDUuIFBFUk1JU1NJT05TXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnR1JBTlQnKSkge1xyXG4gICAgICAgIHJldHVybiBxLnJlcGxhY2UoL0dSQU5UL2ksICdSRVZPS0UnKS5yZXBsYWNlKC9UTy9pLCAnRlJPTScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ1JFVk9LRScpKSB7XHJcbiAgICAgICAgcmV0dXJuIHEucmVwbGFjZSgvUkVWT0tFL2ksICdHUkFOVCcpLnJlcGxhY2UoL0ZST00vaSwgJ1RPJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNi4gREIgLyBTQ0hFTUFcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdDUkVBVEUgREFUQUJBU0UnKSkgcmV0dXJuIHEucmVwbGFjZSgvQ1JFQVRFL2ksICdEUk9QJyk7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFNDSEVNQScpKSByZXR1cm4gcS5yZXBsYWNlKC9DUkVBVEUvaSwgJ0RST1AnKTtcclxuXHJcbiAgICByZXR1cm4gJ01BTlVBTCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcGVuZGluZyBjaGFuZ2VzIGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZW5kaW5nQ2hhbmdlcyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VDaGFuZ2VbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Zjcy9wZW5kaW5nP2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiBkYXRhLmNoYW5nZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgcGVuZGluZyBjaGFuZ2VzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21taXQgcGVuZGluZyBjaGFuZ2VzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tbWl0Q2hhbmdlcyhcclxuICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxyXG4gICAgbWVzc2FnZTogc3RyaW5nLFxyXG4gICAgYXV0aG9yOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZyB9XHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwZW5kaW5nID0gYXdhaXQgZ2V0UGVuZGluZ0NoYW5nZXMoY29ubmVjdGlvbklkKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvY29tbWl0Jywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICBhdXRob3IsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBwZW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHsgdGFibGVzOiB7fSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdGFibGVzOiB7fSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29tbWl0IGNoYW5nZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjb21taXQgaGlzdG9yeSBmb3IgYSBjb25uZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29tbWl0SGlzdG9yeShjb25uZWN0aW9uSWQ6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Zjcy9jb21taXQ/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY29tbWl0cyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBjb21taXQgaGlzdG9yeTonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGJyYW5jaGVzIGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcmFuY2hlcyhjb25uZWN0aW9uSWQ6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Zjcy9icmFuY2hlcz9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4geyBicmFuY2hlczogZGF0YS5icmFuY2hlcyB8fCBbXSwgY3VycmVudEJyYW5jaDogZGF0YS5jdXJyZW50QnJhbmNoIHx8ICdtYWluJyB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGJyYW5jaGVzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4geyBicmFuY2hlczogW10sIGN1cnJlbnRCcmFuY2g6ICdtYWluJyB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IGJyYW5jaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJyYW5jaChjb25uZWN0aW9uSWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdmNzL2JyYW5jaGVzJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29ubmVjdGlvbklkLCBuYW1lLCBhY3Rpb246ICdjcmVhdGUnIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBicmFuY2g6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqICBcclxuICogQ2hlY2tvdXQgYSBicmFuY2hcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja291dEJyYW5jaChjb25uZWN0aW9uSWQ6IHN0cmluZywgbmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdmNzL2JyYW5jaGVzJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29ubmVjdGlvbklkLCBuYW1lLCBhY3Rpb246ICdjaGVja291dCcgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2tvdXQgYnJhbmNoOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInRyYWNrQ2hhbmdlIiwiY29ubmVjdGlvbklkIiwiY2hhbmdlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJ0cmFja1NjaGVtYUNoYW5nZSIsIm9wZXJhdGlvbiIsInRhYmxlTmFtZSIsInNxbCIsImF1dGhvciIsInR5cGUiLCJ0b1VwcGVyQ2FzZSIsInRhcmdldCIsImRlc2NyaXB0aW9uIiwiY2hhckF0Iiwic2xpY2UiLCJuYW1lIiwicXVlcnkiLCJwYXJzZVF1ZXJ5Rm9yQ2hhbmdlcyIsImFmZmVjdGVkUm93cyIsImNsZWFuUXVlcnkiLCJyZXBsYWNlIiwidHJpbSIsIm5vcm1hbGl6ZWRRdWVyeSIsImluY2x1ZGVzIiwibWF0Y2giLCJwcm9jTWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImRyb3BQcm9jTWF0Y2giLCJzdGFydHNXaXRoIiwiZ2VuZXJhdGVSb2xsYmFja1NRTCIsIm1ldGFkYXRhIiwicSIsInVwcGVyIiwib3JpZ2luYWxDcmVhdGVTUUwiLCJjb2x1bW5EZWZpbml0aW9uIiwicHJpbWFyeUtleSIsInRhYmxlIiwicGsiLCJjb25kaXRpb25zIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImNvbCIsInZhbCIsImpvaW4iLCJyb3dzIiwicm93IiwiY29scyIsImtleXMiLCJ2YWxzIiwidmFsdWVzIiwidiIsIm9sZFJvd3MiLCJwcmltYXJ5S2V5RmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZiIsInNldCIsIndoZXJlIiwiZ2V0UGVuZGluZ0NoYW5nZXMiLCJyZXNwb25zZSIsImRhdGEiLCJqc29uIiwiY2hhbmdlcyIsImNvbW1pdENoYW5nZXMiLCJtZXNzYWdlIiwicGVuZGluZyIsInNuYXBzaG90Iiwic2NoZW1hIiwidGFibGVzIiwidGltZXN0YW1wIiwiRGF0ZSIsInJlc3VsdCIsInN1Y2Nlc3MiLCJnZXRDb21taXRIaXN0b3J5IiwiY29tbWl0cyIsImdldEJyYW5jaGVzIiwiYnJhbmNoZXMiLCJjdXJyZW50QnJhbmNoIiwiY3JlYXRlQnJhbmNoIiwiYWN0aW9uIiwiY2hlY2tvdXRCcmFuY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/vcs-helper.ts\n"));

/***/ })

});