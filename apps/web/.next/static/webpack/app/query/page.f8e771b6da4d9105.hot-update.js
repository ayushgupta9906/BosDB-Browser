"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/query/page",{

/***/ "(app-pages-browser)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: function() { return /* binding */ checkoutBranch; },\n/* harmony export */   commitChanges: function() { return /* binding */ commitChanges; },\n/* harmony export */   createBranch: function() { return /* binding */ createBranch; },\n/* harmony export */   generateInverseSQL: function() { return /* binding */ generateInverseSQL; },\n/* harmony export */   getBranches: function() { return /* binding */ getBranches; },\n/* harmony export */   getCommitHistory: function() { return /* binding */ getCommitHistory; },\n/* harmony export */   getPendingChanges: function() { return /* binding */ getPendingChanges; },\n/* harmony export */   parseQueryForChanges: function() { return /* binding */ parseQueryForChanges; },\n/* harmony export */   trackChange: function() { return /* binding */ trackChange; },\n/* harmony export */   trackSchemaChange: function() { return /* binding */ trackSchemaChange; }\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: \"\".concat(operation.charAt(0).toUpperCase() + operation.slice(1), \" table \").concat(tableName, \" by \").concat(author.name),\n        query: sql\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Helper to extract the next identifier after a keyword/phrase\n    const getIdentifierAfter = (keyword, fromQuery)=>{\n        const regex = new RegExp(\"\".concat(keyword, \"\\\\s+(?:IF\\\\s+NOT\\\\s+EXISTS\\\\s+|IF\\\\s+EXISTS\\\\s+)?([^\\\\s\\\\(\\\\);]+)\"), \"i\");\n        const match = fromQuery.match(regex);\n        return match ? match[1] : \"unknown\";\n    };\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const tableName = getIdentifierAfter(\"CREATE\\\\s+TABLE\", cleanQuery);\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Create table \".concat(tableName),\n            query\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const tableName = getIdentifierAfter(\"ALTER\\\\s+TABLE\", cleanQuery);\n        // Try to identify if it's ADD/DROP column for better rollback\n        let schemaUpdate = undefined;\n        if (normalizedQuery.includes(\"ADD COLUMN\")) schemaUpdate = \"ADD COLUMN\";\n        else if (normalizedQuery.includes(\"DROP COLUMN\")) schemaUpdate = \"DROP COLUMN\";\n        else if (normalizedQuery.includes(\"MODIFY\") || normalizedQuery.includes(\"ALTER COLUMN\")) schemaUpdate = \"MODIFY COLUMN\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Alter table \".concat(tableName),\n            query,\n            schemaUpdate\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const tableName = getIdentifierAfter(\"DROP\\\\s+TABLE\", cleanQuery);\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Drop table \".concat(tableName),\n            query\n        };\n    }\n    // Database changes\n    const dbMatch = cleanQuery.match(/(CREATE|DROP)\\s+DATABASE\\s+([^\\\\s\\\\(\\\\);]+)/i);\n    if (dbMatch) {\n        const op = dbMatch[1].toUpperCase();\n        const name = dbMatch[2];\n        return {\n            type: \"SCHEMA\",\n            operation: op,\n            targetType: \"DATABASE\",\n            target: name,\n            description: \"\".concat(op === \"CREATE\" ? \"Create\" : \"Drop\", \" database \").concat(name),\n            query\n        };\n    }\n    // Truncate\n    if (normalizedQuery.includes(\"TRUNCATE TABLE\") || normalizedQuery.startsWith(\"TRUNCATE \")) {\n        const tableName = getIdentifierAfter(\"TRUNCATE\\\\s+(?:TABLE\\\\s+)?\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"TRUNCATE\",\n            targetType: \"TABLE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Truncate table \".concat(tableName),\n            query\n        };\n    }\n    // Rename\n    if (normalizedQuery.includes(\"RENAME TABLE\")) {\n        const match = cleanQuery.match(/RENAME\\s+TABLE\\s+([^\\\\s,]+)\\s+TO\\s+([^\\\\s,;]+)/i);\n        if (match) {\n            return {\n                type: \"SCHEMA\",\n                operation: \"RENAME\",\n                targetType: \"TABLE\",\n                target: match[2],\n                previousIdentifier: match[1],\n                tableName: match[2].replace(/[`\"\\[\\]]/g, \"\"),\n                description: \"Rename table \".concat(match[1], \" to \").concat(match[2]),\n                query\n            };\n        }\n    }\n    // Procedure/Function/View Schema changes\n    const schemaObjMatch = cleanQuery.match(/(CREATE|ALTER)\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|ROUTINE|TRIGGER|INDEX)\\s+([^\\\\s\\\\(\\\\);]+)/i);\n    if (schemaObjMatch) {\n        const op = schemaObjMatch[1].toUpperCase();\n        const type = schemaObjMatch[2].toUpperCase();\n        const name = schemaObjMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: op,\n            targetType: type,\n            target: name,\n            description: \"\".concat(op === \"CREATE\" ? \"Create\" : \"Alter\", \" \").concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    const dropObjMatch = cleanQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|ROUTINE|TRIGGER|INDEX)\\s+(?:IF\\s+EXISTS\\s+)?([^\\\\s\\\\(\\\\);]+)/i);\n    if (dropObjMatch) {\n        const type = dropObjMatch[1].toUpperCase();\n        const name = dropObjMatch[2];\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            targetType: type,\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query\n        };\n    }\n    // Permissions\n    if (normalizedQuery.startsWith(\"GRANT \") || normalizedQuery.startsWith(\"REVOKE \")) {\n        const op = normalizedQuery.startsWith(\"GRANT \") ? \"GRANT\" : \"REVOKE\";\n        return {\n            type: \"PERMISSION\",\n            operation: op,\n            target: \"database\",\n            description: \"\".concat(op, \" permission: \").concat(cleanQuery.substring(0, 50), \"...\"),\n            query\n        };\n    }\n    // Data changes (DML)\n    if (normalizedQuery.startsWith(\"INSERT INTO\")) {\n        const tableName = getIdentifierAfter(\"INSERT\\\\s+INTO\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"INSERT\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Insert \".concat(affectedRows || 1, \" row(s) into \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const tableName = getIdentifierAfter(\"UPDATE\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Update \".concat(affectedRows || \"unknown\", \" row(s) in \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const tableName = getIdentifierAfter(\"DELETE\\\\s+FROM\", cleanQuery);\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName: tableName.replace(/[`\"\\[\\]]/g, \"\"),\n            description: \"Delete \".concat(affectedRows || \"unknown\", \" row(s) from \").concat(tableName),\n            query,\n            affectedRows\n        };\n    }\n    return null;\n}\n/**\r\n * Generate inverse SQL to undo a change\r\n */ function generateInverseSQL(change) {\n    const { type, operation, target, query, tableName, targetType, previousIdentifier, schemaUpdate, oldValues } = change;\n    // SCHEMA ROLLBACKS\n    if (type === \"SCHEMA\") {\n        if (operation === \"CREATE\") {\n            const objType = targetType || \"TABLE\";\n            return \"DROP \".concat(objType, \" IF EXISTS \").concat(target, \";\");\n        }\n        if (operation === \"DROP\") {\n            // Restore from original query if available\n            if (query && (query.toUpperCase().includes(\"CREATE\") || query.toUpperCase().includes(\"ALTER\"))) {\n                return query;\n            }\n            return \"-- Manual restore required for dropped \".concat(targetType || \"OBJECT\", \" \").concat(target);\n        }\n        if (operation === \"ALTER\") {\n            // Specific ALTER inverses if we have metadata\n            if (targetType === \"TABLE\" && schemaUpdate) {\n                if (schemaUpdate === \"ADD COLUMN\") {\n                    const colMatch = query === null || query === void 0 ? void 0 : query.match(/ADD\\s+COLUMN\\s+([^\\\\s\\\\(\\\\)]+)/i);\n                    if (colMatch) return \"ALTER TABLE \".concat(target, \" DROP COLUMN \").concat(colMatch[1], \";\");\n                }\n                if (schemaUpdate === \"DROP COLUMN\") {\n                    return \"-- Manual restore required: Column was dropped from \".concat(target, \". Query: \").concat(query);\n                }\n            }\n            // If it's a VIEW/PROC replacement, the original query might be a CREATE OR REPLACE\n            if (query && query.toUpperCase().includes(\"OR REPLACE\")) {\n                return \"-- Warning: Restore manual version of \".concat(targetType, \" \").concat(target, \" as it was replaced.\");\n            }\n            return \"-- Manual undo required for ALTER \".concat(targetType || \"OBJECT\", \" \").concat(target);\n        }\n        if (operation === \"RENAME\") {\n            if (targetType === \"TABLE\" && previousIdentifier) {\n                return \"RENAME TABLE \".concat(target, \" TO \").concat(previousIdentifier, \";\");\n            }\n            return \"-- Manual rename back from \".concat(target, \" required.\");\n        }\n    }\n    // DATABASE ROLLBACKS\n    if (targetType === \"DATABASE\") {\n        if (operation === \"CREATE\") return \"DROP DATABASE \".concat(target, \";\");\n        return \"-- Manual database restore required for \".concat(target, \".\");\n    }\n    // DATA ROLLBACKS\n    if (type === \"DATA\") {\n        const table = tableName || target;\n        if (operation === \"INSERT\") {\n            // If we have some values but not specifically PK, we try to match what was inserted\n            // This is risky but better than nothing\n            return \"-- Undo INSERT into \".concat(table, \"\\n-- Manual deletion required if Primary Key unknown.\");\n        }\n        if (operation === \"UPDATE\" && oldValues && oldValues.length > 0) {\n            return oldValues.map((row)=>{\n                const idCol = Object.keys(row).find((k)=>k.toLowerCase() === \"id\") || Object.keys(row)[0];\n                const idVal = typeof row[idCol] === \"string\" ? \"'\".concat(row[idCol], \"'\") : row[idCol];\n                const sets = Object.entries(row).filter((param)=>{\n                    let [k] = param;\n                    return k !== idCol;\n                }).map((param)=>{\n                    let [k, v] = param;\n                    return \"\".concat(k, \" = \").concat(typeof v === \"string\" ? \"'\".concat(v.replace(/'/g, \"''\"), \"'\") : v);\n                }).join(\", \");\n                return \"UPDATE \".concat(table, \" SET \").concat(sets, \" WHERE \").concat(idCol, \" = \").concat(idVal, \";\");\n            }).join(\"\\n\");\n        }\n        if (operation === \"DELETE\" && oldValues && oldValues.length > 0) {\n            return oldValues.map((row)=>{\n                const keys = Object.keys(row).join(\", \");\n                const values = Object.values(row).map((v)=>typeof v === \"string\" ? \"'\".concat(v.replace(/'/g, \"''\"), \"'\") : v === null ? \"NULL\" : v).join(\", \");\n                return \"INSERT INTO \".concat(table, \" (\").concat(keys, \") VALUES (\").concat(values, \");\");\n            }).join(\"\\n\");\n        }\n        if (operation === \"TRUNCATE\") {\n            return \"-- Manual data restore required for truncated table \".concat(target, \".\");\n        }\n        return \"-- Undo \".concat(operation, \" on \").concat(table, \"\\n-- Original values were not captured.\");\n    }\n    // PERMISSION ROLLBACKS\n    if (type === \"PERMISSION\") {\n        if (operation === \"GRANT\") return (query === null || query === void 0 ? void 0 : query.replace(/GRANT/i, \"REVOKE\").replace(/ TO /i, \" FROM \")) + \";\" || 0;\n        if (operation === \"REVOKE\") return (query === null || query === void 0 ? void 0 : query.replace(/REVOKE/i, \"GRANT\").replace(/ FROM /i, \" TO \")) + \";\" || 0;\n    }\n    return null;\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/pending?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/commit?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/branches?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdmNzLWhlbHBlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBa0JEOztDQUVDLEdBQ00sZUFBZUEsWUFBWUMsWUFBb0IsRUFBRUMsTUFBc0I7SUFDMUUsSUFBSTtRQUNBLE1BQU1DLE1BQU0sb0JBQW9CO1lBQzVCQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjQztZQUFPO1FBQ2hEO0lBQ0osRUFBRSxPQUFPTyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO0lBQzdDO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGtCQUNsQlYsWUFBb0IsRUFDcEJXLFNBQXNDLEVBQ3RDQyxTQUFpQixFQUNqQkMsR0FBVyxFQUNYQyxNQUFvQztJQUVwQyxNQUFNYixTQUF5QjtRQUMzQmMsTUFBTTtRQUNOSixXQUFXQSxVQUFVSyxXQUFXO1FBQ2hDQyxRQUFRTDtRQUNSQTtRQUNBTSxhQUFhLEdBQW1FTixPQUFoRUQsVUFBVVEsTUFBTSxDQUFDLEdBQUdILFdBQVcsS0FBS0wsVUFBVVMsS0FBSyxDQUFDLElBQUcsV0FBeUJOLE9BQWhCRixXQUFVLFFBQWtCLE9BQVpFLE9BQU9PLElBQUk7UUFDM0dDLE9BQU9UO0lBQ1g7SUFFQSxNQUFNZCxZQUFZQyxjQUFjQztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU3NCLHFCQUFxQkQsS0FBYSxFQUFFRSxZQUFxQjtJQUNyRSwyQkFBMkI7SUFDM0IsTUFBTUMsYUFBYUgsTUFBTUksT0FBTyxDQUFDLDZCQUE2QixJQUFJQyxJQUFJO0lBQ3RFLE1BQU1DLGtCQUFrQkgsV0FBV1QsV0FBVztJQUU5QywrREFBK0Q7SUFDL0QsTUFBTWEscUJBQXFCLENBQUNDLFNBQWlCQztRQUN6QyxNQUFNQyxRQUFRLElBQUlDLE9BQU8sR0FBVyxPQUFSSCxTQUFR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Q1g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3Zjcy1oZWxwZXIudHM/YmM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVkNTIEludGVncmF0aW9uIEhlbHBlclxyXG4gKiBBdXRvbWF0aWNhbGx5IHRyYWNrcyBkYXRhYmFzZSBjaGFuZ2VzIGZvciB2ZXJzaW9uIGNvbnRyb2xcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFiYXNlQ2hhbmdlIHtcclxuICAgIHR5cGU6ICdTQ0hFTUEnIHwgJ0RBVEEnIHwgJ1BFUk1JU1NJT04nIHwgJ0FETUlOJztcclxuICAgIG9wZXJhdGlvbjogJ0NSRUFURScgfCAnQUxURVInIHwgJ0RST1AnIHwgJ0lOU0VSVCcgfCAnVVBEQVRFJyB8ICdERUxFVEUnIHwgJ1JFTkFNRScgfCAnVFJVTkNBVEUnIHwgJ0dSQU5UJyB8ICdSRVZPS0UnO1xyXG4gICAgdGFyZ2V0VHlwZT86ICdUQUJMRScgfCAnVklFVycgfCAnUFJPQ0VEVVJFJyB8ICdGVU5DVElPTicgfCAnUk9VVElORScgfCAnVFJJR0dFUicgfCAnSU5ERVgnIHwgJ0RBVEFCQVNFJyB8ICdTQ0hFTUEnIHwgJ0NPTFVNTicgfCAnVVNFUicgfCAnUk9MRSc7XHJcbiAgICB0YXJnZXQ6IHN0cmluZztcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgICBxdWVyeT86IHN0cmluZztcclxuICAgIHRhYmxlTmFtZT86IHN0cmluZztcclxuICAgIGFmZmVjdGVkUm93cz86IG51bWJlcjtcclxuICAgIC8vIEFkdmFuY2VkIG1ldGFkYXRhIGZvciByb2xsYmFja1xyXG4gICAgb2xkVmFsdWVzPzogYW55W107IC8vIEZvciBVUERBVEUvREVMRVRFIHJvbGxiYWNrXHJcbiAgICBvbGRTY2hlbWE/OiBhbnk7ICAgLy8gRm9yIEFMVEVSL0RST1Agcm9sbGJhY2tcclxuICAgIHByZXZpb3VzSWRlbnRpZmllcj86IHN0cmluZzsgLy8gRm9yIFJFTkFNRVxyXG4gICAgc2NoZW1hVXBkYXRlPzogc3RyaW5nOyAvLyBTcGVjaWZpYyBwYXJ0IG9mIHNjaGVtYSB1cGRhdGVkIChlLmcuIFwiQUREIENPTFVNTlwiKVxyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgYSBkYXRhYmFzZSBjaGFuZ2UgZm9yIHZlcnNpb24gY29udHJvbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrQ2hhbmdlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBjaGFuZ2U6IERhdGFiYXNlQ2hhbmdlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9wZW5kaW5nJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29ubmVjdGlvbklkLCBjaGFuZ2UgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHRyYWNrIGNoYW5nZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFjayBhIHNjaGVtYSBjaGFuZ2UgKENSRUFURSwgQUxURVIsIERST1AgdGFibGUpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2tTY2hlbWFDaGFuZ2UoXHJcbiAgICBjb25uZWN0aW9uSWQ6IHN0cmluZyxcclxuICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScgfCAnYWx0ZXInIHwgJ2Ryb3AnLFxyXG4gICAgdGFibGVOYW1lOiBzdHJpbmcsXHJcbiAgICBzcWw6IHN0cmluZyxcclxuICAgIGF1dGhvcjogeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGNoYW5nZTogRGF0YWJhc2VDaGFuZ2UgPSB7XHJcbiAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24udG9VcHBlckNhc2UoKSBhcyAnQ1JFQVRFJyB8ICdBTFRFUicgfCAnRFJPUCcsXHJcbiAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvcGVyYXRpb24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcGVyYXRpb24uc2xpY2UoMSl9IHRhYmxlICR7dGFibGVOYW1lfSBieSAke2F1dGhvci5uYW1lfWAsXHJcbiAgICAgICAgcXVlcnk6IHNxbFxyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQsIGNoYW5nZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBTUUwgcXVlcnkgdG8gZGV0ZWN0IGNoYW5nZSB0eXBlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeUZvckNoYW5nZXMocXVlcnk6IHN0cmluZywgYWZmZWN0ZWRSb3dzPzogbnVtYmVyKTogRGF0YWJhc2VDaGFuZ2UgfCBudWxsIHtcclxuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgdHJpbVxyXG4gICAgY29uc3QgY2xlYW5RdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRRdWVyeSA9IGNsZWFuUXVlcnkudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAvLyBIZWxwZXIgdG8gZXh0cmFjdCB0aGUgbmV4dCBpZGVudGlmaWVyIGFmdGVyIGEga2V5d29yZC9waHJhc2VcclxuICAgIGNvbnN0IGdldElkZW50aWZpZXJBZnRlciA9IChrZXl3b3JkOiBzdHJpbmcsIGZyb21RdWVyeTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAke2tleXdvcmR9XFxcXHMrKD86SUZcXFxccytOT1RcXFxccytFWElTVFNcXFxccyt8SUZcXFxccytFWElTVFNcXFxccyspPyhbXlxcXFxzXFxcXChcXFxcKTtdKylgLCAnaScpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gZnJvbVF1ZXJ5Lm1hdGNoKHJlZ2V4KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICd1bmtub3duJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGFibGUgU2NoZW1hIGNoYW5nZXNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0NSRUFURSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gZ2V0SWRlbnRpZmllckFmdGVyKCdDUkVBVEVcXFxccytUQUJMRScsIGNsZWFuUXVlcnkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiAnVEFCTEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignQUxURVJcXFxccytUQUJMRScsIGNsZWFuUXVlcnkpO1xyXG4gICAgICAgIC8vIFRyeSB0byBpZGVudGlmeSBpZiBpdCdzIEFERC9EUk9QIGNvbHVtbiBmb3IgYmV0dGVyIHJvbGxiYWNrXHJcbiAgICAgICAgbGV0IHNjaGVtYVVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdBREQgQ09MVU1OJykpIHNjaGVtYVVwZGF0ZSA9ICdBREQgQ09MVU1OJztcclxuICAgICAgICBlbHNlIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0RST1AgQ09MVU1OJykpIHNjaGVtYVVwZGF0ZSA9ICdEUk9QIENPTFVNTic7XHJcbiAgICAgICAgZWxzZSBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdNT0RJRlknKSB8fCBub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0FMVEVSIENPTFVNTicpKSBzY2hlbWFVcGRhdGUgPSAnTU9ESUZZIENPTFVNTic7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdBTFRFUicsXHJcbiAgICAgICAgICAgIHRhcmdldFR5cGU6ICdUQUJMRScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWU6IHRhYmxlTmFtZS5yZXBsYWNlKC9bYFwiXFxbXFxdXS9nLCAnJyksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQWx0ZXIgdGFibGUgJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHNjaGVtYVVwZGF0ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnRFJPUCBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gZ2V0SWRlbnRpZmllckFmdGVyKCdEUk9QXFxcXHMrVEFCTEUnLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldFR5cGU6ICdUQUJMRScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWU6IHRhYmxlTmFtZS5yZXBsYWNlKC9bYFwiXFxbXFxdXS9nLCAnJyksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRHJvcCB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGF0YWJhc2UgY2hhbmdlc1xyXG4gICAgY29uc3QgZGJNYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goLyhDUkVBVEV8RFJPUClcXHMrREFUQUJBU0VcXHMrKFteXFxcXHNcXFxcKFxcXFwpO10rKS9pKTtcclxuICAgIGlmIChkYk1hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBkYk1hdGNoWzFdLnRvVXBwZXJDYXNlKCkgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBkYk1hdGNoWzJdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IG9wLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiAnREFUQUJBU0UnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvcCA9PT0gJ0NSRUFURScgPyAnQ3JlYXRlJyA6ICdEcm9wJ30gZGF0YWJhc2UgJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnVuY2F0ZVxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnVFJVTkNBVEUgVEFCTEUnKSB8fCBub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnVFJVTkNBVEUgJykpIHtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBnZXRJZGVudGlmaWVyQWZ0ZXIoJ1RSVU5DQVRFXFxcXHMrKD86VEFCTEVcXFxccyspPycsIGNsZWFuUXVlcnkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdEQVRBJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnVFJVTkNBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiAnVEFCTEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFRydW5jYXRlIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5hbWVcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ1JFTkFNRSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9SRU5BTUVcXHMrVEFCTEVcXHMrKFteXFxcXHMsXSspXFxzK1RPXFxzKyhbXlxcXFxzLDtdKykvaSk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ1JFTkFNRScsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRUeXBlOiAnVEFCTEUnLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBtYXRjaFsyXSxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzSWRlbnRpZmllcjogbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICB0YWJsZU5hbWU6IG1hdGNoWzJdLnJlcGxhY2UoL1tgXCJcXFtcXF1dL2csICcnKSxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUmVuYW1lIHRhYmxlICR7bWF0Y2hbMV19IHRvICR7bWF0Y2hbMl19YCxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb2NlZHVyZS9GdW5jdGlvbi9WaWV3IFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBjb25zdCBzY2hlbWFPYmpNYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goLyhDUkVBVEV8QUxURVIpXFxzKyg/Ok9SXFxzK1JFUExBQ0VcXHMrKT8oUFJPQ0VEVVJFfEZVTkNUSU9OfFZJRVd8Uk9VVElORXxUUklHR0VSfElOREVYKVxccysoW15cXFxcc1xcXFwoXFxcXCk7XSspL2kpO1xyXG4gICAgaWYgKHNjaGVtYU9iak1hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBzY2hlbWFPYmpNYXRjaFsxXS50b1VwcGVyQ2FzZSgpIGFzIGFueTtcclxuICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hT2JqTWF0Y2hbMl0udG9VcHBlckNhc2UoKSBhcyBhbnk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHNjaGVtYU9iak1hdGNoWzNdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IG9wLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvcCA9PT0gJ0NSRUFURScgPyAnQ3JlYXRlJyA6ICdBbHRlcid9ICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BPYmpNYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RST1BcXHMrKFBST0NFRFVSRXxGVU5DVElPTnxWSUVXfFJPVVRJTkV8VFJJR0dFUnxJTkRFWClcXHMrKD86SUZcXHMrRVhJU1RTXFxzKyk/KFteXFxcXHNcXFxcKFxcXFwpO10rKS9pKTtcclxuICAgIGlmIChkcm9wT2JqTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gZHJvcE9iak1hdGNoWzFdLnRvVXBwZXJDYXNlKCkgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBkcm9wT2JqTWF0Y2hbMl07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0RST1AnLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRHJvcCAke3R5cGUudG9Mb3dlckNhc2UoKX0gJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQZXJtaXNzaW9uc1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdHUkFOVCAnKSB8fCBub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnUkVWT0tFICcpKSB7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnR1JBTlQgJykgPyAnR1JBTlQnIDogJ1JFVk9LRSc7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1BFUk1JU1NJT04nLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IG9wLFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICdkYXRhYmFzZScsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvcH0gcGVybWlzc2lvbjogJHtjbGVhblF1ZXJ5LnN1YnN0cmluZygwLCA1MCl9Li4uYCxcclxuICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERhdGEgY2hhbmdlcyAoRE1MKVxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdJTlNFUlQgSU5UTycpKSB7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gZ2V0SWRlbnRpZmllckFmdGVyKCdJTlNFUlRcXFxccytJTlRPJywgY2xlYW5RdWVyeSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdJTlNFUlQnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lOiB0YWJsZU5hbWUucmVwbGFjZSgvW2BcIlxcW1xcXV0vZywgJycpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEluc2VydCAke2FmZmVjdGVkUm93cyB8fCAxfSByb3cocykgaW50byAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1VQREFURScpKSB7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gZ2V0SWRlbnRpZmllckFmdGVyKCdVUERBVEUnLCBjbGVhblF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ1VQREFURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWU6IHRhYmxlTmFtZS5yZXBsYWNlKC9bYFwiXFxbXFxdXS9nLCAnJyksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVXBkYXRlICR7YWZmZWN0ZWRSb3dzIHx8ICd1bmtub3duJ30gcm93KHMpIGluICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnREVMRVRFIEZST00nKSkge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGdldElkZW50aWZpZXJBZnRlcignREVMRVRFXFxcXHMrRlJPTScsIGNsZWFuUXVlcnkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdEQVRBJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnREVMRVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZTogdGFibGVOYW1lLnJlcGxhY2UoL1tgXCJcXFtcXF1dL2csICcnKSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEZWxldGUgJHthZmZlY3RlZFJvd3MgfHwgJ3Vua25vd24nfSByb3cocykgZnJvbSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGludmVyc2UgU1FMIHRvIHVuZG8gYSBjaGFuZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUludmVyc2VTUUwoY2hhbmdlOiBEYXRhYmFzZUNoYW5nZSk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgY29uc3QgeyB0eXBlLCBvcGVyYXRpb24sIHRhcmdldCwgcXVlcnksIHRhYmxlTmFtZSwgdGFyZ2V0VHlwZSwgcHJldmlvdXNJZGVudGlmaWVyLCBzY2hlbWFVcGRhdGUsIG9sZFZhbHVlcyB9ID0gY2hhbmdlO1xyXG5cclxuICAgIC8vIFNDSEVNQSBST0xMQkFDS1NcclxuICAgIGlmICh0eXBlID09PSAnU0NIRU1BJykge1xyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdDUkVBVEUnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ialR5cGUgPSB0YXJnZXRUeXBlIHx8ICdUQUJMRSc7XHJcbiAgICAgICAgICAgIHJldHVybiBgRFJPUCAke29ialR5cGV9IElGIEVYSVNUUyAke3RhcmdldH07YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0RST1AnKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgZnJvbSBvcmlnaW5hbCBxdWVyeSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5ICYmIChxdWVyeS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdDUkVBVEUnKSB8fCBxdWVyeS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdBTFRFUicpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBgLS0gTWFudWFsIHJlc3RvcmUgcmVxdWlyZWQgZm9yIGRyb3BwZWQgJHt0YXJnZXRUeXBlIHx8ICdPQkpFQ1QnfSAke3RhcmdldH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnQUxURVInKSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWNpZmljIEFMVEVSIGludmVyc2VzIGlmIHdlIGhhdmUgbWV0YWRhdGFcclxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdUQUJMRScgJiYgc2NoZW1hVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hVXBkYXRlID09PSAnQUREIENPTFVNTicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xNYXRjaCA9IHF1ZXJ5Py5tYXRjaCgvQUREXFxzK0NPTFVNTlxccysoW15cXFxcc1xcXFwoXFxcXCldKykvaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbE1hdGNoKSByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGFyZ2V0fSBEUk9QIENPTFVNTiAke2NvbE1hdGNoWzFdfTtgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVVwZGF0ZSA9PT0gJ0RST1AgQ09MVU1OJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgLS0gTWFudWFsIHJlc3RvcmUgcmVxdWlyZWQ6IENvbHVtbiB3YXMgZHJvcHBlZCBmcm9tICR7dGFyZ2V0fS4gUXVlcnk6ICR7cXVlcnl9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGEgVklFVy9QUk9DIHJlcGxhY2VtZW50LCB0aGUgb3JpZ2luYWwgcXVlcnkgbWlnaHQgYmUgYSBDUkVBVEUgT1IgUkVQTEFDRVxyXG4gICAgICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkudG9VcHBlckNhc2UoKS5pbmNsdWRlcygnT1IgUkVQTEFDRScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYC0tIFdhcm5pbmc6IFJlc3RvcmUgbWFudWFsIHZlcnNpb24gb2YgJHt0YXJnZXRUeXBlfSAke3RhcmdldH0gYXMgaXQgd2FzIHJlcGxhY2VkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGAtLSBNYW51YWwgdW5kbyByZXF1aXJlZCBmb3IgQUxURVIgJHt0YXJnZXRUeXBlIHx8ICdPQkpFQ1QnfSAke3RhcmdldH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnUkVOQU1FJykge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ1RBQkxFJyAmJiBwcmV2aW91c0lkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgUkVOQU1FIFRBQkxFICR7dGFyZ2V0fSBUTyAke3ByZXZpb3VzSWRlbnRpZmllcn07YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYC0tIE1hbnVhbCByZW5hbWUgYmFjayBmcm9tICR7dGFyZ2V0fSByZXF1aXJlZC5gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEQVRBQkFTRSBST0xMQkFDS1NcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAnREFUQUJBU0UnKSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0NSRUFURScpIHJldHVybiBgRFJPUCBEQVRBQkFTRSAke3RhcmdldH07YDtcclxuICAgICAgICByZXR1cm4gYC0tIE1hbnVhbCBkYXRhYmFzZSByZXN0b3JlIHJlcXVpcmVkIGZvciAke3RhcmdldH0uYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEQVRBIFJPTExCQUNLU1xyXG4gICAgaWYgKHR5cGUgPT09ICdEQVRBJykge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGFibGVOYW1lIHx8IHRhcmdldDtcclxuXHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0lOU0VSVCcpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21lIHZhbHVlcyBidXQgbm90IHNwZWNpZmljYWxseSBQSywgd2UgdHJ5IHRvIG1hdGNoIHdoYXQgd2FzIGluc2VydGVkXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmlza3kgYnV0IGJldHRlciB0aGFuIG5vdGhpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGAtLSBVbmRvIElOU0VSVCBpbnRvICR7dGFibGV9XFxuLS0gTWFudWFsIGRlbGV0aW9uIHJlcXVpcmVkIGlmIFByaW1hcnkgS2V5IHVua25vd24uYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdVUERBVEUnICYmIG9sZFZhbHVlcyAmJiBvbGRWYWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVzLm1hcChyb3cgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRDb2wgPSBPYmplY3Qua2V5cyhyb3cpLmZpbmQoayA9PiBrLnRvTG93ZXJDYXNlKCkgPT09ICdpZCcpIHx8IE9iamVjdC5rZXlzKHJvdylbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZFZhbCA9IHR5cGVvZiByb3dbaWRDb2xdID09PSAnc3RyaW5nJyA/IGAnJHtyb3dbaWRDb2xdfSdgIDogcm93W2lkQ29sXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXRzID0gT2JqZWN0LmVudHJpZXMocm93KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtrXSkgPT4gayAhPT0gaWRDb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfSA9ICR7dHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3YucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgIDogdn1gKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBgVVBEQVRFICR7dGFibGV9IFNFVCAke3NldHN9IFdIRVJFICR7aWRDb2x9ID0gJHtpZFZhbH07YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnREVMRVRFJyAmJiBvbGRWYWx1ZXMgJiYgb2xkVmFsdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlcy5tYXAocm93ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyb3cpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHJvdykubWFwKHYgPT5cclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7di5yZXBsYWNlKC8nL2csIFwiJydcIil9J2AgOiAodiA9PT0gbnVsbCA/ICdOVUxMJyA6IHYpXHJcbiAgICAgICAgICAgICAgICApLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYElOU0VSVCBJTlRPICR7dGFibGV9ICgke2tleXN9KSBWQUxVRVMgKCR7dmFsdWVzfSk7YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnVFJVTkNBVEUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgLS0gTWFudWFsIGRhdGEgcmVzdG9yZSByZXF1aXJlZCBmb3IgdHJ1bmNhdGVkIHRhYmxlICR7dGFyZ2V0fS5gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGAtLSBVbmRvICR7b3BlcmF0aW9ufSBvbiAke3RhYmxlfVxcbi0tIE9yaWdpbmFsIHZhbHVlcyB3ZXJlIG5vdCBjYXB0dXJlZC5gO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBFUk1JU1NJT04gUk9MTEJBQ0tTXHJcbiAgICBpZiAodHlwZSA9PT0gJ1BFUk1JU1NJT04nKSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ0dSQU5UJykgcmV0dXJuIHF1ZXJ5Py5yZXBsYWNlKC9HUkFOVC9pLCAnUkVWT0tFJykucmVwbGFjZSgvIFRPIC9pLCAnIEZST00gJykgKyAnOycgfHwgbnVsbDtcclxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnUkVWT0tFJykgcmV0dXJuIHF1ZXJ5Py5yZXBsYWNlKC9SRVZPS0UvaSwgJ0dSQU5UJykucmVwbGFjZSgvIEZST00gL2ksICcgVE8gJykgKyAnOycgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwZW5kaW5nIGNoYW5nZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdDaGFuZ2VzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUNoYW5nZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL3BlbmRpbmc/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhbmdlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBwZW5kaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbW1pdCBwZW5kaW5nIGNoYW5nZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21taXRDaGFuZ2VzKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgbmFtZTogc3RyaW5nOyBlbWFpbDogc3RyaW5nIH1cclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBhd2FpdCBnZXRQZW5kaW5nQ2hhbmdlcyhjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9jb21taXQnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcixcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21taXQgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGNvbW1pdCBoaXN0b3J5IGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21taXRIaXN0b3J5KGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2NvbW1pdD9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gZGF0YS5jb21taXRzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNvbW1pdCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYnJhbmNoZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2JyYW5jaGVzP2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBkYXRhLmJyYW5jaGVzIHx8IFtdLCBjdXJyZW50QnJhbmNoOiBkYXRhLmN1cnJlbnRCcmFuY2ggfHwgJ21haW4nIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYnJhbmNoZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBbXSwgY3VycmVudEJyYW5jaDogJ21haW4nIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgYnJhbmNoXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NyZWF0ZScgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGJyYW5jaDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogIFxyXG4gKiBDaGVja291dCBhIGJyYW5jaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrb3V0QnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NoZWNrb3V0JyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVja291dCBicmFuY2g6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidHJhY2tDaGFuZ2UiLCJjb25uZWN0aW9uSWQiLCJjaGFuZ2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsInRyYWNrU2NoZW1hQ2hhbmdlIiwib3BlcmF0aW9uIiwidGFibGVOYW1lIiwic3FsIiwiYXV0aG9yIiwidHlwZSIsInRvVXBwZXJDYXNlIiwidGFyZ2V0IiwiZGVzY3JpcHRpb24iLCJjaGFyQXQiLCJzbGljZSIsIm5hbWUiLCJxdWVyeSIsInBhcnNlUXVlcnlGb3JDaGFuZ2VzIiwiYWZmZWN0ZWRSb3dzIiwiY2xlYW5RdWVyeSIsInJlcGxhY2UiLCJ0cmltIiwibm9ybWFsaXplZFF1ZXJ5IiwiZ2V0SWRlbnRpZmllckFmdGVyIiwia2V5d29yZCIsImZyb21RdWVyeSIsInJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJpbmNsdWRlcyIsInRhcmdldFR5cGUiLCJzY2hlbWFVcGRhdGUiLCJ1bmRlZmluZWQiLCJkYk1hdGNoIiwib3AiLCJzdGFydHNXaXRoIiwicHJldmlvdXNJZGVudGlmaWVyIiwic2NoZW1hT2JqTWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImRyb3BPYmpNYXRjaCIsInN1YnN0cmluZyIsImdlbmVyYXRlSW52ZXJzZVNRTCIsIm9sZFZhbHVlcyIsIm9ialR5cGUiLCJjb2xNYXRjaCIsInRhYmxlIiwibGVuZ3RoIiwibWFwIiwicm93IiwiaWRDb2wiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImsiLCJpZFZhbCIsInNldHMiLCJlbnRyaWVzIiwiZmlsdGVyIiwidiIsImpvaW4iLCJ2YWx1ZXMiLCJnZXRQZW5kaW5nQ2hhbmdlcyIsInJlc3BvbnNlIiwiZGF0YSIsImpzb24iLCJjaGFuZ2VzIiwiY29tbWl0Q2hhbmdlcyIsIm1lc3NhZ2UiLCJwZW5kaW5nIiwic25hcHNob3QiLCJzY2hlbWEiLCJ0YWJsZXMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwicmVzdWx0Iiwic3VjY2VzcyIsImdldENvbW1pdEhpc3RvcnkiLCJjb21taXRzIiwiZ2V0QnJhbmNoZXMiLCJicmFuY2hlcyIsImN1cnJlbnRCcmFuY2giLCJjcmVhdGVCcmFuY2giLCJhY3Rpb24iLCJjaGVja291dEJyYW5jaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/vcs-helper.ts\n"));

/***/ })

});