"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/query/page",{

/***/ "(app-pages-browser)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: function() { return /* binding */ checkoutBranch; },\n/* harmony export */   commitChanges: function() { return /* binding */ commitChanges; },\n/* harmony export */   createBranch: function() { return /* binding */ createBranch; },\n/* harmony export */   generateRollbackSQL: function() { return /* binding */ generateRollbackSQL; },\n/* harmony export */   getBranches: function() { return /* binding */ getBranches; },\n/* harmony export */   getCommitHistory: function() { return /* binding */ getCommitHistory; },\n/* harmony export */   getPendingChanges: function() { return /* binding */ getPendingChanges; },\n/* harmony export */   parseQueryForChanges: function() { return /* binding */ parseQueryForChanges; },\n/* harmony export */   trackChange: function() { return /* binding */ trackChange; },\n/* harmony export */   trackSchemaChange: function() { return /* binding */ trackSchemaChange; }\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: \"\".concat(operation.charAt(0).toUpperCase() + operation.slice(1), \" table \").concat(tableName, \" by \").concat(author.name),\n        query: sql,\n        rollbackSQL: generateRollbackSQL(sql),\n        status: \"APPLIED\"\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const match = cleanQuery.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: tableName,\n            tableName,\n            description: \"Create table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const match = cleanQuery.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: tableName,\n            tableName,\n            description: \"Alter table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const match = cleanQuery.match(/DROP\\s+TABLE\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: tableName,\n            tableName,\n            description: \"Drop table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Procedure/Function/View Schema changes\n    const procMatch = cleanQuery.match(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|ROUTINE)\\s+([`\"]?)(\\w+)\\2/i);\n    if (procMatch) {\n        const type = procMatch[1].toUpperCase();\n        const name = procMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    const dropProcMatch = cleanQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|ROUTINE)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\2/i);\n    if (dropProcMatch) {\n        const type = dropProcMatch[1].toUpperCase();\n        const name = dropProcMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Data changes (DML) - typically start with the keyword\n    if (normalizedQuery.startsWith(\"INSERT INTO\")) {\n        const match = cleanQuery.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"INSERT\",\n            target: tableName,\n            tableName,\n            description: \"Insert \".concat(affectedRows || 1, \" row(s) into \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const match = cleanQuery.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName,\n            description: \"Update \".concat(affectedRows || \"unknown\", \" row(s) in \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const match = cleanQuery.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName,\n            description: \"Delete \".concat(affectedRows || \"unknown\", \" row(s) from \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    return null;\n}\n/**\r\n * Detect DDL/DML and generate rollback SQL using regex patterns\r\n */ function generateRollbackSQL(query, metadata) {\n    const q = query.trim().replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const upper = q.toUpperCase();\n    // 1. DDL: CREATE/DROP/RENAME TABLE\n    if (upper.startsWith(\"CREATE TABLE\")) {\n        const match = q.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP TABLE IF EXISTS \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP TABLE\")) {\n        // If we captured the original CREATE SQL in metadata\n        if (metadata === null || metadata === void 0 ? void 0 : metadata.originalCreateSQL) return metadata.originalCreateSQL;\n        return \"MANUAL\"; // Destructive without snapshot\n    }\n    if (upper.includes(\"RENAME TABLE\") || upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME TO\")) {\n        const match = q.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return match ? \"ALTER TABLE \".concat(match[5], \" RENAME TO \").concat(match[3], \";\") : \"MANUAL\";\n    }\n    // 2. DDL: COLUMN OPERATIONS\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"ADD\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:COLUMN\\s+)?([`\"]?)(\\w+)\\3/i);\n        return match ? \"ALTER TABLE \".concat(match[2], \" DROP COLUMN \").concat(match[4], \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"DROP COLUMN\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+DROP\\s+COLUMN\\s+([`\"]?)(\\w+)\\3/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.columnDefinition)) {\n            return \"ALTER TABLE \".concat(match[2], \" ADD COLUMN \").concat(metadata.columnDefinition, \";\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME COLUMN\")) {\n        const match = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+COLUMN\\s+([`\"]?)(\\w+)\\3\\s+TO\\s+([`\"]?)(\\w+)\\5/i);\n        return match ? \"ALTER TABLE \".concat(match[2], \" RENAME COLUMN \").concat(match[6], \" TO \").concat(match[4], \";\") : \"MANUAL\";\n    }\n    // 3. DML: INSERT/UPDATE/DELETE\n    if (upper.startsWith(\"INSERT INTO\")) {\n        const match = q.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.primaryKey)) {\n            const table = match[2];\n            const pk = metadata.primaryKey;\n            const conditions = Object.entries(pk).map((param)=>{\n                let [col, val] = param;\n                return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n            }).join(\" AND \");\n            return \"DELETE FROM \".concat(table, \" WHERE \").concat(conditions, \";\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"DELETE FROM\")) {\n        const match = q.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.rows)) {\n            const table = match[2];\n            // Recursively generate INSERTS for all deleted rows\n            return metadata.rows.map((row)=>{\n                const cols = Object.keys(row).join(\", \");\n                const vals = Object.values(row).map((v)=>typeof v === \"string\" ? \"'\".concat(v, \"'\") : v).join(\", \");\n                return \"INSERT INTO \".concat(table, \" (\").concat(cols, \") VALUES (\").concat(vals, \");\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"UPDATE\")) {\n        const match = q.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.oldRows)) {\n            const table = match[2];\n            return metadata.oldRows.map((row)=>{\n                const pk = metadata.primaryKeyFields.reduce((acc, f)=>({\n                        ...acc,\n                        [f]: row[f]\n                    }), {});\n                const set = Object.entries(row).map((param)=>{\n                    let [col, val] = param;\n                    return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n                }).join(\", \");\n                const where = Object.entries(pk).map((param)=>{\n                    let [col, val] = param;\n                    return \"\".concat(col, \" = \").concat(typeof val === \"string\" ? \"'\".concat(val, \"'\") : val);\n                }).join(\" AND \");\n                return \"UPDATE \".concat(table, \" SET \").concat(set, \" WHERE \").concat(where, \";\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    // 4. VIEWS / INDEX / PROCEDURES\n    if (upper.startsWith(\"CREATE VIEW\")) {\n        const match = q.match(/CREATE\\s+VIEW\\s+([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP VIEW \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"CREATE INDEX\")) {\n        const match = q.match(/CREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i);\n        return match ? \"DROP INDEX \".concat(match[2], \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"CREATE PROCEDURE\") || upper.startsWith(\"CREATE FUNCTION\")) {\n        const match = q.match(/CREATE\\s+(PROCEDURE|FUNCTION)\\s+([`\"]?)(\\w+)\\2/i);\n        return match ? \"DROP \".concat(match[1], \" \").concat(match[3], \";\") : \"MANUAL\";\n    }\n    // 5. PERMISSIONS\n    if (upper.startsWith(\"GRANT\")) {\n        return q.replace(/GRANT/i, \"REVOKE\").replace(/TO/i, \"FROM\");\n    }\n    if (upper.startsWith(\"REVOKE\")) {\n        return q.replace(/REVOKE/i, \"GRANT\").replace(/FROM/i, \"TO\");\n    }\n    // 6. DB / SCHEMA\n    if (upper.startsWith(\"CREATE DATABASE\")) return q.replace(/CREATE/i, \"DROP\");\n    if (upper.startsWith(\"CREATE SCHEMA\")) return q.replace(/CREATE/i, \"DROP\");\n    return \"MANUAL\";\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/pending?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/commit?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/branches?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdmNzLWhlbHBlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBaUJEOztDQUVDLEdBQ00sZUFBZUEsWUFBWUMsWUFBb0IsRUFBRUMsTUFBc0I7SUFDMUUsSUFBSTtRQUNBLE1BQU1DLE1BQU0sb0JBQW9CO1lBQzVCQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjQztZQUFPO1FBQ2hEO0lBQ0osRUFBRSxPQUFPTyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO0lBQzdDO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGtCQUNsQlYsWUFBb0IsRUFDcEJXLFNBQXNDLEVBQ3RDQyxTQUFpQixFQUNqQkMsR0FBVyxFQUNYQyxNQUFvQztJQUVwQyxNQUFNYixTQUF5QjtRQUMzQmMsTUFBTTtRQUNOSixXQUFXQSxVQUFVSyxXQUFXO1FBQ2hDQyxRQUFRTDtRQUNSQTtRQUNBTSxhQUFhLEdBQW1FTixPQUFoRUQsVUFBVVEsTUFBTSxDQUFDLEdBQUdILFdBQVcsS0FBS0wsVUFBVVMsS0FBSyxDQUFDLElBQUcsV0FBeUJOLE9BQWhCRixXQUFVLFFBQWtCLE9BQVpFLE9BQU9PLElBQUk7UUFDM0dDLE9BQU9UO1FBQ1BVLGFBQWFDLG9CQUFvQlg7UUFDakNZLFFBQVE7SUFDWjtJQUVBLE1BQU0xQixZQUFZQyxjQUFjQztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU3lCLHFCQUFxQkosS0FBYSxFQUFFSyxZQUFxQjtJQUNyRSwyQkFBMkI7SUFDM0IsTUFBTUMsYUFBYU4sTUFBTU8sT0FBTyxDQUFDLDZCQUE2QixJQUFJQyxJQUFJO0lBQ3RFLE1BQU1DLGtCQUFrQkgsV0FBV1osV0FBVztJQUU5Qyx1QkFBdUI7SUFDdkIsSUFBSWUsZ0JBQWdCQyxRQUFRLENBQUMsaUJBQWlCO1FBQzFD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LE1BQU0scUJBQXFCO1lBQzlDQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjcUI7Z0JBQU1tRSxRQUFRO1lBQVM7UUFDaEU7UUFDQSxNQUFNUixTQUFTLE1BQU1aLFNBQVNFLElBQUk7UUFDbEMsT0FBT1UsT0FBT0MsT0FBTztJQUN6QixFQUFFLE9BQU96RSxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDTSxlQUFlaUYsZUFBZXpGLFlBQW9CLEVBQUVxQixJQUFZO0lBQ25FLElBQUk7UUFDQSxNQUFNK0MsV0FBVyxNQUFNbEUsTUFBTSxxQkFBcUI7WUFDOUNDLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFBRVA7Z0JBQWNxQjtnQkFBTW1FLFFBQVE7WUFBVztRQUNsRTtRQUNBLE1BQU1SLFNBQVMsTUFBTVosU0FBU0UsSUFBSTtRQUNsQyxPQUFPVSxPQUFPQyxPQUFPO0lBQ3pCLEVBQUUsT0FBT3pFLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi92Y3MtaGVscGVyLnRzP2JjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFZDUyBJbnRlZ3JhdGlvbiBIZWxwZXJcclxuICogQXV0b21hdGljYWxseSB0cmFja3MgZGF0YWJhc2UgY2hhbmdlcyBmb3IgdmVyc2lvbiBjb250cm9sXHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEYXRhYmFzZUNoYW5nZSB7XHJcbiAgICBpZD86IHN0cmluZztcclxuICAgIHR5cGU6ICdTQ0hFTUEnIHwgJ0RBVEEnIHwgJ0FDTCcgfCAnU1lTVEVNJztcclxuICAgIG9wZXJhdGlvbjogJ0NSRUFURScgfCAnQUxURVInIHwgJ0RST1AnIHwgJ0lOU0VSVCcgfCAnVVBEQVRFJyB8ICdERUxFVEUnIHwgJ1JFTkFNRScgfCAnVFJVTkNBVEUnIHwgJ0dSQU5UJyB8ICdSRVZPS0UnO1xyXG4gICAgdGFyZ2V0OiBzdHJpbmc7XHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gICAgcXVlcnk6IHN0cmluZztcclxuICAgIHJvbGxiYWNrU1FMOiBzdHJpbmcgfCAnTUFOVUFMJztcclxuICAgIHN0YXR1czogJ0FQUExJRUQnIHwgJ1JFVkVSVEVEJztcclxuICAgIHRhYmxlTmFtZT86IHN0cmluZztcclxuICAgIGFmZmVjdGVkUm93cz86IG51bWJlcjtcclxuICAgIG1ldGFkYXRhPzogYW55O1xyXG4gICAgdGltZXN0YW1wPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgYSBkYXRhYmFzZSBjaGFuZ2UgZm9yIHZlcnNpb24gY29udHJvbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrQ2hhbmdlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBjaGFuZ2U6IERhdGFiYXNlQ2hhbmdlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9wZW5kaW5nJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29ubmVjdGlvbklkLCBjaGFuZ2UgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHRyYWNrIGNoYW5nZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFjayBhIHNjaGVtYSBjaGFuZ2UgKENSRUFURSwgQUxURVIsIERST1AgdGFibGUpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2tTY2hlbWFDaGFuZ2UoXHJcbiAgICBjb25uZWN0aW9uSWQ6IHN0cmluZyxcclxuICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScgfCAnYWx0ZXInIHwgJ2Ryb3AnLFxyXG4gICAgdGFibGVOYW1lOiBzdHJpbmcsXHJcbiAgICBzcWw6IHN0cmluZyxcclxuICAgIGF1dGhvcjogeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGNoYW5nZTogRGF0YWJhc2VDaGFuZ2UgPSB7XHJcbiAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24udG9VcHBlckNhc2UoKSBhcyAnQ1JFQVRFJyB8ICdBTFRFUicgfCAnRFJPUCcsXHJcbiAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtvcGVyYXRpb24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcGVyYXRpb24uc2xpY2UoMSl9IHRhYmxlICR7dGFibGVOYW1lfSBieSAke2F1dGhvci5uYW1lfWAsXHJcbiAgICAgICAgcXVlcnk6IHNxbCxcclxuICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChzcWwpLFxyXG4gICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IHRyYWNrQ2hhbmdlKGNvbm5lY3Rpb25JZCwgY2hhbmdlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIFNRTCBxdWVyeSB0byBkZXRlY3QgY2hhbmdlIHR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5Rm9yQ2hhbmdlcyhxdWVyeTogc3RyaW5nLCBhZmZlY3RlZFJvd3M/OiBudW1iZXIpOiBEYXRhYmFzZUNoYW5nZSB8IG51bGwge1xyXG4gICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCB0cmltXHJcbiAgICBjb25zdCBjbGVhblF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3wtLS4qP1xcbi9nLCAnJykudHJpbSgpO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0gY2xlYW5RdWVyeS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIC8vIFRhYmxlIFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdDUkVBVEUgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvQ1JFQVRFXFxzK1RBQkxFXFxzKyg/OklGXFxzK05PVFxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQUxURVInLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEFsdGVyIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEUk9QIFRBQkxFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RST1BcXHMrVEFCTEVcXHMrKD86SUZcXHMrRVhJU1RTXFxzKyk/KFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRHJvcCB0YWJsZSAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VkdXJlL0Z1bmN0aW9uL1ZpZXcgU2NoZW1hIGNoYW5nZXNcclxuICAgIGNvbnN0IHByb2NNYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0NSRUFURVxccysoPzpPUlxccytSRVBMQUNFXFxzKyk/KFBST0NFRFVSRXxGVU5DVElPTnxWSUVXfFJPVVRJTkUpXFxzKyhbYFwiXT8pKFxcdyspXFwyL2kpO1xyXG4gICAgaWYgKHByb2NNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBwcm9jTWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvY01hdGNoWzNdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BQcm9jTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9EUk9QXFxzKyhQUk9DRURVUkV8RlVOQ1RJT058VklFV3xST1VUSU5FKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChkcm9wUHJvY01hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGRyb3BQcm9jTWF0Y2hbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gZHJvcFByb2NNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERhdGEgY2hhbmdlcyAoRE1MKSAtIHR5cGljYWxseSBzdGFydCB3aXRoIHRoZSBrZXl3b3JkXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0lOU0VSVFxccytJTlRPXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdJTlNFUlQnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEluc2VydCAke2FmZmVjdGVkUm93cyB8fCAxfSByb3cocykgaW50byAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsIC8vIE5lZWRzIG1ldGFkYXRhIGZvciBhY2N1cmF0ZSByb2xsYmFja1xyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdVUERBVEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvVVBEQVRFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdVUERBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVwZGF0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBpbiAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsIC8vIE5lZWRzIG1ldGFkYXRhXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdERUxFVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERlbGV0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBmcm9tICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3MsXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiAnTUFOVUFMJywgLy8gTmVlZHMgbWV0YWRhdGFcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IERETC9ETUwgYW5kIGdlbmVyYXRlIHJvbGxiYWNrIFNRTCB1c2luZyByZWdleCBwYXR0ZXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnk6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpOiBzdHJpbmcgfCAnTUFOVUFMJyB7XHJcbiAgICBjb25zdCBxID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IHVwcGVyID0gcS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIC8vIDEuIERETDogQ1JFQVRFL0RST1AvUkVOQU1FIFRBQkxFXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFRBQkxFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0NSRUFURVxccytUQUJMRVxccysoPzpJRlxccytOT1RcXHMrRVhJU1RTXFxzKyk/KFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7bWF0Y2hbMl19O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnRFJPUCBUQUJMRScpKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgY2FwdHVyZWQgdGhlIG9yaWdpbmFsIENSRUFURSBTUUwgaW4gbWV0YWRhdGFcclxuICAgICAgICBpZiAobWV0YWRhdGE/Lm9yaWdpbmFsQ3JlYXRlU1FMKSByZXR1cm4gbWV0YWRhdGEub3JpZ2luYWxDcmVhdGVTUUw7XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnOyAvLyBEZXN0cnVjdGl2ZSB3aXRob3V0IHNuYXBzaG90XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRU5BTUUgVEFCTEUnKSB8fCAodXBwZXIuaW5jbHVkZXMoJ0FMVEVSIFRBQkxFJykgJiYgdXBwZXIuaW5jbHVkZXMoJ1JFTkFNRSBUTycpKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvKFJFTkFNRVxccytUQUJMRXxBTFRFUlxccytUQUJMRSlcXHMrKFtgXCJdPykoXFx3KylcXDJcXHMrUkVOQU1FXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw0L2kpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IGBBTFRFUiBUQUJMRSAke21hdGNoWzVdfSBSRU5BTUUgVE8gJHttYXRjaFszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDIuIERETDogQ09MVU1OIE9QRVJBVElPTlNcclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnQUREJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK0FERFxccysoPzpDT0xVTU5cXHMrKT8oW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBgQUxURVIgVEFCTEUgJHttYXRjaFsyXX0gRFJPUCBDT0xVTU4gJHttYXRjaFs0XX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnRFJPUCBDT0xVTU4nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDFcXHMrRFJPUFxccytDT0xVTU5cXHMrKFtgXCJdPykoXFx3KylcXDMvaSk7XHJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1ldGFkYXRhPy5jb2x1bW5EZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHttYXRjaFsyXX0gQUREIENPTFVNTiAke21ldGFkYXRhLmNvbHVtbkRlZmluaXRpb259O2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ0FMVEVSIFRBQkxFJykgJiYgdXBwZXIuaW5jbHVkZXMoJ1JFTkFNRSBDT0xVTU4nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDFcXHMrUkVOQU1FXFxzK0NPTFVNTlxccysoW2BcIl0/KShcXHcrKVxcM1xccytUT1xccysoW2BcIl0/KShcXHcrKVxcNS9pKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBgQUxURVIgVEFCTEUgJHttYXRjaFsyXX0gUkVOQU1FIENPTFVNTiAke21hdGNoWzZdfSBUTyAke21hdGNoWzRdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4gRE1MOiBJTlNFUlQvVVBEQVRFL0RFTEVURVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0lOU0VSVFxccytJTlRPXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucHJpbWFyeUtleSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICBjb25zdCBwayA9IG1ldGFkYXRhLnByaW1hcnlLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBPYmplY3QuZW50cmllcyhwaylcclxuICAgICAgICAgICAgICAgIC5tYXAoKFtjb2wsIHZhbF0pID0+IGAke2NvbH0gPSAke3R5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gYCcke3ZhbH0nYCA6IHZhbH1gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJyBBTkQgJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0YWJsZX0gV0hFUkUgJHtjb25kaXRpb25zfTtgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucm93cykge1xyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBnZW5lcmF0ZSBJTlNFUlRTIGZvciBhbGwgZGVsZXRlZCByb3dzXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YS5yb3dzLm1hcCgocm93OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHMgPSBPYmplY3Qua2V5cyhyb3cpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxzID0gT2JqZWN0LnZhbHVlcyhyb3cpLm1hcCh2ID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGAnJHt2fSdgIDogdikuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgSU5TRVJUIElOVE8gJHt0YWJsZX0gKCR7Y29sc30pIFZBTFVFUyAoJHt2YWxzfSk7YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnVVBEQVRFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL1VQREFURVxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBpZiAobWF0Y2ggJiYgbWV0YWRhdGE/Lm9sZFJvd3MpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBtYXRjaFsyXTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLm9sZFJvd3MubWFwKChyb3c6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBtZXRhZGF0YS5wcmltYXJ5S2V5RmllbGRzLnJlZHVjZSgoYWNjOiBhbnksIGY6IHN0cmluZykgPT4gKHsgLi4uYWNjLCBbZl06IHJvd1tmXSB9KSwge30pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gT2JqZWN0LmVudHJpZXMocm93KVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtjb2wsIHZhbF0pID0+IGAke2NvbH0gPSAke3R5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gYCcke3ZhbH0nYCA6IHZhbH1gKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlcmUgPSBPYmplY3QuZW50cmllcyhwaylcclxuICAgICAgICAgICAgICAgICAgICAubWFwKChbY29sLCB2YWxdKSA9PiBgJHtjb2x9ID0gJHt0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGAnJHt2YWx9J2AgOiB2YWx9YClcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignIEFORCAnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgVVBEQVRFICR7dGFibGV9IFNFVCAke3NldH0gV0hFUkUgJHt3aGVyZX07YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBWSUVXUyAvIElOREVYIC8gUFJPQ0VEVVJFU1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBWSUVXJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0NSRUFURVxccytWSUVXXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IGBEUk9QIFZJRVcgJHttYXRjaFsyXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBJTkRFWCcpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBxLm1hdGNoKC9DUkVBVEVcXHMrKD86VU5JUVVFXFxzKyk/SU5ERVhcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gYERST1AgSU5ERVggJHttYXRjaFsyXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBQUk9DRURVUkUnKSB8fCB1cHBlci5zdGFydHNXaXRoKCdDUkVBVEUgRlVOQ1RJT04nKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcS5tYXRjaCgvQ1JFQVRFXFxzKyhQUk9DRURVUkV8RlVOQ1RJT04pXFxzKyhbYFwiXT8pKFxcdyspXFwyL2kpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IGBEUk9QICR7bWF0Y2hbMV19ICR7bWF0Y2hbM119O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyA1LiBQRVJNSVNTSU9OU1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0dSQU5UJykpIHtcclxuICAgICAgICByZXR1cm4gcS5yZXBsYWNlKC9HUkFOVC9pLCAnUkVWT0tFJykucmVwbGFjZSgvVE8vaSwgJ0ZST00nKTtcclxuICAgIH1cclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdSRVZPS0UnKSkge1xyXG4gICAgICAgIHJldHVybiBxLnJlcGxhY2UoL1JFVk9LRS9pLCAnR1JBTlQnKS5yZXBsYWNlKC9GUk9NL2ksICdUTycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDYuIERCIC8gU0NIRU1BXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIERBVEFCQVNFJykpIHJldHVybiBxLnJlcGxhY2UoL0NSRUFURS9pLCAnRFJPUCcpO1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBTQ0hFTUEnKSkgcmV0dXJuIHEucmVwbGFjZSgvQ1JFQVRFL2ksICdEUk9QJyk7XHJcblxyXG4gICAgcmV0dXJuICdNQU5VQUwnO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHBlbmRpbmcgY2hhbmdlcyBmb3IgYSBjb25uZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVuZGluZ0NoYW5nZXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPERhdGFiYXNlQ2hhbmdlW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92Y3MvcGVuZGluZz9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gZGF0YS5jaGFuZ2VzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHBlbmRpbmcgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tbWl0IHBlbmRpbmcgY2hhbmdlc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbW1pdENoYW5nZXMoXHJcbiAgICBjb25uZWN0aW9uSWQ6IHN0cmluZyxcclxuICAgIG1lc3NhZ2U6IHN0cmluZyxcclxuICAgIGF1dGhvcjogeyBuYW1lOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmcgfVxyXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IGF3YWl0IGdldFBlbmRpbmdDaGFuZ2VzKGNvbm5lY3Rpb25JZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdmNzL2NvbW1pdCcsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogcGVuZGluZyxcclxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiB7IHRhYmxlczoge30gfSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHRhYmxlczoge30gfSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvbW1pdCBjaGFuZ2VzOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgY29tbWl0IGhpc3RvcnkgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbW1pdEhpc3RvcnkoY29ubmVjdGlvbklkOiBzdHJpbmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92Y3MvY29tbWl0P2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiBkYXRhLmNvbW1pdHMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY29tbWl0IGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBicmFuY2hlcyBmb3IgYSBjb25uZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJhbmNoZXMoY29ubmVjdGlvbklkOiBzdHJpbmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92Y3MvYnJhbmNoZXM/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgYnJhbmNoZXM6IGRhdGEuYnJhbmNoZXMgfHwgW10sIGN1cnJlbnRCcmFuY2g6IGRhdGEuY3VycmVudEJyYW5jaCB8fCAnbWFpbicgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBicmFuY2hlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIHsgYnJhbmNoZXM6IFtdLCBjdXJyZW50QnJhbmNoOiAnbWFpbicgfTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBicmFuY2hcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVCcmFuY2goY29ubmVjdGlvbklkOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9icmFuY2hlcycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbm5lY3Rpb25JZCwgbmFtZSwgYWN0aW9uOiAnY3JlYXRlJyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYnJhbmNoOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiAgXHJcbiAqIENoZWNrb3V0IGEgYnJhbmNoXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tvdXRCcmFuY2goY29ubmVjdGlvbklkOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9icmFuY2hlcycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbm5lY3Rpb25JZCwgbmFtZSwgYWN0aW9uOiAnY2hlY2tvdXQnIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrb3V0IGJyYW5jaDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ0cmFja0NoYW5nZSIsImNvbm5lY3Rpb25JZCIsImNoYW5nZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwidHJhY2tTY2hlbWFDaGFuZ2UiLCJvcGVyYXRpb24iLCJ0YWJsZU5hbWUiLCJzcWwiLCJhdXRob3IiLCJ0eXBlIiwidG9VcHBlckNhc2UiLCJ0YXJnZXQiLCJkZXNjcmlwdGlvbiIsImNoYXJBdCIsInNsaWNlIiwibmFtZSIsInF1ZXJ5Iiwicm9sbGJhY2tTUUwiLCJnZW5lcmF0ZVJvbGxiYWNrU1FMIiwic3RhdHVzIiwicGFyc2VRdWVyeUZvckNoYW5nZXMiLCJhZmZlY3RlZFJvd3MiLCJjbGVhblF1ZXJ5IiwicmVwbGFjZSIsInRyaW0iLCJub3JtYWxpemVkUXVlcnkiLCJpbmNsdWRlcyIsIm1hdGNoIiwicHJvY01hdGNoIiwidG9Mb3dlckNhc2UiLCJkcm9wUHJvY01hdGNoIiwic3RhcnRzV2l0aCIsIm1ldGFkYXRhIiwicSIsInVwcGVyIiwib3JpZ2luYWxDcmVhdGVTUUwiLCJjb2x1bW5EZWZpbml0aW9uIiwicHJpbWFyeUtleSIsInRhYmxlIiwicGsiLCJjb25kaXRpb25zIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImNvbCIsInZhbCIsImpvaW4iLCJyb3dzIiwicm93IiwiY29scyIsImtleXMiLCJ2YWxzIiwidmFsdWVzIiwidiIsIm9sZFJvd3MiLCJwcmltYXJ5S2V5RmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZiIsInNldCIsIndoZXJlIiwiZ2V0UGVuZGluZ0NoYW5nZXMiLCJyZXNwb25zZSIsImRhdGEiLCJqc29uIiwiY2hhbmdlcyIsImNvbW1pdENoYW5nZXMiLCJtZXNzYWdlIiwicGVuZGluZyIsInNuYXBzaG90Iiwic2NoZW1hIiwidGFibGVzIiwidGltZXN0YW1wIiwiRGF0ZSIsInJlc3VsdCIsInN1Y2Nlc3MiLCJnZXRDb21taXRIaXN0b3J5IiwiY29tbWl0cyIsImdldEJyYW5jaGVzIiwiYnJhbmNoZXMiLCJjdXJyZW50QnJhbmNoIiwiY3JlYXRlQnJhbmNoIiwiYWN0aW9uIiwiY2hlY2tvdXRCcmFuY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/vcs-helper.ts\n"));

/***/ })

});