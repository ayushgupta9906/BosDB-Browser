"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/query/page",{

/***/ "(app-pages-browser)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: function() { return /* binding */ checkoutBranch; },\n/* harmony export */   commitChanges: function() { return /* binding */ commitChanges; },\n/* harmony export */   createBranch: function() { return /* binding */ createBranch; },\n/* harmony export */   generateRollbackSQL: function() { return /* binding */ generateRollbackSQL; },\n/* harmony export */   getBranches: function() { return /* binding */ getBranches; },\n/* harmony export */   getCommitHistory: function() { return /* binding */ getCommitHistory; },\n/* harmony export */   getPendingChanges: function() { return /* binding */ getPendingChanges; },\n/* harmony export */   parseQueryForChanges: function() { return /* binding */ parseQueryForChanges; },\n/* harmony export */   trackChange: function() { return /* binding */ trackChange; },\n/* harmony export */   trackSchemaChange: function() { return /* binding */ trackSchemaChange; }\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: \"\".concat(operation.charAt(0).toUpperCase() + operation.slice(1), \" table \").concat(tableName, \" by \").concat(author.name),\n        query: sql,\n        rollbackSQL: generateRollbackSQL(sql),\n        status: \"APPLIED\"\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Database / Schema changes\n    if (normalizedQuery.match(/\\bCREATE\\s+(DATABASE|SCHEMA)\\b/i)) {\n        var _normalizedQuery_match;\n        const type = normalizedQuery.includes(\"DATABASE\") ? \"DATABASE\" : \"SCHEMA\";\n        const name = ((_normalizedQuery_match = normalizedQuery.match(/\\bCREATE\\s+(?:DATABASE|SCHEMA)\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match === void 0 ? void 0 : _normalizedQuery_match[2]) || \"unknown\";\n        return {\n            type: \"SYSTEM\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bDROP\\s+(DATABASE|SCHEMA)\\b/i)) {\n        var _normalizedQuery_match1;\n        const type = normalizedQuery.includes(\"DATABASE\") ? \"DATABASE\" : \"SCHEMA\";\n        const name = ((_normalizedQuery_match1 = normalizedQuery.match(/\\bDROP\\s+(?:DATABASE|SCHEMA)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match1 === void 0 ? void 0 : _normalizedQuery_match1[2]) || \"unknown\";\n        return {\n            type: \"SYSTEM\",\n            operation: \"DROP\",\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Indices / Triggers / Sequences\n    if (normalizedQuery.match(/\\bCREATE\\s+(?:UNIQUE\\s+)?INDEX\\b/i)) {\n        var _normalizedQuery_match2;\n        const name = ((_normalizedQuery_match2 = normalizedQuery.match(/\\bCREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match2 === void 0 ? void 0 : _normalizedQuery_match2[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create index \".concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bCREATE\\s+TRIGGER\\b/i)) {\n        var _normalizedQuery_match3;\n        const name = ((_normalizedQuery_match3 = normalizedQuery.match(/\\bCREATE\\s+TRIGGER\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match3 === void 0 ? void 0 : _normalizedQuery_match3[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create trigger \".concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bCREATE\\s+SEQUENCE\\b/i)) {\n        var _normalizedQuery_match4;\n        const name = ((_normalizedQuery_match4 = normalizedQuery.match(/\\bCREATE\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match4 === void 0 ? void 0 : _normalizedQuery_match4[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create sequence \".concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const match = cleanQuery.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: tableName,\n            tableName,\n            description: \"Create table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const match = cleanQuery.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: tableName,\n            tableName,\n            description: \"Alter table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const match = cleanQuery.match(/DROP\\s+TABLE\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: tableName,\n            tableName,\n            description: \"Drop table \".concat(tableName),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Procedure/Function/View/Trigger/Index Drop\n    const dropObjMatch = normalizedQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|SEQUENCE|ROLE)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\2/i);\n    if (dropObjMatch) {\n        const type = dropObjMatch[1].toUpperCase();\n        const name = dropObjMatch[3];\n        return {\n            type: type === \"ROLE\" ? \"ACL\" : \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: \"Drop \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bREFRESH\\s+MATERIALIZED\\s+VIEW\\b/i)) {\n        var _normalizedQuery_match5;\n        const name = ((_normalizedQuery_match5 = normalizedQuery.match(/\\bREFRESH\\s+MATERIALIZED\\s+VIEW\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match5 === void 0 ? void 0 : _normalizedQuery_match5[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: name,\n            description: \"Refresh materialized view \".concat(name),\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Materialized view drop handle\n    if (normalizedQuery.match(/\\bDROP\\s+MATERIALIZED\\s+VIEW\\b/i)) {\n        var _normalizedQuery_match6;\n        const name = ((_normalizedQuery_match6 = normalizedQuery.match(/\\bDROP\\s+MATERIALIZED\\s+VIEW\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match6 === void 0 ? void 0 : _normalizedQuery_match6[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: \"Drop materialized view \".concat(name),\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Views/Procedures/Functions\n    const procMatch = cleanQuery.match(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|MATERIALIZED\\s+VIEW|ROUTINE)\\s+([`\"]?)(\\w+)\\2/i);\n    if (procMatch) {\n        const type = procMatch[1].toUpperCase();\n        const name = procMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: \"Create \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // ACL changes\n    if (normalizedQuery.startsWith(\"GRANT\") || normalizedQuery.startsWith(\"REVOKE\")) {\n        return {\n            type: \"ACL\",\n            operation: normalizedQuery.startsWith(\"GRANT\") ? \"GRANT\" : \"REVOKE\",\n            target: \"permissions\",\n            description: \"\".concat(normalizedQuery.startsWith(\"GRANT\") ? \"Grant\" : \"Revoke\", \" permissions\"),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Comments\n    if (normalizedQuery.startsWith(\"COMMENT ON\")) {\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: \"comment\",\n            description: \"Update comment\",\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Data changes (DML)\n    if (normalizedQuery.startsWith(\"INSERT INTO\") || normalizedQuery.startsWith(\"MERGE\")) {\n        const isMerge = normalizedQuery.startsWith(\"MERGE\");\n        const match = cleanQuery.match(/(?:INSERT\\s+INTO|MERGE\\s+INTO?)\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: isMerge ? \"ALTER\" : \"INSERT\",\n            target: tableName,\n            tableName,\n            description: \"\".concat(isMerge ? \"Merge\" : \"Insert\", \" \").concat(affectedRows || 1, \" row(s) into \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bALTER\\s+(SEQUENCE|INDEX)\\b/i)) {\n        var _normalizedQuery_match7;\n        const type = normalizedQuery.includes(\"SEQUENCE\") ? \"SEQUENCE\" : \"INDEX\";\n        const name = ((_normalizedQuery_match7 = normalizedQuery.match(/\\bALTER\\s+(?:SEQUENCE|INDEX)\\s+([`\"]?)(\\w+)\\1/i)) === null || _normalizedQuery_match7 === void 0 ? void 0 : _normalizedQuery_match7[2]) || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: name,\n            description: \"Alter \".concat(type.toLowerCase(), \" \").concat(name),\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"REINDEX\") || normalizedQuery.startsWith(\"VACUUM\") || normalizedQuery.startsWith(\"ANALYZE\")) {\n        const op = normalizedQuery.split(\" \")[0];\n        return {\n            type: \"SYSTEM\",\n            operation: \"ALTER\",\n            target: \"database\",\n            description: \"Run \".concat(op.toLowerCase()),\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const match = cleanQuery.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName,\n            description: \"Update \".concat(affectedRows || \"unknown\", \" row(s) in \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const match = cleanQuery.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName,\n            description: \"Delete \".concat(affectedRows || \"unknown\", \" row(s) from \").concat(tableName),\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    return null;\n}\n/**\r\n * Detect DDL/DML and generate rollback SQL using regex patterns\r\n * Covers the MASTER SQL OPERATION MATRIX\r\n */ function generateRollbackSQL(query, metadata) {\n    const q = query.trim().replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const upper = q.toUpperCase();\n    // Helper to get name from common regex groups\n    const getMatch = function(regex) {\n        let groupIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;\n        const match = q.match(regex);\n        return match ? match[groupIndex] : null;\n    };\n    // 1 & 2. DATABASE / SCHEMA LEVEL\n    if (upper.startsWith(\"CREATE DATABASE\")) return \"DROP DATABASE \".concat(getMatch(/CREATE\\s+DATABASE\\s+([`\"]?)(\\w+)\\1/i, 2), \";\");\n    if (upper.startsWith(\"DROP DATABASE\")) return \"MANUAL\";\n    if (upper.startsWith(\"CREATE SCHEMA\")) return \"DROP SCHEMA \".concat(getMatch(/CREATE\\s+SCHEMA\\s+([`\"]?)(\\w+)\\1/i, 2), \";\");\n    if (upper.startsWith(\"DROP SCHEMA\")) return \"MANUAL\";\n    if (upper.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        const m = q.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return m ? \"\".concat(m[1], \" \").concat(m[5], \" RENAME TO \").concat(m[3], \";\") : \"MANUAL\";\n    }\n    if (upper.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+OWNER\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        if (metadata === null || metadata === void 0 ? void 0 : metadata.oldOwner) {\n            const m = q.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+OWNER\\s+TO\\s+/i);\n            return m ? \"\".concat(m[1], \" \").concat(m[3], \" OWNER TO \").concat(metadata.oldOwner, \";\") : \"MANUAL\";\n        }\n        return \"MANUAL\";\n    }\n    // 3. TABLE OPERATIONS\n    if (upper.startsWith(\"CREATE TABLE\")) {\n        const name = getMatch(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        return name ? \"DROP TABLE IF EXISTS \".concat(name, \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP TABLE\")) return (metadata === null || metadata === void 0 ? void 0 : metadata.originalCreateSQL) || \"MANUAL\";\n    if (upper.startsWith(\"TRUNCATE\")) return \"MANUAL\";\n    if (upper.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        const m = q.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return m ? \"ALTER TABLE \".concat(m[5], \" RENAME TO \").concat(m[3], \";\") : \"MANUAL\";\n    }\n    if (upper.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+OWNER\\s+TO\\s+/i)) {\n        if (metadata === null || metadata === void 0 ? void 0 : metadata.oldOwner) {\n            const m = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n            return m ? \"ALTER TABLE \".concat(m[2], \" OWNER TO \").concat(metadata.oldOwner, \";\") : \"MANUAL\";\n        }\n        return \"MANUAL\";\n    }\n    // 4. COLUMN OPERATIONS\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"ADD\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:COLUMN\\s+)?([`\"]?)(\\w+)\\3/i);\n        return mt ? \"ALTER TABLE \".concat(mt[2], \" DROP COLUMN \").concat(mt[4], \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"DROP COLUMN\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+DROP\\s+COLUMN\\s+([`\"]?)(\\w+)\\3/i);\n        return mt && (metadata === null || metadata === void 0 ? void 0 : metadata.columnDefinition) ? \"ALTER TABLE \".concat(mt[2], \" ADD COLUMN \").concat(metadata.columnDefinition, \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME COLUMN\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+COLUMN\\s+([`\"]?)(\\w+)\\3\\s+TO\\s+([`\"]?)(\\w+)\\5/i);\n        return mt ? \"ALTER TABLE \".concat(mt[2], \" RENAME COLUMN \").concat(mt[6], \" TO \").concat(mt[4], \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER COLUMN\") || upper.includes(\"MODIFY\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+(?:ALTER\\s+COLUMN|MODIFY)\\s+([`\"]?)(\\w+)\\3/i);\n        if (mt) {\n            if (upper.includes(\"SET DEFAULT\")) return (metadata === null || metadata === void 0 ? void 0 : metadata.oldDefault) !== undefined ? \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" SET DEFAULT \").concat(metadata.oldDefault, \";\") : \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" DROP DEFAULT;\");\n            if (upper.includes(\"DROP DEFAULT\")) return (metadata === null || metadata === void 0 ? void 0 : metadata.oldDefault) !== undefined ? \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" SET DEFAULT \").concat(metadata.oldDefault, \";\") : \"MANUAL\";\n            if (upper.includes(\"SET NOT NULL\")) return \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" DROP NOT NULL;\");\n            if (upper.includes(\"DROP NOT NULL\")) return \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" SET NOT NULL;\");\n            if (metadata === null || metadata === void 0 ? void 0 : metadata.oldColumnState) return \"ALTER TABLE \".concat(mt[2], \" ALTER COLUMN \").concat(mt[4], \" \").concat(metadata.oldColumnState, \";\");\n        }\n        return \"MANUAL\";\n    }\n    // 5. CONSTRAINTS\n    if (upper.includes(\"ADD PRIMARY KEY\") || upper.includes(\"ADD CONSTRAINT\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:CONSTRAINT\\s+([`\"]?)(\\w+)\\3\\s+)?(?:PRIMARY\\s+KEY|FOREIGN\\s+KEY|UNIQUE|CHECK)/i);\n        const name = mt ? mt[4] || \"pk\" : null; // Need to know constraint name to drop it\n        return mt && name ? \"ALTER TABLE \".concat(mt[2], \" DROP CONSTRAINT \").concat(name, \";\") : \"MANUAL\";\n    }\n    // 6. INDEXES\n    if (upper.startsWith(\"CREATE\") && upper.includes(\"INDEX\")) {\n        const name = getMatch(/CREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i);\n        return name ? \"DROP INDEX \".concat(name, \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP INDEX\")) return (metadata === null || metadata === void 0 ? void 0 : metadata.originalIndexSQL) || \"MANUAL\";\n    if (upper.includes(\"ALTER INDEX\") && upper.includes(\"RENAME TO\")) {\n        const m = q.match(/ALTER\\s+INDEX\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\3/i);\n        return m ? \"ALTER INDEX \".concat(m[3], \" RENAME TO \").concat(m[1], \";\") : \"MANUAL\";\n    }\n    // 7 & 8. VIEWS\n    if (upper.startsWith(\"CREATE\") && (upper.includes(\"VIEW\") || upper.includes(\"MATERIALIZED VIEW\"))) {\n        const isMat = upper.includes(\"MATERIALIZED\");\n        const name = getMatch(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(?:MATERIALIZED\\s+)?VIEW\\s+([`\"]?)(\\w+)\\1/i);\n        if (upper.includes(\"REPLACE\") && (metadata === null || metadata === void 0 ? void 0 : metadata.oldViewDefinition)) return metadata.oldViewDefinition;\n        return name ? \"DROP \".concat(isMat ? \"MATERIALIZED \" : \"\", \"VIEW \").concat(name, \";\") : \"MANUAL\";\n    }\n    if (upper.startsWith(\"REFRESH MATERIALIZED VIEW\")) return \"MANUAL\";\n    // 9. FUNCTIONS / PROCEDURES\n    if (upper.startsWith(\"CREATE\") && (upper.includes(\"FUNCTION\") || upper.includes(\"PROCEDURE\"))) {\n        const type = upper.includes(\"FUNCTION\") ? \"FUNCTION\" : \"PROCEDURE\";\n        if (upper.includes(\"REPLACE\") && (metadata === null || metadata === void 0 ? void 0 : metadata.oldBody)) return metadata.oldBody;\n        const name = getMatch(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(FUNCTION|PROCEDURE)\\s+([`\"]?)(\\w+)\\2/i, 3);\n        return name ? \"DROP \".concat(type, \" \").concat(name, \";\") : \"MANUAL\";\n    }\n    // 10. TRIGGERS\n    if (upper.startsWith(\"CREATE TRIGGER\")) {\n        const m = q.match(/CREATE\\s+TRIGGER\\s+([`\"]?)(\\w+)\\1\\s+ON\\s+([`\"]?)(\\w+)\\3/i);\n        return m ? \"DROP TRIGGER \".concat(m[2], \" ON \").concat(m[4], \";\") : \"MANUAL\";\n    }\n    if (upper.includes(\"ENABLE TRIGGER\") || upper.includes(\"DISABLE TRIGGER\")) {\n        const isEnable = upper.includes(\"ENABLE\");\n        const m = q.match(/(ENABLE|DISABLE)\\s+TRIGGER\\s+([`\"]?)(\\w+)\\3\\s+ON\\s+([`\"]?)(\\w+)\\5/i);\n        return m ? \"ALTER TABLE \".concat(m[5], \" \").concat(isEnable ? \"DISABLE\" : \"ENABLE\", \" TRIGGER \").concat(m[3], \";\") : \"MANUAL\";\n    }\n    // 11. SEQUENCES\n    if (upper.startsWith(\"CREATE SEQUENCE\")) return \"DROP SEQUENCE \".concat(getMatch(/CREATE\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i, 2), \";\");\n    if (upper.startsWith(\"DROP SEQUENCE\")) return (metadata === null || metadata === void 0 ? void 0 : metadata.originalSeqSQL) || \"MANUAL\";\n    if (upper.startsWith(\"ALTER SEQUENCE\")) {\n        const name = getMatch(/ALTER\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i, 2);\n        if (upper.includes(\"RESTART\")) return \"MANUAL\"; // value lost unless we have it\n        return (metadata === null || metadata === void 0 ? void 0 : metadata.oldSeqState) ? \"ALTER SEQUENCE \".concat(name, \" \").concat(metadata.oldSeqState, \";\") : \"MANUAL\";\n    }\n    // 12. DATA (DML)\n    if (upper.startsWith(\"MERGE\")) return \"MANUAL\"; // Complex inverse\n    if (upper.startsWith(\"INSERT INTO\")) {\n        const match = q.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.primaryKey)) {\n            const pk = metadata.primaryKey;\n            const conds = Object.entries(pk).map((param)=>{\n                let [c, v] = param;\n                return \"\".concat(c, \" = \").concat(typeof v === \"string\" ? \"'\".concat(v, \"'\") : v);\n            }).join(\" AND \");\n            return \"DELETE FROM \".concat(match[2], \" WHERE \").concat(conds, \";\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"DELETE FROM\")) {\n        const match = q.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.rows)) {\n            return metadata.rows.map((row)=>{\n                const cols = Object.keys(row).join(\", \");\n                const vals = Object.values(row).map((v)=>typeof v === \"string\" ? \"'\".concat(v, \"'\") : v).join(\", \");\n                return \"INSERT INTO \".concat(match[2], \" (\").concat(cols, \") VALUES (\").concat(vals, \");\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"UPDATE\")) {\n        const match = q.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && (metadata === null || metadata === void 0 ? void 0 : metadata.oldRows)) {\n            return metadata.oldRows.map((row)=>{\n                const pk = metadata.primaryKeyFields.reduce((acc, f)=>({\n                        ...acc,\n                        [f]: row[f]\n                    }), {});\n                const set = Object.entries(row).map((param)=>{\n                    let [c, v] = param;\n                    return \"\".concat(c, \" = \").concat(typeof v === \"string\" ? \"'\".concat(v, \"'\") : v);\n                }).join(\", \");\n                const where = Object.entries(pk).map((param)=>{\n                    let [c, v] = param;\n                    return \"\".concat(c, \" = \").concat(typeof v === \"string\" ? \"'\".concat(v, \"'\") : v);\n                }).join(\" AND \");\n                return \"UPDATE \".concat(match[2], \" SET \").concat(set, \" WHERE \").concat(where, \";\");\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    // 14. PERMISSIONS / ACL\n    if (upper.startsWith(\"GRANT\")) return q.replace(/GRANT/i, \"REVOKE\").replace(/TO/i, \"FROM\");\n    if (upper.startsWith(\"REVOKE\")) return q.replace(/REVOKE/i, \"GRANT\").replace(/FROM/i, \"TO\");\n    if (upper.startsWith(\"CREATE ROLE\")) return \"DROP ROLE \".concat(getMatch(/CREATE\\s+ROLE\\s+([`\"]?)(\\w+)\\1/i, 2), \";\");\n    // 20. COMMENTS\n    if (upper.startsWith(\"COMMENT ON\")) {\n        const m = q.match(/COMMENT\\s+ON\\s+(TABLE|COLUMN)\\s+([\\s\\S]+?)\\s+IS/i);\n        if (m && (metadata === null || metadata === void 0 ? void 0 : metadata.oldComment) !== undefined) return \"COMMENT ON \".concat(m[1], \" \").concat(m[2], \" IS \").concat(metadata.oldComment === null ? \"NULL\" : \"'\".concat(metadata.oldComment, \"'\"), \";\");\n        return \"MANUAL\";\n    }\n    return \"MANUAL\";\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/pending?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/commit?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(\"/api/vcs/branches?connectionId=\".concat(connectionId));\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdmNzLWhlbHBlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBaUJEOztDQUVDLEdBQ00sZUFBZUEsWUFBWUMsWUFBb0IsRUFBRUMsTUFBc0I7SUFDMUUsSUFBSTtRQUNBLE1BQU1DLE1BQU0sb0JBQW9CO1lBQzVCQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFjQztZQUFPO1FBQ2hEO0lBQ0osRUFBRSxPQUFPTyxPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO0lBQzdDO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFLGtCQUNsQlYsWUFBb0IsRUFDcEJXLFNBQXNDLEVBQ3RDQyxTQUFpQixFQUNqQkMsR0FBVyxFQUNYQyxNQUFvQztJQUVwQyxNQUFNYixTQUF5QjtRQUMzQmMsTUFBTTtRQUNOSixXQUFXQSxVQUFVSyxXQUFXO1FBQ2hDQyxRQUFRTDtRQUNSQTtRQUNBTSxhQUFhLEdBQW1FTixPQUFoRUQsVUFBVVEsTUFBTSxDQUFDLEdBQUdILFdBQVcsS0FBS0wsVUFBVVMsS0FBSyxDQUFDLElBQUcsV0FBeUJOLE9BQWhCRixXQUFVLFFBQWtCLE9BQVpFLE9BQU9PLElBQUk7UUFDM0dDLE9BQU9UO1FBQ1BVLGFBQWFDLG9CQUFvQlg7UUFDakNZLFFBQVE7SUFDWjtJQUVBLE1BQU0xQixZQUFZQyxjQUFjQztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU3lCLHFCQUFxQkosS0FBYSxFQUFFSyxZQUFxQjtJQUNyRSwyQkFBMkI7SUFDM0IsTUFBTUMsYUFBYU4sTUFBTU8sT0FBTyxDQUFDLDZCQUE2QixJQUFJQyxJQUFJO0lBQ3RFLE1BQU1DLGtCQUFrQkgsV0FBV1osV0FBVztJQUU5Qyw0QkFBNEI7SUFDNUIsSUFBSWUsZ0JBQWdCQyxLQUFLLENBQUMsb0NBQW9DO1lBRTdD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QUFNUixTQUFTLE1BQU1aLFNBQVNFLElBQUk7UUFDbEMsT0FBT1UsT0FBT0MsT0FBTztJQUN6QixFQUFFLE9BQU8zRixPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvdmNzLWhlbHBlci50cz9iYzc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBWQ1MgSW50ZWdyYXRpb24gSGVscGVyXHJcbiAqIEF1dG9tYXRpY2FsbHkgdHJhY2tzIGRhdGFiYXNlIGNoYW5nZXMgZm9yIHZlcnNpb24gY29udHJvbFxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YWJhc2VDaGFuZ2Uge1xyXG4gICAgaWQ/OiBzdHJpbmc7XHJcbiAgICB0eXBlOiAnU0NIRU1BJyB8ICdEQVRBJyB8ICdBQ0wnIHwgJ1NZU1RFTSc7XHJcbiAgICBvcGVyYXRpb246ICdDUkVBVEUnIHwgJ0FMVEVSJyB8ICdEUk9QJyB8ICdJTlNFUlQnIHwgJ1VQREFURScgfCAnREVMRVRFJyB8ICdSRU5BTUUnIHwgJ1RSVU5DQVRFJyB8ICdHUkFOVCcgfCAnUkVWT0tFJztcclxuICAgIHRhcmdldDogc3RyaW5nO1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICByb2xsYmFja1NRTDogc3RyaW5nIHwgJ01BTlVBTCc7XHJcbiAgICBzdGF0dXM6ICdBUFBMSUVEJyB8ICdSRVZFUlRFRCc7XHJcbiAgICB0YWJsZU5hbWU/OiBzdHJpbmc7XHJcbiAgICBhZmZlY3RlZFJvd3M/OiBudW1iZXI7XHJcbiAgICBtZXRhZGF0YT86IGFueTtcclxuICAgIHRpbWVzdGFtcD86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgZGF0YWJhc2UgY2hhbmdlIGZvciB2ZXJzaW9uIGNvbnRyb2xcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQ6IHN0cmluZywgY2hhbmdlOiBEYXRhYmFzZUNoYW5nZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvcGVuZGluZycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbm5lY3Rpb25JZCwgY2hhbmdlIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB0cmFjayBjaGFuZ2U6JywgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgYSBzY2hlbWEgY2hhbmdlIChDUkVBVEUsIEFMVEVSLCBEUk9QIHRhYmxlKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrU2NoZW1hQ2hhbmdlKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBvcGVyYXRpb246ICdjcmVhdGUnIHwgJ2FsdGVyJyB8ICdkcm9wJyxcclxuICAgIHRhYmxlTmFtZTogc3RyaW5nLFxyXG4gICAgc3FsOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1cclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBjaGFuZ2U6IERhdGFiYXNlQ2hhbmdlID0ge1xyXG4gICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLnRvVXBwZXJDYXNlKCkgYXMgJ0NSRUFURScgfCAnQUxURVInIHwgJ0RST1AnLFxyXG4gICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgIHRhYmxlTmFtZSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3BlcmF0aW9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3BlcmF0aW9uLnNsaWNlKDEpfSB0YWJsZSAke3RhYmxlTmFtZX0gYnkgJHthdXRob3IubmFtZX1gLFxyXG4gICAgICAgIHF1ZXJ5OiBzcWwsXHJcbiAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwoc3FsKSxcclxuICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQsIGNoYW5nZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBTUUwgcXVlcnkgdG8gZGV0ZWN0IGNoYW5nZSB0eXBlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeUZvckNoYW5nZXMocXVlcnk6IHN0cmluZywgYWZmZWN0ZWRSb3dzPzogbnVtYmVyKTogRGF0YWJhc2VDaGFuZ2UgfCBudWxsIHtcclxuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgdHJpbVxyXG4gICAgY29uc3QgY2xlYW5RdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRRdWVyeSA9IGNsZWFuUXVlcnkudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAvLyBEYXRhYmFzZSAvIFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJDUkVBVEVcXHMrKERBVEFCQVNFfFNDSEVNQSlcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gbm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEQVRBQkFTRScpID8gJ0RBVEFCQVNFJyA6ICdTQ0hFTUEnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkNSRUFURVxccysoPzpEQVRBQkFTRXxTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTWVNURU0nLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrKERBVEFCQVNFfFNDSEVNQSlcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gbm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEQVRBQkFTRScpID8gJ0RBVEFCQVNFJyA6ICdTQ0hFTUEnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrKD86REFUQUJBU0V8U0NIRU1BKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU1lTVEVNJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiAnTUFOVUFMJyxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluZGljZXMgLyBUcmlnZ2VycyAvIFNlcXVlbmNlc1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzKyg/OlVOSVFVRVxccyspP0lOREVYXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzKyg/OlVOSVFVRVxccyspP0lOREVYXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIGluZGV4ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1RSSUdHRVJcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJDUkVBVEVcXHMrVFJJR0dFUlxccysoW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSB0cmlnZ2VyICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1NFUVVFTkNFXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1NFUVVFTkNFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIHNlcXVlbmNlICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGFibGUgU2NoZW1hIGNoYW5nZXNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0NSRUFURSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9DUkVBVEVcXHMrVEFCTEVcXHMrKD86SUZcXHMrTk9UXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0NSRUFURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdBTFRFUicsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQWx0ZXIgdGFibGUgJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0RST1AgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvRFJPUFxccytUQUJMRVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZWR1cmUvRnVuY3Rpb24vVmlldy9UcmlnZ2VyL0luZGV4IERyb3BcclxuICAgIGNvbnN0IGRyb3BPYmpNYXRjaCA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvRFJPUFxccysoUFJPQ0VEVVJFfEZVTkNUSU9OfFZJRVd8VFJJR0dFUnxJTkRFWHxTRVFVRU5DRXxST0xFKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChkcm9wT2JqTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gZHJvcE9iak1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGRyb3BPYmpNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlID09PSAnUk9MRScgPyAnQUNMJyA6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgJHt0eXBlLnRvTG93ZXJDYXNlKCl9ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiUkVGUkVTSFxccytNQVRFUklBTElaRURcXHMrVklFV1xcYi9pKSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYlJFRlJFU0hcXHMrTUFURVJJQUxJWkVEXFxzK1ZJRVdcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk/LlsyXSB8fCAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0FMVEVSJyBhcyBhbnksXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZWZyZXNoIG1hdGVyaWFsaXplZCB2aWV3ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0ZXJpYWxpemVkIHZpZXcgZHJvcCBoYW5kbGVcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrTUFURVJJQUxJWkVEXFxzK1ZJRVdcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJEUk9QXFxzK01BVEVSSUFMSVpFRFxccytWSUVXXFxzKyg/OklGXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgbWF0ZXJpYWxpemVkIHZpZXcgJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFZpZXdzL1Byb2NlZHVyZXMvRnVuY3Rpb25zXHJcbiAgICBjb25zdCBwcm9jTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9DUkVBVEVcXHMrKD86T1JcXHMrUkVQTEFDRVxccyspPyhQUk9DRURVUkV8RlVOQ1RJT058VklFV3xNQVRFUklBTElaRURcXHMrVklFV3xST1VUSU5FKVxccysoW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChwcm9jTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gcHJvY01hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb2NNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSAke3R5cGUudG9Mb3dlckNhc2UoKX0gJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ0wgY2hhbmdlc1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdHUkFOVCcpIHx8IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdSRVZPS0UnKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdBQ0wnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdHUkFOVCcpID8gJ0dSQU5UJyA6ICdSRVZPS0UnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICdwZXJtaXNzaW9ucycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnR1JBTlQnKSA/ICdHcmFudCcgOiAnUmV2b2tlJ30gcGVybWlzc2lvbnNgLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tbWVudHNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnQ09NTUVOVCBPTicpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0FMVEVSJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnY29tbWVudCcsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVXBkYXRlIGNvbW1lbnRgLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGF0YSBjaGFuZ2VzIChETUwpXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ01FUkdFJykpIHtcclxuICAgICAgICBjb25zdCBpc01lcmdlID0gbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ01FUkdFJyk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC8oPzpJTlNFUlRcXHMrSU5UT3xNRVJHRVxccytJTlRPPylcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogaXNNZXJnZSA/ICdBTFRFUicgYXMgYW55IDogJ0lOU0VSVCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtpc01lcmdlID8gJ01lcmdlJyA6ICdJbnNlcnQnfSAke2FmZmVjdGVkUm93cyB8fCAxfSByb3cocykgaW50byAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJBTFRFUlxccysoU0VRVUVOQ0V8SU5ERVgpXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnU0VRVUVOQ0UnKSA/ICdTRVFVRU5DRScgOiAnSU5ERVgnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkFMVEVSXFxzKyg/OlNFUVVFTkNFfElOREVYKVxccysoW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQUxURVInLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQWx0ZXIgJHt0eXBlLnRvTG93ZXJDYXNlKCl9ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdSRUlOREVYJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1ZBQ1VVTScpIHx8IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdBTkFMWVpFJykpIHtcclxuICAgICAgICBjb25zdCBvcCA9IG5vcm1hbGl6ZWRRdWVyeS5zcGxpdCgnICcpWzBdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTWVNURU0nLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdBTFRFUicgYXMgYW55LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICdkYXRhYmFzZScsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUnVuICR7b3AudG9Mb3dlckNhc2UoKX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdVUERBVEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvVVBEQVRFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdVUERBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVwZGF0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBpbiAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdERUxFVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERlbGV0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBmcm9tICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3MsXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiAnTUFOVUFMJyxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IERETC9ETUwgYW5kIGdlbmVyYXRlIHJvbGxiYWNrIFNRTCB1c2luZyByZWdleCBwYXR0ZXJuc1xyXG4gKiBDb3ZlcnMgdGhlIE1BU1RFUiBTUUwgT1BFUkFUSU9OIE1BVFJJWFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnk6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpOiBzdHJpbmcgfCAnTUFOVUFMJyB7XHJcbiAgICBjb25zdCBxID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IHVwcGVyID0gcS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIC8vIEhlbHBlciB0byBnZXQgbmFtZSBmcm9tIGNvbW1vbiByZWdleCBncm91cHNcclxuICAgIGNvbnN0IGdldE1hdGNoID0gKHJlZ2V4OiBSZWdFeHAsIGdyb3VwSW5kZXg6IG51bWJlciA9IDIpID0+IHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2gocmVnZXgpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoW2dyb3VwSW5kZXhdIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gMSAmIDIuIERBVEFCQVNFIC8gU0NIRU1BIExFVkVMXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIERBVEFCQVNFJykpIHJldHVybiBgRFJPUCBEQVRBQkFTRSAke2dldE1hdGNoKC9DUkVBVEVcXHMrREFUQUJBU0VcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMil9O2A7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnRFJPUCBEQVRBQkFTRScpKSByZXR1cm4gJ01BTlVBTCc7XHJcblxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBTQ0hFTUEnKSkgcmV0dXJuIGBEUk9QIFNDSEVNQSAke2dldE1hdGNoKC9DUkVBVEVcXHMrU0NIRU1BXFxzKyhbYFwiXT8pKFxcdyspXFwxL2ksIDIpfTtgO1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgU0NIRU1BJykpIHJldHVybiAnTUFOVUFMJztcclxuXHJcbiAgICBpZiAodXBwZXIubWF0Y2goLyhBTFRFUlxccytEQVRBQkFTRXxBTFRFUlxccytTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwyXFxzK1JFTkFNRVxccytUT1xccysoW2BcIl0/KShcXHcrKVxcNC9pKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC8oQUxURVJcXHMrREFUQUJBU0V8QUxURVJcXHMrU0NIRU1BKVxccysoW2BcIl0/KShcXHcrKVxcMlxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDQvaSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBgJHttWzFdfSAke21bNV19IFJFTkFNRSBUTyAke21bM119O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIubWF0Y2goLyhBTFRFUlxccytEQVRBQkFTRXxBTFRFUlxccytTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwyXFxzK09XTkVSXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw0L2kpKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhPy5vbGRPd25lcikge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKEFMVEVSXFxzK0RBVEFCQVNFfEFMVEVSXFxzK1NDSEVNQSlcXHMrKFtgXCJdPykoXFx3KylcXDJcXHMrT1dORVJcXHMrVE9cXHMrL2kpO1xyXG4gICAgICAgICAgICByZXR1cm4gbSA/IGAke21bMV19ICR7bVszXX0gT1dORVIgVE8gJHttZXRhZGF0YS5vbGRPd25lcn07YCA6ICdNQU5VQUwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4gVEFCTEUgT1BFUkFUSU9OU1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldE1hdGNoKC9DUkVBVEVcXHMrVEFCTEVcXHMrKD86SUZcXHMrTk9UXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIHJldHVybiBuYW1lID8gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7bmFtZX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgVEFCTEUnKSkgcmV0dXJuIG1ldGFkYXRhPy5vcmlnaW5hbENyZWF0ZVNRTCB8fCAnTUFOVUFMJztcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdUUlVOQ0FURScpKSByZXR1cm4gJ01BTlVBTCc7XHJcblxyXG4gICAgaWYgKHVwcGVyLm1hdGNoKC8oUkVOQU1FXFxzK1RBQkxFfEFMVEVSXFxzK1RBQkxFKVxccysoW2BcIl0/KShcXHcrKVxcMlxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDQvaSkpIHtcclxuICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKFJFTkFNRVxccytUQUJMRXxBTFRFUlxccytUQUJMRSlcXHMrKFtgXCJdPykoXFx3KylcXDJcXHMrUkVOQU1FXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw0L2kpO1xyXG4gICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVs1XX0gUkVOQU1FIFRPICR7bVszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDFcXHMrT1dORVJcXHMrVE9cXHMrL2kpKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhPy5vbGRPd25lcikge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVsyXX0gT1dORVIgVE8gJHttZXRhZGF0YS5vbGRPd25lcn07YCA6ICdNQU5VQUwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNC4gQ09MVU1OIE9QRVJBVElPTlNcclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnQUREJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK0FERFxccysoPzpDT0xVTU5cXHMrKT8oW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gbXQgPyBgQUxURVIgVEFCTEUgJHttdFsyXX0gRFJPUCBDT0xVTU4gJHttdFs0XX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdEUk9QIENPTFVNTicpKSB7XHJcbiAgICAgICAgY29uc3QgbXQgPSBxLm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMVxccytEUk9QXFxzK0NPTFVNTlxccysoW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gKG10ICYmIG1ldGFkYXRhPy5jb2x1bW5EZWZpbml0aW9uKSA/IGBBTFRFUiBUQUJMRSAke210WzJdfSBBREQgQ09MVU1OICR7bWV0YWRhdGEuY29sdW1uRGVmaW5pdGlvbn07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdSRU5BTUUgQ09MVU1OJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK1JFTkFNRVxccytDT0xVTU5cXHMrKFtgXCJdPykoXFx3KylcXDNcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDUvaSk7XHJcbiAgICAgICAgcmV0dXJuIG10ID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IFJFTkFNRSBDT0xVTU4gJHttdFs2XX0gVE8gJHttdFs0XX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBDT0xVTU4nKSB8fCB1cHBlci5pbmNsdWRlcygnTU9ESUZZJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzKyg/OkFMVEVSXFxzK0NPTFVNTnxNT0RJRlkpXFxzKyhbYFwiXT8pKFxcdyspXFwzL2kpO1xyXG4gICAgICAgIGlmIChtdCkge1xyXG4gICAgICAgICAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ1NFVCBERUZBVUxUJykpIHJldHVybiBtZXRhZGF0YT8ub2xkRGVmYXVsdCAhPT0gdW5kZWZpbmVkID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IEFMVEVSIENPTFVNTiAke210WzRdfSBTRVQgREVGQVVMVCAke21ldGFkYXRhLm9sZERlZmF1bHR9O2AgOiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IERST1AgREVGQVVMVDtgO1xyXG4gICAgICAgICAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ0RST1AgREVGQVVMVCcpKSByZXR1cm4gbWV0YWRhdGE/Lm9sZERlZmF1bHQgIT09IHVuZGVmaW5lZCA/IGBBTFRFUiBUQUJMRSAke210WzJdfSBBTFRFUiBDT0xVTU4gJHttdFs0XX0gU0VUIERFRkFVTFQgJHttZXRhZGF0YS5vbGREZWZhdWx0fTtgIDogJ01BTlVBTCc7XHJcbiAgICAgICAgICAgIGlmICh1cHBlci5pbmNsdWRlcygnU0VUIE5PVCBOVUxMJykpIHJldHVybiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IERST1AgTk9UIE5VTEw7YDtcclxuICAgICAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdEUk9QIE5PVCBOVUxMJykpIHJldHVybiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IFNFVCBOT1QgTlVMTDtgO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/Lm9sZENvbHVtblN0YXRlKSByZXR1cm4gYEFMVEVSIFRBQkxFICR7bXRbMl19IEFMVEVSIENPTFVNTiAke210WzRdfSAke21ldGFkYXRhLm9sZENvbHVtblN0YXRlfTtgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4gQ09OU1RSQUlOVFNcclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUREIFBSSU1BUlkgS0VZJykgfHwgdXBwZXIuaW5jbHVkZXMoJ0FERCBDT05TVFJBSU5UJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK0FERFxccysoPzpDT05TVFJBSU5UXFxzKyhbYFwiXT8pKFxcdyspXFwzXFxzKyk/KD86UFJJTUFSWVxccytLRVl8Rk9SRUlHTlxccytLRVl8VU5JUVVFfENIRUNLKS9pKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gbXQgPyAobXRbNF0gfHwgJ3BrJykgOiBudWxsOyAvLyBOZWVkIHRvIGtub3cgY29uc3RyYWludCBuYW1lIHRvIGRyb3AgaXRcclxuICAgICAgICByZXR1cm4gKG10ICYmIG5hbWUpID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IERST1AgQ09OU1RSQUlOVCAke25hbWV9O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyA2LiBJTkRFWEVTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgdXBwZXIuaW5jbHVkZXMoJ0lOREVYJykpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0TWF0Y2goL0NSRUFURVxccysoPzpVTklRVUVcXHMrKT9JTkRFWFxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICByZXR1cm4gbmFtZSA/IGBEUk9QIElOREVYICR7bmFtZX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgSU5ERVgnKSkgcmV0dXJuIG1ldGFkYXRhPy5vcmlnaW5hbEluZGV4U1FMIHx8ICdNQU5VQUwnO1xyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBJTkRFWCcpICYmIHVwcGVyLmluY2x1ZGVzKCdSRU5BTUUgVE8nKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC9BTFRFUlxccytJTkRFWFxccysoW2BcIl0/KShcXHcrKVxcMVxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDMvaSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBgQUxURVIgSU5ERVggJHttWzNdfSBSRU5BTUUgVE8gJHttWzFdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNyAmIDguIFZJRVdTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgKHVwcGVyLmluY2x1ZGVzKCdWSUVXJykgfHwgdXBwZXIuaW5jbHVkZXMoJ01BVEVSSUFMSVpFRCBWSUVXJykpKSB7XHJcbiAgICAgICAgY29uc3QgaXNNYXQgPSB1cHBlci5pbmNsdWRlcygnTUFURVJJQUxJWkVEJyk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldE1hdGNoKC9DUkVBVEVcXHMrKD86T1JcXHMrUkVQTEFDRVxccyspPyg/Ok1BVEVSSUFMSVpFRFxccyspP1ZJRVdcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVBMQUNFJykgJiYgbWV0YWRhdGE/Lm9sZFZpZXdEZWZpbml0aW9uKSByZXR1cm4gbWV0YWRhdGEub2xkVmlld0RlZmluaXRpb247XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBgRFJPUCAke2lzTWF0ID8gJ01BVEVSSUFMSVpFRCAnIDogJyd9VklFVyAke25hbWV9O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdSRUZSRVNIIE1BVEVSSUFMSVpFRCBWSUVXJykpIHJldHVybiAnTUFOVUFMJztcclxuXHJcbiAgICAvLyA5LiBGVU5DVElPTlMgLyBQUk9DRURVUkVTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgKHVwcGVyLmluY2x1ZGVzKCdGVU5DVElPTicpIHx8IHVwcGVyLmluY2x1ZGVzKCdQUk9DRURVUkUnKSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdXBwZXIuaW5jbHVkZXMoJ0ZVTkNUSU9OJykgPyAnRlVOQ1RJT04nIDogJ1BST0NFRFVSRSc7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVBMQUNFJykgJiYgbWV0YWRhdGE/Lm9sZEJvZHkpIHJldHVybiBtZXRhZGF0YS5vbGRCb2R5O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRNYXRjaCgvQ1JFQVRFXFxzKyg/Ok9SXFxzK1JFUExBQ0VcXHMrKT8oRlVOQ1RJT058UFJPQ0VEVVJFKVxccysoW2BcIl0/KShcXHcrKVxcMi9pLCAzKTtcclxuICAgICAgICByZXR1cm4gbmFtZSA/IGBEUk9QICR7dHlwZX0gJHtuYW1lfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMTAuIFRSSUdHRVJTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFRSSUdHRVInKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC9DUkVBVEVcXHMrVFJJR0dFUlxccysoW2BcIl0/KShcXHcrKVxcMVxccytPTlxccysoW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gbSA/IGBEUk9QIFRSSUdHRVIgJHttWzJdfSBPTiAke21bNF19O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnRU5BQkxFIFRSSUdHRVInKSB8fCB1cHBlci5pbmNsdWRlcygnRElTQUJMRSBUUklHR0VSJykpIHtcclxuICAgICAgICBjb25zdCBpc0VuYWJsZSA9IHVwcGVyLmluY2x1ZGVzKCdFTkFCTEUnKTtcclxuICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKEVOQUJMRXxESVNBQkxFKVxccytUUklHR0VSXFxzKyhbYFwiXT8pKFxcdyspXFwzXFxzK09OXFxzKyhbYFwiXT8pKFxcdyspXFw1L2kpO1xyXG4gICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVs1XX0gJHtpc0VuYWJsZSA/ICdESVNBQkxFJyA6ICdFTkFCTEUnfSBUUklHR0VSICR7bVszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDExLiBTRVFVRU5DRVNcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdDUkVBVEUgU0VRVUVOQ0UnKSkgcmV0dXJuIGBEUk9QIFNFUVVFTkNFICR7Z2V0TWF0Y2goL0NSRUFURVxccytTRVFVRU5DRVxccysoW2BcIl0/KShcXHcrKVxcMS9pLCAyKX07YDtcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdEUk9QIFNFUVVFTkNFJykpIHJldHVybiBtZXRhZGF0YT8ub3JpZ2luYWxTZXFTUUwgfHwgJ01BTlVBTCc7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQUxURVIgU0VRVUVOQ0UnKSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRNYXRjaCgvQUxURVJcXHMrU0VRVUVOQ0VcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMik7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVNUQVJUJykpIHJldHVybiAnTUFOVUFMJzsgLy8gdmFsdWUgbG9zdCB1bmxlc3Mgd2UgaGF2ZSBpdFxyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YT8ub2xkU2VxU3RhdGUgPyBgQUxURVIgU0VRVUVOQ0UgJHtuYW1lfSAke21ldGFkYXRhLm9sZFNlcVN0YXRlfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMTIuIERBVEEgKERNTClcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdNRVJHRScpKSByZXR1cm4gJ01BTlVBTCc7IC8vIENvbXBsZXggaW52ZXJzZVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0lOU0VSVFxccytJTlRPXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucHJpbWFyeUtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBwayA9IG1ldGFkYXRhLnByaW1hcnlLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRzID0gT2JqZWN0LmVudHJpZXMocGspLm1hcCgoW2MsIHZdKSA9PiBgJHtjfSA9ICR7dHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3Z9J2AgOiB2fWApLmpvaW4oJyBBTkQgJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBgREVMRVRFIEZST00gJHttYXRjaFsyXX0gV0hFUkUgJHtjb25kc307YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucm93cykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEucm93cy5tYXAoKHJvdzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xzID0gT2JqZWN0LmtleXMocm93KS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFscyA9IE9iamVjdC52YWx1ZXMocm93KS5tYXAodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7dn0nYCA6IHYpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYElOU0VSVCBJTlRPICR7bWF0Y2hbMl19ICgke2NvbHN9KSBWQUxVRVMgKCR7dmFsc30pO2A7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnVVBEQVRFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL1VQREFURVxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBpZiAobWF0Y2ggJiYgbWV0YWRhdGE/Lm9sZFJvd3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLm9sZFJvd3MubWFwKChyb3c6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBtZXRhZGF0YS5wcmltYXJ5S2V5RmllbGRzLnJlZHVjZSgoYWNjOiBhbnksIGY6IHN0cmluZykgPT4gKHsgLi4uYWNjLCBbZl06IHJvd1tmXSB9KSwge30pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gT2JqZWN0LmVudHJpZXMocm93KS5tYXAoKFtjLCB2XSkgPT4gYCR7Y30gPSAke3R5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGAnJHt2fSdgIDogdn1gKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlcmUgPSBPYmplY3QuZW50cmllcyhwaykubWFwKChbYywgdl0pID0+IGAke2N9ID0gJHt0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7dn0nYCA6IHZ9YCkuam9pbignIEFORCAnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgVVBEQVRFICR7bWF0Y2hbMl19IFNFVCAke3NldH0gV0hFUkUgJHt3aGVyZX07YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyAxNC4gUEVSTUlTU0lPTlMgLyBBQ0xcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdHUkFOVCcpKSByZXR1cm4gcS5yZXBsYWNlKC9HUkFOVC9pLCAnUkVWT0tFJykucmVwbGFjZSgvVE8vaSwgJ0ZST00nKTtcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdSRVZPS0UnKSkgcmV0dXJuIHEucmVwbGFjZSgvUkVWT0tFL2ksICdHUkFOVCcpLnJlcGxhY2UoL0ZST00vaSwgJ1RPJyk7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFJPTEUnKSkgcmV0dXJuIGBEUk9QIFJPTEUgJHtnZXRNYXRjaCgvQ1JFQVRFXFxzK1JPTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMil9O2A7XHJcblxyXG4gICAgLy8gMjAuIENPTU1FTlRTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ09NTUVOVCBPTicpKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IHEubWF0Y2goL0NPTU1FTlRcXHMrT05cXHMrKFRBQkxFfENPTFVNTilcXHMrKFtcXHNcXFNdKz8pXFxzK0lTL2kpO1xyXG4gICAgICAgIGlmIChtICYmIG1ldGFkYXRhPy5vbGRDb21tZW50ICE9PSB1bmRlZmluZWQpIHJldHVybiBgQ09NTUVOVCBPTiAke21bMV19ICR7bVsyXX0gSVMgJHttZXRhZGF0YS5vbGRDb21tZW50ID09PSBudWxsID8gJ05VTEwnIDogYCcke21ldGFkYXRhLm9sZENvbW1lbnR9J2B9O2A7XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnTUFOVUFMJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwZW5kaW5nIGNoYW5nZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdDaGFuZ2VzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUNoYW5nZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL3BlbmRpbmc/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhbmdlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBwZW5kaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbW1pdCBwZW5kaW5nIGNoYW5nZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21taXRDaGFuZ2VzKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgbmFtZTogc3RyaW5nOyBlbWFpbDogc3RyaW5nIH1cclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBhd2FpdCBnZXRQZW5kaW5nQ2hhbmdlcyhjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9jb21taXQnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcixcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21taXQgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGNvbW1pdCBoaXN0b3J5IGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21taXRIaXN0b3J5KGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2NvbW1pdD9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gZGF0YS5jb21taXRzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNvbW1pdCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYnJhbmNoZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2JyYW5jaGVzP2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBkYXRhLmJyYW5jaGVzIHx8IFtdLCBjdXJyZW50QnJhbmNoOiBkYXRhLmN1cnJlbnRCcmFuY2ggfHwgJ21haW4nIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYnJhbmNoZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBbXSwgY3VycmVudEJyYW5jaDogJ21haW4nIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgYnJhbmNoXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NyZWF0ZScgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGJyYW5jaDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogIFxyXG4gKiBDaGVja291dCBhIGJyYW5jaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrb3V0QnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NoZWNrb3V0JyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVja291dCBicmFuY2g6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidHJhY2tDaGFuZ2UiLCJjb25uZWN0aW9uSWQiLCJjaGFuZ2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsInRyYWNrU2NoZW1hQ2hhbmdlIiwib3BlcmF0aW9uIiwidGFibGVOYW1lIiwic3FsIiwiYXV0aG9yIiwidHlwZSIsInRvVXBwZXJDYXNlIiwidGFyZ2V0IiwiZGVzY3JpcHRpb24iLCJjaGFyQXQiLCJzbGljZSIsIm5hbWUiLCJxdWVyeSIsInJvbGxiYWNrU1FMIiwiZ2VuZXJhdGVSb2xsYmFja1NRTCIsInN0YXR1cyIsInBhcnNlUXVlcnlGb3JDaGFuZ2VzIiwiYWZmZWN0ZWRSb3dzIiwiY2xlYW5RdWVyeSIsInJlcGxhY2UiLCJ0cmltIiwibm9ybWFsaXplZFF1ZXJ5IiwibWF0Y2giLCJpbmNsdWRlcyIsInRvTG93ZXJDYXNlIiwiZHJvcE9iak1hdGNoIiwicHJvY01hdGNoIiwic3RhcnRzV2l0aCIsImlzTWVyZ2UiLCJvcCIsInNwbGl0IiwibWV0YWRhdGEiLCJxIiwidXBwZXIiLCJnZXRNYXRjaCIsInJlZ2V4IiwiZ3JvdXBJbmRleCIsIm0iLCJvbGRPd25lciIsIm9yaWdpbmFsQ3JlYXRlU1FMIiwibXQiLCJjb2x1bW5EZWZpbml0aW9uIiwib2xkRGVmYXVsdCIsInVuZGVmaW5lZCIsIm9sZENvbHVtblN0YXRlIiwib3JpZ2luYWxJbmRleFNRTCIsImlzTWF0Iiwib2xkVmlld0RlZmluaXRpb24iLCJvbGRCb2R5IiwiaXNFbmFibGUiLCJvcmlnaW5hbFNlcVNRTCIsIm9sZFNlcVN0YXRlIiwicHJpbWFyeUtleSIsInBrIiwiY29uZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiYyIsInYiLCJqb2luIiwicm93cyIsInJvdyIsImNvbHMiLCJrZXlzIiwidmFscyIsInZhbHVlcyIsIm9sZFJvd3MiLCJwcmltYXJ5S2V5RmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZiIsInNldCIsIndoZXJlIiwib2xkQ29tbWVudCIsImdldFBlbmRpbmdDaGFuZ2VzIiwicmVzcG9uc2UiLCJkYXRhIiwianNvbiIsImNoYW5nZXMiLCJjb21taXRDaGFuZ2VzIiwibWVzc2FnZSIsInBlbmRpbmciLCJzbmFwc2hvdCIsInNjaGVtYSIsInRhYmxlcyIsInRpbWVzdGFtcCIsIkRhdGUiLCJyZXN1bHQiLCJzdWNjZXNzIiwiZ2V0Q29tbWl0SGlzdG9yeSIsImNvbW1pdHMiLCJnZXRCcmFuY2hlcyIsImJyYW5jaGVzIiwiY3VycmVudEJyYW5jaCIsImNyZWF0ZUJyYW5jaCIsImFjdGlvbiIsImNoZWNrb3V0QnJhbmNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/vcs-helper.ts\n"));

/***/ })

});