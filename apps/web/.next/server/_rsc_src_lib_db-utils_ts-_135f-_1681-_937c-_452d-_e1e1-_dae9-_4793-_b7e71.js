/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_src_lib_db-utils_ts-_135f-_1681-_937c-_452d-_e1e1-_dae9-_4793-_b7e71";
exports.ids = ["_rsc_src_lib_db-utils_ts-_135f-_1681-_937c-_452d-_e1e1-_dae9-_4793-_b7e71"];
exports.modules = {

/***/ "?135f":
/*!***********************************************!*\
  !*** @aws-sdk/credential-providers (ignored) ***!
  \***********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1681":
/*!**********************************!*\
  !*** @mongodb-js/zstd (ignored) ***!
  \**********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?937c":
/*!******************************!*\
  !*** gcp-metadata (ignored) ***!
  \******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?452d":
/*!**************************!*\
  !*** kerberos (ignored) ***!
  \**************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e1e1":
/*!*******************************************!*\
  !*** mongodb-client-encryption (ignored) ***!
  \*******************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?dae9":
/*!************************!*\
  !*** snappy (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4793":
/*!***********************!*\
  !*** socks (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./src/lib/db-utils.ts":
/*!*****************************!*\
  !*** ./src/lib/db-utils.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getConnectedAdapter: () => (/* binding */ getConnectedAdapter)\n/* harmony export */ });\n/* harmony import */ var _bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bosdb/db-adapters */ \"(rsc)/../../packages/db-adapters/src/index.ts\");\n/* harmony import */ var _bosdb_security__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bosdb/security */ \"(rsc)/../../packages/security/src/index.ts\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/store */ \"(rsc)/./src/lib/store.ts\");\n/* harmony import */ var _docker_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./docker-manager */ \"(rsc)/./src/lib/docker-manager.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__]);\n_bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\nasync function getConnectedAdapter(connectionId) {\n    const connectionInfo = await (0,_lib_store__WEBPACK_IMPORTED_MODULE_2__.getConnection)(connectionId);\n    if (!connectionInfo) {\n        throw new Error(`Connection not found: ${connectionId}`);\n    }\n    // Auto-awake and update activity for ALL Docker-managed databases\n    // This applies to any connection where the host is local (as set during provisioning)\n    if (connectionInfo.host === \"localhost\" || connectionInfo.host === \"127.0.0.1\" || connectionInfo.host === \"host.docker.internal\" || connectionInfo.host?.includes(\"bosdb-provisioned\")) {\n        try {\n            await (0,_docker_manager__WEBPACK_IMPORTED_MODULE_3__.ensureDatabaseStarted)(connectionInfo.port);\n            await (0,_docker_manager__WEBPACK_IMPORTED_MODULE_3__.updateDatabaseActivity)(connectionInfo.port);\n        } catch (error) {\n            console.error(`[db-utils] Failed to handle auto-sleep logic for ${connectionId}:`, error);\n        }\n    }\n    let adapterEntry = _lib_store__WEBPACK_IMPORTED_MODULE_2__.adapterInstances.get(connectionId);\n    if (!adapterEntry) {\n        const adapter = _bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__.AdapterFactory.create(connectionInfo.type);\n        const credentials = (0,_bosdb_security__WEBPACK_IMPORTED_MODULE_1__.decryptCredentials)(connectionInfo.credentials);\n        const connectResult = await adapter.connect({\n            id: connectionId,\n            name: connectionInfo.name,\n            host: connectionInfo.host,\n            port: connectionInfo.port,\n            database: connectionInfo.database,\n            username: credentials.username,\n            password: credentials.password,\n            ssl: connectionInfo.ssl,\n            readOnly: connectionInfo.readOnly\n        });\n        if (!connectResult.success) {\n            throw new Error(\"Failed to connect to database\");\n        }\n        adapterEntry = {\n            adapter,\n            adapterConnectionId: connectResult.connectionId\n        };\n        _lib_store__WEBPACK_IMPORTED_MODULE_2__.adapterInstances.set(connectionId, adapterEntry);\n    }\n    return {\n        adapter: adapterEntry.adapter,\n        adapterConnectionId: adapterEntry.adapterConnectionId\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2RiLXV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ0M7QUFDc0I7QUFDTTtBQUUxRSxlQUFlTSxvQkFBb0JDLFlBQW9CO0lBQzFELE1BQU1DLGlCQUFpQixNQUFNTCx5REFBYUEsQ0FBQ0k7SUFDM0MsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDakIsTUFBTSxJQUFJQyxNQUFNLENBQUMsc0JBQXNCLEVBQUVGLGFBQWEsQ0FBQztJQUMzRDtJQUVBLGtFQUFrRTtJQUNsRSxzRkFBc0Y7SUFDdEYsSUFBSUMsZUFBZUUsSUFBSSxLQUFLLGVBQWVGLGVBQWVFLElBQUksS0FBSyxlQUFlRixlQUFlRSxJQUFJLEtBQUssMEJBQTBCRixlQUFlRSxJQUFJLEVBQUVDLFNBQVMsc0JBQXNCO1FBQ3BMLElBQUk7WUFDQSxNQUFNUCxzRUFBcUJBLENBQUNJLGVBQWVJLElBQUk7WUFDL0MsTUFBTVAsdUVBQXNCQSxDQUFDRyxlQUFlSSxJQUFJO1FBQ3BELEVBQUUsT0FBT0MsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsQ0FBQyxpREFBaUQsRUFBRU4sYUFBYSxDQUFDLENBQUMsRUFBRU07UUFDdkY7SUFDSjtJQUVBLElBQUlFLGVBQWViLHdEQUFnQkEsQ0FBQ2MsR0FBRyxDQUFDVDtJQUV4QyxJQUFJLENBQUNRLGNBQWM7UUFDZixNQUFNRSxVQUFVakIsOERBQWNBLENBQUNrQixNQUFNLENBQUNWLGVBQWVXLElBQUk7UUFDekQsTUFBTUMsY0FBY25CLG1FQUFrQkEsQ0FBQ08sZUFBZVksV0FBVztRQUVqRSxNQUFNQyxnQkFBZ0IsTUFBTUosUUFBUUssT0FBTyxDQUFDO1lBQ3hDQyxJQUFJaEI7WUFDSmlCLE1BQU1oQixlQUFlZ0IsSUFBSTtZQUN6QmQsTUFBTUYsZUFBZUUsSUFBSTtZQUN6QkUsTUFBTUosZUFBZUksSUFBSTtZQUN6QmEsVUFBVWpCLGVBQWVpQixRQUFRO1lBQ2pDQyxVQUFVTixZQUFZTSxRQUFRO1lBQzlCQyxVQUFVUCxZQUFZTyxRQUFRO1lBQzlCQyxLQUFLcEIsZUFBZW9CLEdBQUc7WUFDdkJDLFVBQVVyQixlQUFlcUIsUUFBUTtRQUNyQztRQUVBLElBQUksQ0FBQ1IsY0FBY1MsT0FBTyxFQUFFO1lBQ3hCLE1BQU0sSUFBSXJCLE1BQU07UUFDcEI7UUFFQU0sZUFBZTtZQUNYRTtZQUNBYyxxQkFBcUJWLGNBQWNkLFlBQVk7UUFDbkQ7UUFFQUwsd0RBQWdCQSxDQUFDOEIsR0FBRyxDQUFDekIsY0FBY1E7SUFDdkM7SUFFQSxPQUFPO1FBQ0hFLFNBQVNGLGFBQWFFLE9BQU87UUFDN0JjLHFCQUFxQmhCLGFBQWFnQixtQkFBbUI7SUFDekQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi9zcmMvbGliL2RiLXV0aWxzLnRzPzIzMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWRhcHRlckZhY3RvcnkgfSBmcm9tICdAYm9zZGIvZGItYWRhcHRlcnMnO1xyXG5pbXBvcnQgeyBkZWNyeXB0Q3JlZGVudGlhbHMgfSBmcm9tICdAYm9zZGIvc2VjdXJpdHknO1xyXG5pbXBvcnQgeyBjb25uZWN0aW9ucywgYWRhcHRlckluc3RhbmNlcywgZ2V0Q29ubmVjdGlvbiB9IGZyb20gJ0AvbGliL3N0b3JlJztcclxuaW1wb3J0IHsgZW5zdXJlRGF0YWJhc2VTdGFydGVkLCB1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IH0gZnJvbSAnLi9kb2NrZXItbWFuYWdlcic7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkQWRhcHRlcihjb25uZWN0aW9uSWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkluZm8gPSBhd2FpdCBnZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XHJcbiAgICBpZiAoIWNvbm5lY3Rpb25JbmZvKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXV0by1hd2FrZSBhbmQgdXBkYXRlIGFjdGl2aXR5IGZvciBBTEwgRG9ja2VyLW1hbmFnZWQgZGF0YWJhc2VzXHJcbiAgICAvLyBUaGlzIGFwcGxpZXMgdG8gYW55IGNvbm5lY3Rpb24gd2hlcmUgdGhlIGhvc3QgaXMgbG9jYWwgKGFzIHNldCBkdXJpbmcgcHJvdmlzaW9uaW5nKVxyXG4gICAgaWYgKGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICdsb2NhbGhvc3QnIHx8IGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICcxMjcuMC4wLjEnIHx8IGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICdob3N0LmRvY2tlci5pbnRlcm5hbCcgfHwgY29ubmVjdGlvbkluZm8uaG9zdD8uaW5jbHVkZXMoJ2Jvc2RiLXByb3Zpc2lvbmVkJykpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBlbnN1cmVEYXRhYmFzZVN0YXJ0ZWQoY29ubmVjdGlvbkluZm8ucG9ydCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURhdGFiYXNlQWN0aXZpdHkoY29ubmVjdGlvbkluZm8ucG9ydCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2RiLXV0aWxzXSBGYWlsZWQgdG8gaGFuZGxlIGF1dG8tc2xlZXAgbG9naWMgZm9yICR7Y29ubmVjdGlvbklkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBhZGFwdGVyRW50cnkgPSBhZGFwdGVySW5zdGFuY2VzLmdldChjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgIGlmICghYWRhcHRlckVudHJ5KSB7XHJcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IEFkYXB0ZXJGYWN0b3J5LmNyZWF0ZShjb25uZWN0aW9uSW5mby50eXBlKTtcclxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IGRlY3J5cHRDcmVkZW50aWFscyhjb25uZWN0aW9uSW5mby5jcmVkZW50aWFscyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3RSZXN1bHQgPSBhd2FpdCBhZGFwdGVyLmNvbm5lY3Qoe1xyXG4gICAgICAgICAgICBpZDogY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICBuYW1lOiBjb25uZWN0aW9uSW5mby5uYW1lLFxyXG4gICAgICAgICAgICBob3N0OiBjb25uZWN0aW9uSW5mby5ob3N0LFxyXG4gICAgICAgICAgICBwb3J0OiBjb25uZWN0aW9uSW5mby5wb3J0LFxyXG4gICAgICAgICAgICBkYXRhYmFzZTogY29ubmVjdGlvbkluZm8uZGF0YWJhc2UsXHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiBjcmVkZW50aWFscy51c2VybmFtZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxyXG4gICAgICAgICAgICBzc2w6IGNvbm5lY3Rpb25JbmZvLnNzbCxcclxuICAgICAgICAgICAgcmVhZE9ubHk6IGNvbm5lY3Rpb25JbmZvLnJlYWRPbmx5LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIWNvbm5lY3RSZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIGRhdGFiYXNlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGFwdGVyRW50cnkgPSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXIsXHJcbiAgICAgICAgICAgIGFkYXB0ZXJDb25uZWN0aW9uSWQ6IGNvbm5lY3RSZXN1bHQuY29ubmVjdGlvbklkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYWRhcHRlckluc3RhbmNlcy5zZXQoY29ubmVjdGlvbklkLCBhZGFwdGVyRW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWRhcHRlcjogYWRhcHRlckVudHJ5LmFkYXB0ZXIsXHJcbiAgICAgICAgYWRhcHRlckNvbm5lY3Rpb25JZDogYWRhcHRlckVudHJ5LmFkYXB0ZXJDb25uZWN0aW9uSWRcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbIkFkYXB0ZXJGYWN0b3J5IiwiZGVjcnlwdENyZWRlbnRpYWxzIiwiYWRhcHRlckluc3RhbmNlcyIsImdldENvbm5lY3Rpb24iLCJlbnN1cmVEYXRhYmFzZVN0YXJ0ZWQiLCJ1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IiwiZ2V0Q29ubmVjdGVkQWRhcHRlciIsImNvbm5lY3Rpb25JZCIsImNvbm5lY3Rpb25JbmZvIiwiRXJyb3IiLCJob3N0IiwiaW5jbHVkZXMiLCJwb3J0IiwiZXJyb3IiLCJjb25zb2xlIiwiYWRhcHRlckVudHJ5IiwiZ2V0IiwiYWRhcHRlciIsImNyZWF0ZSIsInR5cGUiLCJjcmVkZW50aWFscyIsImNvbm5lY3RSZXN1bHQiLCJjb25uZWN0IiwiaWQiLCJuYW1lIiwiZGF0YWJhc2UiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic3NsIiwicmVhZE9ubHkiLCJzdWNjZXNzIiwiYWRhcHRlckNvbm5lY3Rpb25JZCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db-utils.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/docker-manager.ts":
/*!***********************************!*\
  !*** ./src/lib/docker-manager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDockerAvailable: () => (/* binding */ checkDockerAvailable),\n/* harmony export */   ensureDatabaseStarted: () => (/* binding */ ensureDatabaseStarted),\n/* harmony export */   loadDockerDatabases: () => (/* binding */ loadDockerDatabases),\n/* harmony export */   pullAndStartDatabase: () => (/* binding */ pullAndStartDatabase),\n/* harmony export */   removeDatabase: () => (/* binding */ removeDatabase),\n/* harmony export */   startDatabase: () => (/* binding */ startDatabase),\n/* harmony export */   startIdleTimeoutCheck: () => (/* binding */ startIdleTimeoutCheck),\n/* harmony export */   stopDatabase: () => (/* binding */ stopDatabase),\n/* harmony export */   syncDatabaseStatus: () => (/* binding */ syncDatabaseStatus),\n/* harmony export */   updateDatabaseActivity: () => (/* binding */ updateDatabaseActivity)\n/* harmony export */ });\n/* harmony import */ var dockerode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dockerode */ \"dockerode\");\n/* harmony import */ var dockerode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dockerode__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst docker = new (dockerode__WEBPACK_IMPORTED_MODULE_0___default())();\n// Storage path for database configurations\nconst STORAGE_DIR = path__WEBPACK_IMPORTED_MODULE_2__.join(process.cwd(), \"data\", \"docker-databases\");\n// Ensure storage directory exists\nif (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(STORAGE_DIR)) {\n    fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(STORAGE_DIR, {\n        recursive: true\n    });\n}\n// Port ranges for different database types\nconst PORT_RANGES = {\n    postgres: 5432,\n    mysql: 3306,\n    mariadb: 3306,\n    mongodb: 27017,\n    redis: 6379,\n    mssql: 1433,\n    oracle: 1521,\n    cassandra: 9042,\n    neo4j: 7687,\n    elasticsearch: 9200,\n    clickhouse: 8123,\n    influxdb: 8086,\n    firebird: 3050,\n    cubrid: 33000,\n    couchbase: 8091,\n    orientdb: 2424,\n    rabbitmq: 5672,\n    minio: 9000\n};\n// Default docker images for database types\nconst DOCKER_IMAGES = {\n    postgres: \"postgres:16-alpine\",\n    mysql: \"mysql:8.0\",\n    mariadb: \"mariadb:11\",\n    mongodb: \"mongo:7\",\n    redis: \"redis:7-alpine\",\n    mssql: \"mcr.microsoft.com/mssql/server:2022-latest\",\n    cassandra: \"cassandra:5\",\n    neo4j: \"neo4j:5\",\n    elasticsearch: \"elasticsearch:8.11.0\",\n    opensearch: \"opensearchproject/opensearch:2.11.0\",\n    clickhouse: \"clickhouse/clickhouse-server:latest\",\n    influxdb: \"influxdb:2.7-alpine\",\n    timescaledb: \"timescale/timescaledb:latest-pg16\",\n    cockroachdb: \"cockroachdb/cockroach:latest\",\n    yugabyte: \"yugabytedb/yugabyte:latest\",\n    tidb: \"pingcap/tidb:latest\",\n    scylladb: \"scylladb/scylla:latest\",\n    ferretdb: \"ghcr.io/ferretdb/ferretdb:latest\",\n    couchdb: \"couchdb:3\",\n    solr: \"solr:9\",\n    memcached: \"memcached:1.6-alpine\",\n    rabbitmq: \"rabbitmq:3-management-alpine\",\n    minio: \"minio/minio:latest\",\n    surrealdb: \"surrealdb/surrealdb:latest\",\n    oracle: \"gvenzl/oracle-free:latest\",\n    firebird: \"jacobalberty/firebird:latest\",\n    cubrid: \"cubrid/cubrid:latest\",\n    h2: \"oscarfonts/h2:latest\",\n    couchbase: \"couchbase:latest\",\n    orientdb: \"orientdb:3.2\",\n    prometheus: \"prom/prometheus:latest\"\n};\n/**\r\n * Check if Docker is available and running\r\n */ async function checkDockerAvailable() {\n    try {\n        await docker.ping();\n        return true;\n    } catch (error) {\n        console.error(\"[Docker] Docker is not available:\", error);\n        return false;\n    }\n}\n/**\r\n * Find an available port starting from the default port\r\n */ async function findAvailablePort(startPort) {\n    const usedPorts = await getUsedPorts();\n    let port = startPort;\n    while(usedPorts.has(port)){\n        port++;\n    }\n    return port;\n}\n/**\r\n * Get all currently used ports\r\n */ async function getUsedPorts() {\n    const databases = getAllDockerDatabases();\n    return new Set(databases.map((db)=>db.port));\n}\n/**\r\n * Get storage file path for organization\r\n */ function getStorageFilePath(organizationId) {\n    return path__WEBPACK_IMPORTED_MODULE_2__.join(STORAGE_DIR, `${organizationId}.json`);\n}\n/**\r\n * Load databases for a specific organization\r\n */ function loadDockerDatabases(organizationId) {\n    const filePath = getStorageFilePath(organizationId);\n    if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(filePath)) {\n        return [];\n    }\n    try {\n        const data = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filePath, \"utf-8\");\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(`[Docker] Failed to load databases for org ${organizationId}:`, error);\n        return [];\n    }\n}\n/**\r\n * Get all databases across all organizations\r\n */ function getAllDockerDatabases() {\n    const databases = [];\n    if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(STORAGE_DIR)) {\n        return databases;\n    }\n    const files = fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync(STORAGE_DIR);\n    for (const file of files){\n        if (file.endsWith(\".json\")) {\n            try {\n                const data = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(path__WEBPACK_IMPORTED_MODULE_2__.join(STORAGE_DIR, file), \"utf-8\");\n                const orgDatabases = JSON.parse(data);\n                databases.push(...orgDatabases);\n            } catch (error) {\n                console.error(`[Docker] Failed to load ${file}:`, error);\n            }\n        }\n    }\n    return databases;\n}\n/**\r\n * Save databases for a specific organization\r\n */ function saveDockerDatabases(organizationId, databases) {\n    const filePath = getStorageFilePath(organizationId);\n    fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(filePath, JSON.stringify(databases, null, 2));\n}\n/**\r\n * Generate database credentials\r\n */ function generateCredentials(type, name) {\n    const username = type === \"postgres\" || type === \"timescaledb\" ? \"postgres\" : type === \"mysql\" || type === \"mariadb\" ? \"root\" : type === \"mongodb\" ? \"admin\" : type === \"mssql\" ? \"sa\" : \"admin\";\n    const password = `${name}_${Math.random().toString(36).substring(2, 10)}`;\n    const database = type === \"mongodb\" ? \"admin\" : name.toLowerCase().replace(/[^a-z0-9]/g, \"_\");\n    return {\n        username,\n        password,\n        database\n    };\n}\n/**\r\n * Get environment variables for database container\r\n */ function getEnvironmentVariables(type, credentials) {\n    const { username, password, database } = credentials;\n    switch(type){\n        case \"postgres\":\n        case \"timescaledb\":\n            return [\n                `POSTGRES_USER=${username}`,\n                `POSTGRES_PASSWORD=${password}`,\n                `POSTGRES_DB=${database}`\n            ];\n        case \"mysql\":\n        case \"mariadb\":\n            return [\n                `MYSQL_ROOT_PASSWORD=${password}`,\n                `MYSQL_DATABASE=${database}`\n            ];\n        case \"mongodb\":\n            return [\n                `MONGO_INITDB_ROOT_USERNAME=${username}`,\n                `MONGO_INITDB_ROOT_PASSWORD=${password}`\n            ];\n        case \"redis\":\n            return [\n                `REDIS_PASSWORD=${password}`\n            ];\n        case \"mssql\":\n            return [\n                \"ACCEPT_EULA=Y\",\n                `MSSQL_SA_PASSWORD=${password}`\n            ];\n        case \"neo4j\":\n            return [\n                `NEO4J_AUTH=${username}/${password}`\n            ];\n        case \"elasticsearch\":\n            return [\n                \"discovery.type=single-node\",\n                `ELASTIC_PASSWORD=${password}`,\n                \"xpack.security.enabled=false\"\n            ];\n        case \"opensearch\":\n            return [\n                \"discovery.type=single-node\",\n                `OPENSEARCH_INITIAL_ADMIN_PASSWORD=${password}`,\n                \"plugins.security.disabled=true\"\n            ];\n        case \"influxdb\":\n            return [\n                `DOCKER_INFLUXDB_INIT_USERNAME=${username}`,\n                `DOCKER_INFLUXDB_INIT_PASSWORD=${password}`,\n                `DOCKER_INFLUXDB_INIT_ORG=bosdb`,\n                `DOCKER_INFLUXDB_INIT_BUCKET=${database}`,\n                \"DOCKER_INFLUXDB_INIT_MODE=setup\"\n            ];\n        case \"rabbitmq\":\n            return [\n                `RABBITMQ_DEFAULT_USER=${username}`,\n                `RABBITMQ_DEFAULT_PASS=${password}`\n            ];\n        case \"minio\":\n            return [\n                `MINIO_ROOT_USER=${username}`,\n                `MINIO_ROOT_PASSWORD=${password}`\n            ];\n        case \"oracle\":\n            return [\n                `ORACLE_PASSWORD=${password}`,\n                `ORACLE_DATABASE=${database}`\n            ];\n        case \"firebird\":\n            return [\n                `ISC_PASSWORD=${password}`\n            ];\n        case \"couchbase\":\n            return [\n                `COUCHBASE_ADMINISTRATOR_USERNAME=${username}`,\n                `COUCHBASE_ADMINISTRATOR_PASSWORD=${password}`\n            ];\n        case \"orientdb\":\n            return [\n                `ORIENTDB_ROOT_PASSWORD=${password}`\n            ];\n        default:\n            return [];\n    }\n}\n/**\r\n * Pull Docker image and start database container\r\n */ async function pullAndStartDatabase(type, name, organizationId, autoStart = true, signal) {\n    const image = DOCKER_IMAGES[type];\n    if (!image) {\n        throw new Error(`Unsupported database type: ${type}`);\n    }\n    if (signal?.aborted) {\n        throw new Error(\"Provisioning cancelled\");\n    }\n    console.log(`[Docker] Checking if image ${image} exists localy...`);\n    const images = await docker.listImages();\n    const imageExists = images.some((img)=>img.RepoTags?.includes(image));\n    if (!imageExists) {\n        console.log(`[Docker] Pulling image ${image}...`);\n        // Pull the image\n        await new Promise((resolve, reject)=>{\n            let pullStream;\n            const abortHandler = ()=>{\n                if (pullStream && pullStream.destroy) {\n                    pullStream.destroy();\n                }\n                reject(new Error(\"Provisioning cancelled\"));\n            };\n            if (signal) {\n                signal.addEventListener(\"abort\", abortHandler);\n            }\n            docker.pull(image, (err, stream)=>{\n                if (err) {\n                    if (signal) signal.removeEventListener(\"abort\", abortHandler);\n                    reject(err);\n                    return;\n                }\n                pullStream = stream;\n                docker.modem.followProgress(stream, (err)=>{\n                    if (signal) signal.removeEventListener(\"abort\", abortHandler);\n                    if (err) {\n                        if (signal?.aborted) reject(new Error(\"Provisioning cancelled\"));\n                        else reject(err);\n                    } else resolve();\n                });\n            });\n        });\n        if (signal?.aborted) {\n            throw new Error(\"Provisioning cancelled\");\n        }\n        console.log(`[Docker] Image ${image} pulled successfully`);\n    } else {\n        console.log(`[Docker] Image ${image} already exists, skipping pull`);\n    }\n    // Generate database ID and credentials\n    const id = `${type}_${name}_${Date.now()}`.toLowerCase().replace(/[^a-z0-9_]/g, \"_\");\n    const credentials = generateCredentials(type, name);\n    const defaultPort = PORT_RANGES[type] || 5432;\n    const port = await findAvailablePort(defaultPort);\n    // Create container configuration\n    const env = getEnvironmentVariables(type, credentials);\n    const containerName = `bosdb_${id}`;\n    const createOptions = {\n        Image: image,\n        name: containerName,\n        Env: env,\n        HostConfig: {\n            PortBindings: {\n                [`${defaultPort}/tcp`]: [\n                    {\n                        HostPort: String(port)\n                    }\n                ]\n            },\n            RestartPolicy: autoStart ? {\n                Name: \"unless-stopped\"\n            } : {\n                Name: \"no\"\n            }\n        },\n        Labels: {\n            \"bosdb.managed\": \"true\",\n            \"bosdb.type\": type,\n            \"bosdb.organization\": organizationId\n        }\n    };\n    // Special configurations for specific databases\n    if (type === \"minio\") {\n        createOptions.Cmd = [\n            \"server\",\n            \"/data\",\n            \"--console-address\",\n            \":9001\"\n        ];\n        createOptions.HostConfig.PortBindings[\"9001/tcp\"] = [\n            {\n                HostPort: String(port + 1)\n            }\n        ];\n    } else if (type === \"neo4j\") {\n        createOptions.HostConfig.PortBindings[\"7474/tcp\"] = [\n            {\n                HostPort: String(port + 1)\n            }\n        ];\n    } else if (type === \"cockroachdb\") {\n        createOptions.Cmd = [\n            \"start-single-node\",\n            \"--insecure\"\n        ];\n        createOptions.HostConfig.PortBindings[\"26257/tcp\"] = [\n            {\n                HostPort: String(port)\n            }\n        ];\n        createOptions.HostConfig.PortBindings[\"8080/tcp\"] = [\n            {\n                HostPort: String(port + 100)\n            }\n        ];\n    }\n    console.log(`[Docker] Creating container ${containerName}...`);\n    // Create and start container\n    const container = await docker.createContainer(createOptions);\n    const containerId = container.id;\n    if (autoStart) {\n        console.log(`[Docker] Starting container ${containerName}...`);\n        await container.start();\n    }\n    // Create database record\n    const database = {\n        id,\n        type,\n        name,\n        port,\n        username: credentials.username,\n        password: credentials.password,\n        database: credentials.database,\n        status: autoStart ? \"running\" : \"stopped\",\n        autoStart,\n        createdAt: new Date().toISOString(),\n        lastUsedAt: new Date().toISOString(),\n        organizationId,\n        containerId\n    };\n    // Save to storage\n    const databases = loadDockerDatabases(organizationId);\n    databases.push(database);\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} created successfully`);\n    return database;\n}\n/**\r\n * Start a stopped database\r\n */ async function startDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (!database.containerId) {\n        throw new Error(`Container ID not found for database ${id}`);\n    }\n    const container = docker.getContainer(database.containerId);\n    await container.start();\n    // Update status and activity\n    database.status = \"running\";\n    database.lastUsedAt = new Date().toISOString();\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} started`);\n}\n/**\r\n * Stop a running database\r\n */ async function stopDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (!database.containerId) {\n        throw new Error(`Container ID not found for database ${id}`);\n    }\n    const container = docker.getContainer(database.containerId);\n    await container.stop();\n    // Update status\n    database.status = \"stopped\";\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} stopped`);\n}\n/**\r\n * Remove a database and its container\r\n */ async function removeDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (database.containerId) {\n        try {\n            const container = docker.getContainer(database.containerId);\n            // Stop if running\n            try {\n                await container.stop();\n            } catch (error) {\n            // Container might already be stopped\n            }\n            // Remove container\n            await container.remove();\n        } catch (error) {\n            console.error(`[Docker] Failed to remove container for ${id}:`, error);\n        }\n    }\n    // Remove from storage\n    const updatedDatabases = databases.filter((db)=>db.id !== id);\n    saveDockerDatabases(organizationId, updatedDatabases);\n    console.log(`[Docker] Database ${id} removed`);\n}\n/**\r\n * Sync database status with actual Docker containers\r\n */ async function syncDatabaseStatus(organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    let updated = false;\n    for (const database of databases){\n        if (database.containerId) {\n            try {\n                const container = docker.getContainer(database.containerId);\n                const info = await container.inspect();\n                const newStatus = info.State.Running ? \"running\" : \"stopped\";\n                if (database.status !== newStatus) {\n                    database.status = newStatus;\n                    updated = true;\n                }\n            } catch (error) {\n                console.error(`[Docker] Failed to get status for ${database.id}:`, error);\n                database.status = \"error\";\n                updated = true;\n            }\n        }\n    }\n    if (updated) {\n        saveDockerDatabases(organizationId, databases);\n    }\n}\n/**\r\n * Update the last used timestamp for a database by its port\r\n */ async function updateDatabaseActivity(port) {\n    const databases = getAllDockerDatabases();\n    const db = databases.find((d)=>d.port === port);\n    if (db) {\n        db.lastUsedAt = new Date().toISOString();\n        // We need to find which org it belongs to for saving\n        const orgDatabases = loadDockerDatabases(db.organizationId);\n        const orgDb = orgDatabases.find((d)=>d.id === db.id);\n        if (orgDb) {\n            orgDb.lastUsedAt = db.lastUsedAt;\n            saveDockerDatabases(db.organizationId, orgDatabases);\n        }\n    }\n}\n/**\r\n * Ensure a database is started if it's currently stopped\r\n */ async function ensureDatabaseStarted(port) {\n    const databases = getAllDockerDatabases();\n    const db = databases.find((d)=>d.port === port);\n    if (db && db.status === \"stopped\" && db.containerId) {\n        console.log(`[Docker] Auto-awakening database ${db.id} on port ${db.port}...`);\n        await startDatabase(db.id, db.organizationId);\n        // Wait a bit for the DB to be ready\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n    }\n}\n/**\r\n * Background check for idle databases to stop them (Auto-Sleep)\r\n */ let idleCheckInterval = null;\nconst IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes\nfunction startIdleTimeoutCheck() {\n    if (idleCheckInterval) return;\n    console.log(\"[Docker] Starting background idle timeout check (10 min)...\");\n    idleCheckInterval = setInterval(async ()=>{\n        const databases = getAllDockerDatabases();\n        const now = Date.now();\n        for (const db of databases){\n            if (db.status === \"running\" && db.lastUsedAt && db.containerId) {\n                const lastUsed = new Date(db.lastUsedAt).getTime();\n                if (now - lastUsed > IDLE_TIMEOUT_MS) {\n                    console.log(`[Docker] Database ${db.id} on port ${db.port} is idle for >10m. Sleeping...`);\n                    try {\n                        await stopDatabase(db.id, db.organizationId);\n                    } catch (error) {\n                        console.error(`[Docker] Failed to auto-sleep database ${db.id}:`, error);\n                    }\n                }\n            } else if (db.status === \"running\" && !db.lastUsedAt) {\n                // Initialize lastUsedAt if missing so it can eventually sleep\n                db.lastUsedAt = new Date().toISOString();\n                const orgDatabases = loadDockerDatabases(db.organizationId);\n                const orgDb = orgDatabases.find((d)=>d.id === db.id);\n                if (orgDb) {\n                    orgDb.lastUsedAt = db.lastUsedAt;\n                    saveDockerDatabases(db.organizationId, orgDatabases);\n                }\n            }\n        }\n    }, 60000); // Check every minute\n}\n// Start the check automatically\nif (true) {\n    startIdleTimeoutCheck();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdOLElBQUksQ0FBQyw4QkFBOEIsQ0FBQztvQkFDekYsSUFBSTt3QkFDQSxNQUFNNkYsYUFBYXZGLEdBQUcyRCxFQUFFLEVBQUUzRCxHQUFHRSxjQUFjO29CQUMvQyxFQUFFLE9BQU9kLE9BQU87d0JBQ1pDLFFBQVFELEtBQUssQ0FBQyxDQUFDLHVDQUF1QyxFQUFFWSxHQUFHMkQsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFdkU7b0JBQ3RFO2dCQUNKO1lBQ0osT0FBTyxJQUFJWSxHQUFHZ0YsTUFBTSxLQUFLLGFBQWEsQ0FBQ2hGLEdBQUdtRixVQUFVLEVBQUU7Z0JBQ2xELDhEQUE4RDtnQkFDOURuRixHQUFHbUYsVUFBVSxHQUFHLElBQUl2QixPQUFPc0IsV0FBVztnQkFDdEMsTUFBTXJFLGVBQWVWLG9CQUFvQkgsR0FBR0UsY0FBYztnQkFDMUQsTUFBTW9HLFFBQVF6RixhQUFhd0UsSUFBSSxDQUFDZ0IsQ0FBQUEsSUFBS0EsRUFBRTFDLEVBQUUsS0FBSzNELEdBQUcyRCxFQUFFO2dCQUNuRCxJQUFJMkMsT0FBTztvQkFDUEEsTUFBTW5CLFVBQVUsR0FBR25GLEdBQUdtRixVQUFVO29CQUNoQ3BFLG9CQUFvQmYsR0FBR0UsY0FBYyxFQUFFVztnQkFDM0M7WUFDSjtRQUNKO0lBQ0osR0FBRyxRQUFRLHFCQUFxQjtBQUNwQztBQUVBLGdDQUFnQztBQUNoQyxJQUFJLElBQWtCLEVBQWE7SUFDL0I4RjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uL3NyYy9saWIvZG9ja2VyLW1hbmFnZXIudHM/OTk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9ja2VyIGZyb20gJ2RvY2tlcm9kZSc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgRGF0YWJhc2VUeXBlIH0gZnJvbSAnQC9jb25zdGFudHMvZGF0YWJhc2UtdHlwZXMnO1xyXG5cclxuY29uc3QgZG9ja2VyID0gbmV3IERvY2tlcigpO1xyXG5cclxuLy8gU3RvcmFnZSBwYXRoIGZvciBkYXRhYmFzZSBjb25maWd1cmF0aW9uc1xyXG5jb25zdCBTVE9SQUdFX0RJUiA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGF0YScsICdkb2NrZXItZGF0YWJhc2VzJyk7XHJcblxyXG4vLyBFbnN1cmUgc3RvcmFnZSBkaXJlY3RvcnkgZXhpc3RzXHJcbmlmICghZnMuZXhpc3RzU3luYyhTVE9SQUdFX0RJUikpIHtcclxuICAgIGZzLm1rZGlyU3luYyhTVE9SQUdFX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyRGF0YWJhc2Uge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHR5cGU6IERhdGFiYXNlVHlwZTtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHBvcnQ6IG51bWJlcjtcclxuICAgIHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgICBwYXNzd29yZDogc3RyaW5nO1xyXG4gICAgZGF0YWJhc2U6IHN0cmluZztcclxuICAgIHN0YXR1czogJ3J1bm5pbmcnIHwgJ3N0b3BwZWQnIHwgJ2Vycm9yJztcclxuICAgIGF1dG9TdGFydDogYm9vbGVhbjtcclxuICAgIGNyZWF0ZWRBdDogc3RyaW5nO1xyXG4gICAgbGFzdFVzZWRBdD86IHN0cmluZzsgLy8gVHJhY2sgbGFzdCBhY3Rpdml0eSBmb3IgYXV0by1zbGVlcFxyXG4gICAgb3JnYW5pemF0aW9uSWQ6IHN0cmluZztcclxuICAgIGNvbnRhaW5lcklkPzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBQb3J0IHJhbmdlcyBmb3IgZGlmZmVyZW50IGRhdGFiYXNlIHR5cGVzXHJcbmNvbnN0IFBPUlRfUkFOR0VTOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICAgcG9zdGdyZXM6IDU0MzIsXHJcbiAgICBteXNxbDogMzMwNixcclxuICAgIG1hcmlhZGI6IDMzMDYsXHJcbiAgICBtb25nb2RiOiAyNzAxNyxcclxuICAgIHJlZGlzOiA2Mzc5LFxyXG4gICAgbXNzcWw6IDE0MzMsXHJcbiAgICBvcmFjbGU6IDE1MjEsXHJcbiAgICBjYXNzYW5kcmE6IDkwNDIsXHJcbiAgICBuZW80ajogNzY4NyxcclxuICAgIGVsYXN0aWNzZWFyY2g6IDkyMDAsXHJcbiAgICBjbGlja2hvdXNlOiA4MTIzLFxyXG4gICAgaW5mbHV4ZGI6IDgwODYsXHJcbiAgICBmaXJlYmlyZDogMzA1MCxcclxuICAgIGN1YnJpZDogMzMwMDAsXHJcbiAgICBjb3VjaGJhc2U6IDgwOTEsXHJcbiAgICBvcmllbnRkYjogMjQyNCxcclxuICAgIHJhYmJpdG1xOiA1NjcyLFxyXG4gICAgbWluaW86IDkwMDBcclxufTtcclxuXHJcbi8vIERlZmF1bHQgZG9ja2VyIGltYWdlcyBmb3IgZGF0YWJhc2UgdHlwZXNcclxuY29uc3QgRE9DS0VSX0lNQUdFUzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgIHBvc3RncmVzOiAncG9zdGdyZXM6MTYtYWxwaW5lJyxcclxuICAgIG15c3FsOiAnbXlzcWw6OC4wJyxcclxuICAgIG1hcmlhZGI6ICdtYXJpYWRiOjExJyxcclxuICAgIG1vbmdvZGI6ICdtb25nbzo3JyxcclxuICAgIHJlZGlzOiAncmVkaXM6Ny1hbHBpbmUnLFxyXG4gICAgbXNzcWw6ICdtY3IubWljcm9zb2Z0LmNvbS9tc3NxbC9zZXJ2ZXI6MjAyMi1sYXRlc3QnLFxyXG4gICAgY2Fzc2FuZHJhOiAnY2Fzc2FuZHJhOjUnLFxyXG4gICAgbmVvNGo6ICduZW80ajo1JyxcclxuICAgIGVsYXN0aWNzZWFyY2g6ICdlbGFzdGljc2VhcmNoOjguMTEuMCcsXHJcbiAgICBvcGVuc2VhcmNoOiAnb3BlbnNlYXJjaHByb2plY3Qvb3BlbnNlYXJjaDoyLjExLjAnLFxyXG4gICAgY2xpY2tob3VzZTogJ2NsaWNraG91c2UvY2xpY2tob3VzZS1zZXJ2ZXI6bGF0ZXN0JyxcclxuICAgIGluZmx1eGRiOiAnaW5mbHV4ZGI6Mi43LWFscGluZScsXHJcbiAgICB0aW1lc2NhbGVkYjogJ3RpbWVzY2FsZS90aW1lc2NhbGVkYjpsYXRlc3QtcGcxNicsXHJcbiAgICBjb2Nrcm9hY2hkYjogJ2NvY2tyb2FjaGRiL2NvY2tyb2FjaDpsYXRlc3QnLFxyXG4gICAgeXVnYWJ5dGU6ICd5dWdhYnl0ZWRiL3l1Z2FieXRlOmxhdGVzdCcsXHJcbiAgICB0aWRiOiAncGluZ2NhcC90aWRiOmxhdGVzdCcsXHJcbiAgICBzY3lsbGFkYjogJ3NjeWxsYWRiL3NjeWxsYTpsYXRlc3QnLFxyXG4gICAgZmVycmV0ZGI6ICdnaGNyLmlvL2ZlcnJldGRiL2ZlcnJldGRiOmxhdGVzdCcsXHJcbiAgICBjb3VjaGRiOiAnY291Y2hkYjozJyxcclxuICAgIHNvbHI6ICdzb2xyOjknLFxyXG4gICAgbWVtY2FjaGVkOiAnbWVtY2FjaGVkOjEuNi1hbHBpbmUnLFxyXG4gICAgcmFiYml0bXE6ICdyYWJiaXRtcTozLW1hbmFnZW1lbnQtYWxwaW5lJyxcclxuICAgIG1pbmlvOiAnbWluaW8vbWluaW86bGF0ZXN0JyxcclxuICAgIHN1cnJlYWxkYjogJ3N1cnJlYWxkYi9zdXJyZWFsZGI6bGF0ZXN0JyxcclxuICAgIG9yYWNsZTogJ2d2ZW56bC9vcmFjbGUtZnJlZTpsYXRlc3QnLFxyXG4gICAgZmlyZWJpcmQ6ICdqYWNvYmFsYmVydHkvZmlyZWJpcmQ6bGF0ZXN0JyxcclxuICAgIGN1YnJpZDogJ2N1YnJpZC9jdWJyaWQ6bGF0ZXN0JyxcclxuICAgIGgyOiAnb3NjYXJmb250cy9oMjpsYXRlc3QnLFxyXG4gICAgY291Y2hiYXNlOiAnY291Y2hiYXNlOmxhdGVzdCcsXHJcbiAgICBvcmllbnRkYjogJ29yaWVudGRiOjMuMicsXHJcbiAgICBwcm9tZXRoZXVzOiAncHJvbS9wcm9tZXRoZXVzOmxhdGVzdCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBEb2NrZXIgaXMgYXZhaWxhYmxlIGFuZCBydW5uaW5nXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEb2NrZXJBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGRvY2tlci5waW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tEb2NrZXJdIERvY2tlciBpcyBub3QgYXZhaWxhYmxlOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuIGF2YWlsYWJsZSBwb3J0IHN0YXJ0aW5nIGZyb20gdGhlIGRlZmF1bHQgcG9ydFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmluZEF2YWlsYWJsZVBvcnQoc3RhcnRQb3J0OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgY29uc3QgdXNlZFBvcnRzID0gYXdhaXQgZ2V0VXNlZFBvcnRzKCk7XHJcbiAgICBsZXQgcG9ydCA9IHN0YXJ0UG9ydDtcclxuICAgIHdoaWxlICh1c2VkUG9ydHMuaGFzKHBvcnQpKSB7XHJcbiAgICAgICAgcG9ydCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvcnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIGN1cnJlbnRseSB1c2VkIHBvcnRzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VkUG9ydHMoKTogUHJvbWlzZTxTZXQ8bnVtYmVyPj4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk7XHJcbiAgICByZXR1cm4gbmV3IFNldChkYXRhYmFzZXMubWFwKGRiID0+IGRiLnBvcnQpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBzdG9yYWdlIGZpbGUgcGF0aCBmb3Igb3JnYW5pemF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdG9yYWdlRmlsZVBhdGgob3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gcGF0aC5qb2luKFNUT1JBR0VfRElSLCBgJHtvcmdhbml6YXRpb25JZH0uanNvbmApO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZCBkYXRhYmFzZXMgZm9yIGEgc3BlY2lmaWMgb3JnYW5pemF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZDogc3RyaW5nKTogRG9ja2VyRGF0YWJhc2VbXSB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGdldFN0b3JhZ2VGaWxlUGF0aChvcmdhbml6YXRpb25JZCk7XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0RvY2tlcl0gRmFpbGVkIHRvIGxvYWQgZGF0YWJhc2VzIGZvciBvcmcgJHtvcmdhbml6YXRpb25JZH06YCwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgZGF0YWJhc2VzIGFjcm9zcyBhbGwgb3JnYW5pemF0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk6IERvY2tlckRhdGFiYXNlW10ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzOiBEb2NrZXJEYXRhYmFzZVtdID0gW107XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoU1RPUkFHRV9ESVIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFiYXNlcztcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoU1RPUkFHRV9ESVIpO1xyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoJy5qc29uJykpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKFNUT1JBR0VfRElSLCBmaWxlKSwgJ3V0Zi04Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdEYXRhYmFzZXMgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZGF0YWJhc2VzLnB1c2goLi4ub3JnRGF0YWJhc2VzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBsb2FkICR7ZmlsZX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFiYXNlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNhdmUgZGF0YWJhc2VzIGZvciBhIHNwZWNpZmljIG9yZ2FuaXphdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZDogc3RyaW5nLCBkYXRhYmFzZXM6IERvY2tlckRhdGFiYXNlW10pOiB2b2lkIHtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gZ2V0U3RvcmFnZUZpbGVQYXRoKG9yZ2FuaXphdGlvbklkKTtcclxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGFiYXNlcywgbnVsbCwgMikpO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgZGF0YWJhc2UgY3JlZGVudGlhbHNcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ3JlZGVudGlhbHModHlwZTogRGF0YWJhc2VUeXBlLCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHVzZXJuYW1lID0gdHlwZSA9PT0gJ3Bvc3RncmVzJyB8fCB0eXBlID09PSAndGltZXNjYWxlZGInID8gJ3Bvc3RncmVzJyA6XHJcbiAgICAgICAgdHlwZSA9PT0gJ215c3FsJyB8fCB0eXBlID09PSAnbWFyaWFkYicgPyAncm9vdCcgOlxyXG4gICAgICAgICAgICB0eXBlID09PSAnbW9uZ29kYicgPyAnYWRtaW4nIDpcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09ICdtc3NxbCcgPyAnc2EnIDpcclxuICAgICAgICAgICAgICAgICAgICAnYWRtaW4nO1xyXG5cclxuICAgIGNvbnN0IHBhc3N3b3JkID0gYCR7bmFtZX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApfWA7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IHR5cGUgPT09ICdtb25nb2RiJyA/ICdhZG1pbicgOiBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICdfJyk7XHJcblxyXG4gICAgcmV0dXJuIHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBkYXRhYmFzZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGF0YWJhc2UgY29udGFpbmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh0eXBlOiBEYXRhYmFzZVR5cGUsIGNyZWRlbnRpYWxzOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCwgZGF0YWJhc2UgfSA9IGNyZWRlbnRpYWxzO1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3Bvc3RncmVzJzpcclxuICAgICAgICBjYXNlICd0aW1lc2NhbGVkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgUE9TVEdSRVNfVVNFUj0ke3VzZXJuYW1lfWAsXHJcbiAgICAgICAgICAgICAgICBgUE9TVEdSRVNfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICAgICAgYFBPU1RHUkVTX0RCPSR7ZGF0YWJhc2V9YCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdteXNxbCc6XHJcbiAgICAgICAgY2FzZSAnbWFyaWFkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgTVlTUUxfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgICAgICBgTVlTUUxfREFUQUJBU0U9JHtkYXRhYmFzZX1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ21vbmdvZGInOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgYE1PTkdPX0lOSVREQl9ST09UX1VTRVJOQU1FPSR7dXNlcm5hbWV9YCxcclxuICAgICAgICAgICAgICAgIGBNT05HT19JTklUREJfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSAncmVkaXMnOlxyXG4gICAgICAgICAgICByZXR1cm4gW2BSRURJU19QQVNTV09SRD0ke3Bhc3N3b3JkfWBdO1xyXG4gICAgICAgIGNhc2UgJ21zc3FsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICdBQ0NFUFRfRVVMQT1ZJyxcclxuICAgICAgICAgICAgICAgIGBNU1NRTF9TQV9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSAnbmVvNGonOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgYE5FTzRKX0FVVEg9JHt1c2VybmFtZX0vJHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2VsYXN0aWNzZWFyY2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgJ2Rpc2NvdmVyeS50eXBlPXNpbmdsZS1ub2RlJyxcclxuICAgICAgICAgICAgICAgIGBFTEFTVElDX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgICd4cGFjay5zZWN1cml0eS5lbmFibGVkPWZhbHNlJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdvcGVuc2VhcmNoJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICdkaXNjb3ZlcnkudHlwZT1zaW5nbGUtbm9kZScsXHJcbiAgICAgICAgICAgICAgICBgT1BFTlNFQVJDSF9JTklUSUFMX0FETUlOX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgICdwbHVnaW5zLnNlY3VyaXR5LmRpc2FibGVkPXRydWUnLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2luZmx1eGRiJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBET0NLRVJfSU5GTFVYREJfSU5JVF9VU0VSTkFNRT0ke3VzZXJuYW1lfWAsXHJcbiAgICAgICAgICAgICAgICBgRE9DS0VSX0lORkxVWERCX0lOSVRfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICAgICAgYERPQ0tFUl9JTkZMVVhEQl9JTklUX09SRz1ib3NkYmAsXHJcbiAgICAgICAgICAgICAgICBgRE9DS0VSX0lORkxVWERCX0lOSVRfQlVDS0VUPSR7ZGF0YWJhc2V9YCxcclxuICAgICAgICAgICAgICAgICdET0NLRVJfSU5GTFVYREJfSU5JVF9NT0RFPXNldHVwJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdyYWJiaXRtcSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgUkFCQklUTVFfREVGQVVMVF9VU0VSPSR7dXNlcm5hbWV9YCxcclxuICAgICAgICAgICAgICAgIGBSQUJCSVRNUV9ERUZBVUxUX1BBU1M9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ21pbmlvJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBNSU5JT19ST09UX1VTRVI9JHt1c2VybmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgYE1JTklPX1JPT1RfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ29yYWNsZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgT1JBQ0xFX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgIGBPUkFDTEVfREFUQUJBU0U9JHtkYXRhYmFzZX1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2ZpcmViaXJkJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBJU0NfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2NvdWNoYmFzZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgQ09VQ0hCQVNFX0FETUlOSVNUUkFUT1JfVVNFUk5BTUU9JHt1c2VybmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgYENPVUNIQkFTRV9BRE1JTklTVFJBVE9SX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdvcmllbnRkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgT1JJRU5UREJfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHVsbCBEb2NrZXIgaW1hZ2UgYW5kIHN0YXJ0IGRhdGFiYXNlIGNvbnRhaW5lclxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1bGxBbmRTdGFydERhdGFiYXNlKFxyXG4gICAgdHlwZTogRGF0YWJhc2VUeXBlLFxyXG4gICAgbmFtZTogc3RyaW5nLFxyXG4gICAgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyxcclxuICAgIGF1dG9TdGFydDogYm9vbGVhbiA9IHRydWUsXHJcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbFxyXG4pOiBQcm9taXNlPERvY2tlckRhdGFiYXNlPiB7XHJcbiAgICBjb25zdCBpbWFnZSA9IERPQ0tFUl9JTUFHRVNbdHlwZV07XHJcbiAgICBpZiAoIWltYWdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSB0eXBlOiAke3R5cGV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBDaGVja2luZyBpZiBpbWFnZSAke2ltYWdlfSBleGlzdHMgbG9jYWx5Li4uYCk7XHJcbiAgICBjb25zdCBpbWFnZXMgPSBhd2FpdCBkb2NrZXIubGlzdEltYWdlcygpO1xyXG4gICAgY29uc3QgaW1hZ2VFeGlzdHMgPSBpbWFnZXMuc29tZShpbWcgPT4gaW1nLlJlcG9UYWdzPy5pbmNsdWRlcyhpbWFnZSkpO1xyXG5cclxuICAgIGlmICghaW1hZ2VFeGlzdHMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gUHVsbGluZyBpbWFnZSAke2ltYWdlfS4uLmApO1xyXG5cclxuICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHB1bGxTdHJlYW06IGFueTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwdWxsU3RyZWFtICYmIHB1bGxTdHJlYW0uZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1bGxTdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaWduYWwpIHtcclxuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRvY2tlci5wdWxsKGltYWdlLCAoZXJyOiBhbnksIHN0cmVhbTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwdWxsU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgZG9ja2VyLm1vZGVtLmZvbGxvd1Byb2dyZXNzKHN0cmVhbSwgKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHJlamVjdChuZXcgRXJyb3IoJ1Byb3Zpc2lvbmluZyBjYW5jZWxsZWQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEltYWdlICR7aW1hZ2V9IHB1bGxlZCBzdWNjZXNzZnVsbHlgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEltYWdlICR7aW1hZ2V9IGFscmVhZHkgZXhpc3RzLCBza2lwcGluZyBwdWxsYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgZGF0YWJhc2UgSUQgYW5kIGNyZWRlbnRpYWxzXHJcbiAgICBjb25zdCBpZCA9IGAke3R5cGV9XyR7bmFtZX1fJHtEYXRlLm5vdygpfWAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV9dL2csICdfJyk7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGdlbmVyYXRlQ3JlZGVudGlhbHModHlwZSwgbmFtZSk7XHJcbiAgICBjb25zdCBkZWZhdWx0UG9ydCA9IFBPUlRfUkFOR0VTW3R5cGVdIHx8IDU0MzI7XHJcbiAgICBjb25zdCBwb3J0ID0gYXdhaXQgZmluZEF2YWlsYWJsZVBvcnQoZGVmYXVsdFBvcnQpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBjb250YWluZXIgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgZW52ID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXModHlwZSwgY3JlZGVudGlhbHMpO1xyXG4gICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGBib3NkYl8ke2lkfWA7XHJcblxyXG4gICAgY29uc3QgY3JlYXRlT3B0aW9uczogYW55ID0ge1xyXG4gICAgICAgIEltYWdlOiBpbWFnZSxcclxuICAgICAgICBuYW1lOiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgIEVudjogZW52LFxyXG4gICAgICAgIEhvc3RDb25maWc6IHtcclxuICAgICAgICAgICAgUG9ydEJpbmRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBbYCR7ZGVmYXVsdFBvcnR9L3RjcGBdOiBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQpIH1dLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBSZXN0YXJ0UG9saWN5OiBhdXRvU3RhcnQgPyB7IE5hbWU6ICd1bmxlc3Mtc3RvcHBlZCcgfSA6IHsgTmFtZTogJ25vJyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTGFiZWxzOiB7XHJcbiAgICAgICAgICAgICdib3NkYi5tYW5hZ2VkJzogJ3RydWUnLFxyXG4gICAgICAgICAgICAnYm9zZGIudHlwZSc6IHR5cGUsXHJcbiAgICAgICAgICAgICdib3NkYi5vcmdhbml6YXRpb24nOiBvcmdhbml6YXRpb25JZCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTcGVjaWFsIGNvbmZpZ3VyYXRpb25zIGZvciBzcGVjaWZpYyBkYXRhYmFzZXNcclxuICAgIGlmICh0eXBlID09PSAnbWluaW8nKSB7XHJcbiAgICAgICAgY3JlYXRlT3B0aW9ucy5DbWQgPSBbJ3NlcnZlcicsICcvZGF0YScsICctLWNvbnNvbGUtYWRkcmVzcycsICc6OTAwMSddO1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzkwMDEvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxKSB9XTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25lbzRqJykge1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzc0NzQvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxKSB9XTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvY2tyb2FjaGRiJykge1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuQ21kID0gWydzdGFydC1zaW5nbGUtbm9kZScsICctLWluc2VjdXJlJ107XHJcbiAgICAgICAgY3JlYXRlT3B0aW9ucy5Ib3N0Q29uZmlnLlBvcnRCaW5kaW5nc1snMjYyNTcvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQpIH1dO1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzgwODAvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxMDApIH1dO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBDcmVhdGluZyBjb250YWluZXIgJHtjb250YWluZXJOYW1lfS4uLmApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgc3RhcnQgY29udGFpbmVyXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBhd2FpdCBkb2NrZXIuY3JlYXRlQ29udGFpbmVyKGNyZWF0ZU9wdGlvbnMpO1xyXG4gICAgY29uc3QgY29udGFpbmVySWQgPSBjb250YWluZXIuaWQ7XHJcblxyXG4gICAgaWYgKGF1dG9TdGFydCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBTdGFydGluZyBjb250YWluZXIgJHtjb250YWluZXJOYW1lfS4uLmApO1xyXG4gICAgICAgIGF3YWl0IGNvbnRhaW5lci5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBkYXRhYmFzZSByZWNvcmRcclxuICAgIGNvbnN0IGRhdGFiYXNlOiBEb2NrZXJEYXRhYmFzZSA9IHtcclxuICAgICAgICBpZCxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgcG9ydCxcclxuICAgICAgICB1c2VybmFtZTogY3JlZGVudGlhbHMudXNlcm5hbWUsXHJcbiAgICAgICAgcGFzc3dvcmQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxyXG4gICAgICAgIGRhdGFiYXNlOiBjcmVkZW50aWFscy5kYXRhYmFzZSxcclxuICAgICAgICBzdGF0dXM6IGF1dG9TdGFydCA/ICdydW5uaW5nJyA6ICdzdG9wcGVkJyxcclxuICAgICAgICBhdXRvU3RhcnQsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgbGFzdFVzZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBJbml0aWFsaXplIGFjdGl2aXR5XHJcbiAgICAgICAgb3JnYW5pemF0aW9uSWQsXHJcbiAgICAgICAgY29udGFpbmVySWQsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNhdmUgdG8gc3RvcmFnZVxyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBkYXRhYmFzZXMucHVzaChkYXRhYmFzZSk7XHJcbiAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCBkYXRhYmFzZXMpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBEYXRhYmFzZSAke2lkfSBjcmVhdGVkIHN1Y2Nlc3NmdWxseWApO1xyXG5cclxuICAgIHJldHVybiBkYXRhYmFzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0YXJ0IGEgc3RvcHBlZCBkYXRhYmFzZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RGF0YWJhc2UoaWQ6IHN0cmluZywgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IGRhdGFiYXNlcy5maW5kKGRiID0+IGRiLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJHtpZH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZS5jb250YWluZXJJZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyIElEIG5vdCBmb3VuZCBmb3IgZGF0YWJhc2UgJHtpZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgIGF3YWl0IGNvbnRhaW5lci5zdGFydCgpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgYW5kIGFjdGl2aXR5XHJcbiAgICBkYXRhYmFzZS5zdGF0dXMgPSAncnVubmluZyc7XHJcbiAgICBkYXRhYmFzZS5sYXN0VXNlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCwgZGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gc3RhcnRlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogU3RvcCBhIHJ1bm5pbmcgZGF0YWJhc2VcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9wRGF0YWJhc2UoaWQ6IHN0cmluZywgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IGRhdGFiYXNlcy5maW5kKGRiID0+IGRiLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJHtpZH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZS5jb250YWluZXJJZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyIElEIG5vdCBmb3VuZCBmb3IgZGF0YWJhc2UgJHtpZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgIGF3YWl0IGNvbnRhaW5lci5zdG9wKCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHN0YXR1c1xyXG4gICAgZGF0YWJhc2Uuc3RhdHVzID0gJ3N0b3BwZWQnO1xyXG4gICAgc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCwgZGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gc3RvcHBlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgZGF0YWJhc2UgYW5kIGl0cyBjb250YWluZXJcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVEYXRhYmFzZShpZDogc3RyaW5nLCBvcmdhbml6YXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBkYXRhYmFzZXMgPSBsb2FkRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkKTtcclxuICAgIGNvbnN0IGRhdGFiYXNlID0gZGF0YWJhc2VzLmZpbmQoZGIgPT4gZGIuaWQgPT09IGlkKTtcclxuXHJcbiAgICBpZiAoIWRhdGFiYXNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSAke2lkfSBub3QgZm91bmRgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YWJhc2UuY29udGFpbmVySWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgICAgICAgICAgLy8gU3RvcCBpZiBydW5uaW5nXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb250YWluZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIG1pZ2h0IGFscmVhZHkgYmUgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb250YWluZXJcclxuICAgICAgICAgICAgYXdhaXQgY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byByZW1vdmUgY29udGFpbmVyIGZvciAke2lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBmcm9tIHN0b3JhZ2VcclxuICAgIGNvbnN0IHVwZGF0ZWREYXRhYmFzZXMgPSBkYXRhYmFzZXMuZmlsdGVyKGRiID0+IGRiLmlkICE9PSBpZCk7XHJcbiAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCB1cGRhdGVkRGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gcmVtb3ZlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogU3luYyBkYXRhYmFzZSBzdGF0dXMgd2l0aCBhY3R1YWwgRG9ja2VyIGNvbnRhaW5lcnNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jRGF0YWJhc2VTdGF0dXMob3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAoY29uc3QgZGF0YWJhc2Ugb2YgZGF0YWJhc2VzKSB7XHJcbiAgICAgICAgaWYgKGRhdGFiYXNlLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBjb250YWluZXIuaW5zcGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gaW5mby5TdGF0ZS5SdW5uaW5nID8gJ3J1bm5pbmcnIDogJ3N0b3BwZWQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhYmFzZS5zdGF0dXMgIT09IG5ld1N0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlLnN0YXR1cyA9IG5ld1N0YXR1cztcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBnZXQgc3RhdHVzIGZvciAke2RhdGFiYXNlLmlkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBkYXRhYmFzZS5zdGF0dXMgPSAnZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwZGF0ZWQpIHtcclxuICAgICAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCBkYXRhYmFzZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBsYXN0IHVzZWQgdGltZXN0YW1wIGZvciBhIGRhdGFiYXNlIGJ5IGl0cyBwb3J0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGF0YWJhc2VBY3Rpdml0eShwb3J0OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGRhdGFiYXNlcyA9IGdldEFsbERvY2tlckRhdGFiYXNlcygpO1xyXG4gICAgY29uc3QgZGIgPSBkYXRhYmFzZXMuZmluZChkID0+IGQucG9ydCA9PT0gcG9ydCk7XHJcblxyXG4gICAgaWYgKGRiKSB7XHJcbiAgICAgICAgZGIubGFzdFVzZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgd2hpY2ggb3JnIGl0IGJlbG9uZ3MgdG8gZm9yIHNhdmluZ1xyXG4gICAgICAgIGNvbnN0IG9yZ0RhdGFiYXNlcyA9IGxvYWREb2NrZXJEYXRhYmFzZXMoZGIub3JnYW5pemF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IG9yZ0RiID0gb3JnRGF0YWJhc2VzLmZpbmQoZCA9PiBkLmlkID09PSBkYi5pZCk7XHJcbiAgICAgICAgaWYgKG9yZ0RiKSB7XHJcbiAgICAgICAgICAgIG9yZ0RiLmxhc3RVc2VkQXQgPSBkYi5sYXN0VXNlZEF0O1xyXG4gICAgICAgICAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKGRiLm9yZ2FuaXphdGlvbklkLCBvcmdEYXRhYmFzZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSBhIGRhdGFiYXNlIGlzIHN0YXJ0ZWQgaWYgaXQncyBjdXJyZW50bHkgc3RvcHBlZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZURhdGFiYXNlU3RhcnRlZChwb3J0OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGRhdGFiYXNlcyA9IGdldEFsbERvY2tlckRhdGFiYXNlcygpO1xyXG4gICAgY29uc3QgZGIgPSBkYXRhYmFzZXMuZmluZChkID0+IGQucG9ydCA9PT0gcG9ydCk7XHJcblxyXG4gICAgaWYgKGRiICYmIGRiLnN0YXR1cyA9PT0gJ3N0b3BwZWQnICYmIGRiLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEF1dG8tYXdha2VuaW5nIGRhdGFiYXNlICR7ZGIuaWR9IG9uIHBvcnQgJHtkYi5wb3J0fS4uLmApO1xyXG4gICAgICAgIGF3YWl0IHN0YXJ0RGF0YWJhc2UoZGIuaWQsIGRiLm9yZ2FuaXphdGlvbklkKTtcclxuICAgICAgICAvLyBXYWl0IGEgYml0IGZvciB0aGUgREIgdG8gYmUgcmVhZHlcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQmFja2dyb3VuZCBjaGVjayBmb3IgaWRsZSBkYXRhYmFzZXMgdG8gc3RvcCB0aGVtIChBdXRvLVNsZWVwKVxyXG4gKi9cclxubGV0IGlkbGVDaGVja0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG5jb25zdCBJRExFX1RJTUVPVVRfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SWRsZVRpbWVvdXRDaGVjaygpIHtcclxuICAgIGlmIChpZGxlQ2hlY2tJbnRlcnZhbCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdbRG9ja2VyXSBTdGFydGluZyBiYWNrZ3JvdW5kIGlkbGUgdGltZW91dCBjaGVjayAoMTAgbWluKS4uLicpO1xyXG4gICAgaWRsZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YWJhc2VzID0gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBkYiBvZiBkYXRhYmFzZXMpIHtcclxuICAgICAgICAgICAgaWYgKGRiLnN0YXR1cyA9PT0gJ3J1bm5pbmcnICYmIGRiLmxhc3RVc2VkQXQgJiYgZGIuY29udGFpbmVySWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RVc2VkID0gbmV3IERhdGUoZGIubGFzdFVzZWRBdCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RVc2VkID4gSURMRV9USU1FT1VUX01TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIERhdGFiYXNlICR7ZGIuaWR9IG9uIHBvcnQgJHtkYi5wb3J0fSBpcyBpZGxlIGZvciA+MTBtLiBTbGVlcGluZy4uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0b3BEYXRhYmFzZShkYi5pZCwgZGIub3JnYW5pemF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBhdXRvLXNsZWVwIGRhdGFiYXNlICR7ZGIuaWR9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGIuc3RhdHVzID09PSAncnVubmluZycgJiYgIWRiLmxhc3RVc2VkQXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgbGFzdFVzZWRBdCBpZiBtaXNzaW5nIHNvIGl0IGNhbiBldmVudHVhbGx5IHNsZWVwXHJcbiAgICAgICAgICAgICAgICBkYi5sYXN0VXNlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnRGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhkYi5vcmdhbml6YXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdEYiA9IG9yZ0RhdGFiYXNlcy5maW5kKGQgPT4gZC5pZCA9PT0gZGIuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yZ0RiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JnRGIubGFzdFVzZWRBdCA9IGRiLmxhc3RVc2VkQXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZURvY2tlckRhdGFiYXNlcyhkYi5vcmdhbml6YXRpb25JZCwgb3JnRGF0YWJhc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIDYwMDAwKTsgLy8gQ2hlY2sgZXZlcnkgbWludXRlXHJcbn1cclxuXHJcbi8vIFN0YXJ0IHRoZSBjaGVjayBhdXRvbWF0aWNhbGx5XHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgc3RhcnRJZGxlVGltZW91dENoZWNrKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkRvY2tlciIsImZzIiwicGF0aCIsImRvY2tlciIsIlNUT1JBR0VfRElSIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiUE9SVF9SQU5HRVMiLCJwb3N0Z3JlcyIsIm15c3FsIiwibWFyaWFkYiIsIm1vbmdvZGIiLCJyZWRpcyIsIm1zc3FsIiwib3JhY2xlIiwiY2Fzc2FuZHJhIiwibmVvNGoiLCJlbGFzdGljc2VhcmNoIiwiY2xpY2tob3VzZSIsImluZmx1eGRiIiwiZmlyZWJpcmQiLCJjdWJyaWQiLCJjb3VjaGJhc2UiLCJvcmllbnRkYiIsInJhYmJpdG1xIiwibWluaW8iLCJET0NLRVJfSU1BR0VTIiwib3BlbnNlYXJjaCIsInRpbWVzY2FsZWRiIiwiY29ja3JvYWNoZGIiLCJ5dWdhYnl0ZSIsInRpZGIiLCJzY3lsbGFkYiIsImZlcnJldGRiIiwiY291Y2hkYiIsInNvbHIiLCJtZW1jYWNoZWQiLCJzdXJyZWFsZGIiLCJoMiIsInByb21ldGhldXMiLCJjaGVja0RvY2tlckF2YWlsYWJsZSIsInBpbmciLCJlcnJvciIsImNvbnNvbGUiLCJmaW5kQXZhaWxhYmxlUG9ydCIsInN0YXJ0UG9ydCIsInVzZWRQb3J0cyIsImdldFVzZWRQb3J0cyIsInBvcnQiLCJoYXMiLCJkYXRhYmFzZXMiLCJnZXRBbGxEb2NrZXJEYXRhYmFzZXMiLCJTZXQiLCJtYXAiLCJkYiIsImdldFN0b3JhZ2VGaWxlUGF0aCIsIm9yZ2FuaXphdGlvbklkIiwibG9hZERvY2tlckRhdGFiYXNlcyIsImZpbGVQYXRoIiwiZGF0YSIsInJlYWRGaWxlU3luYyIsIkpTT04iLCJwYXJzZSIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWxlIiwiZW5kc1dpdGgiLCJvcmdEYXRhYmFzZXMiLCJwdXNoIiwic2F2ZURvY2tlckRhdGFiYXNlcyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJnZW5lcmF0ZUNyZWRlbnRpYWxzIiwidHlwZSIsIm5hbWUiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZGF0YWJhc2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImNyZWRlbnRpYWxzIiwicHVsbEFuZFN0YXJ0RGF0YWJhc2UiLCJhdXRvU3RhcnQiLCJzaWduYWwiLCJpbWFnZSIsIkVycm9yIiwiYWJvcnRlZCIsImxvZyIsImltYWdlcyIsImxpc3RJbWFnZXMiLCJpbWFnZUV4aXN0cyIsInNvbWUiLCJpbWciLCJSZXBvVGFncyIsImluY2x1ZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwdWxsU3RyZWFtIiwiYWJvcnRIYW5kbGVyIiwiZGVzdHJveSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdWxsIiwiZXJyIiwic3RyZWFtIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vZGVtIiwiZm9sbG93UHJvZ3Jlc3MiLCJpZCIsIkRhdGUiLCJub3ciLCJkZWZhdWx0UG9ydCIsImVudiIsImNvbnRhaW5lck5hbWUiLCJjcmVhdGVPcHRpb25zIiwiSW1hZ2UiLCJFbnYiLCJIb3N0Q29uZmlnIiwiUG9ydEJpbmRpbmdzIiwiSG9zdFBvcnQiLCJTdHJpbmciLCJSZXN0YXJ0UG9saWN5IiwiTmFtZSIsIkxhYmVscyIsIkNtZCIsImNvbnRhaW5lciIsImNyZWF0ZUNvbnRhaW5lciIsImNvbnRhaW5lcklkIiwic3RhcnQiLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImxhc3RVc2VkQXQiLCJzdGFydERhdGFiYXNlIiwiZmluZCIsImdldENvbnRhaW5lciIsInN0b3BEYXRhYmFzZSIsInN0b3AiLCJyZW1vdmVEYXRhYmFzZSIsInJlbW92ZSIsInVwZGF0ZWREYXRhYmFzZXMiLCJmaWx0ZXIiLCJzeW5jRGF0YWJhc2VTdGF0dXMiLCJ1cGRhdGVkIiwiaW5mbyIsImluc3BlY3QiLCJuZXdTdGF0dXMiLCJTdGF0ZSIsIlJ1bm5pbmciLCJ1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IiwiZCIsIm9yZ0RiIiwiZW5zdXJlRGF0YWJhc2VTdGFydGVkIiwic2V0VGltZW91dCIsImlkbGVDaGVja0ludGVydmFsIiwiSURMRV9USU1FT1VUX01TIiwic3RhcnRJZGxlVGltZW91dENoZWNrIiwic2V0SW50ZXJ2YWwiLCJsYXN0VXNlZCIsImdldFRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/docker-manager.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/constants/index.ts":
/*!**************************************************!*\
  !*** ../../packages/core/src/constants/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CONNECTION_TIMEOUT: () => (/* binding */ DEFAULT_CONNECTION_TIMEOUT),\n/* harmony export */   DEFAULT_MAX_ROWS: () => (/* binding */ DEFAULT_MAX_ROWS),\n/* harmony export */   DEFAULT_PAGE_SIZE: () => (/* binding */ DEFAULT_PAGE_SIZE),\n/* harmony export */   DEFAULT_POOL_SIZE: () => (/* binding */ DEFAULT_POOL_SIZE),\n/* harmony export */   DEFAULT_PORTS: () => (/* binding */ DEFAULT_PORTS),\n/* harmony export */   DEFAULT_QUERY_TIMEOUT: () => (/* binding */ DEFAULT_QUERY_TIMEOUT),\n/* harmony export */   IDLE_TIMEOUT: () => (/* binding */ IDLE_TIMEOUT),\n/* harmony export */   MAX_PAGE_SIZE: () => (/* binding */ MAX_PAGE_SIZE),\n/* harmony export */   MAX_POOL_SIZE: () => (/* binding */ MAX_POOL_SIZE),\n/* harmony export */   MAX_QUERY_TIMEOUT: () => (/* binding */ MAX_QUERY_TIMEOUT),\n/* harmony export */   MAX_ROWS_LIMIT: () => (/* binding */ MAX_ROWS_LIMIT),\n/* harmony export */   RATE_LIMIT: () => (/* binding */ RATE_LIMIT)\n/* harmony export */ });\n/**\n * Application-wide constants\n */ // Query Limits\nconst DEFAULT_QUERY_TIMEOUT = 30000; // 30 seconds\nconst MAX_QUERY_TIMEOUT = 300000; // 5 minutes\nconst DEFAULT_MAX_ROWS = 1000;\nconst MAX_ROWS_LIMIT = 100000;\n// Connection Limits\nconst DEFAULT_CONNECTION_TIMEOUT = 5000; // 5 seconds\nconst DEFAULT_POOL_SIZE = 10;\nconst MAX_POOL_SIZE = 50;\nconst IDLE_TIMEOUT = 30000; // 30 seconds\n// Rate Limits\nconst RATE_LIMIT = {\n    queriesPerMinute: 30,\n    connectionsPerWorkspace: 10,\n    maxConcurrentQueries: 5,\n    savedQueriesPerWorkspace: 100\n};\n// Database Default Ports\nconst DEFAULT_PORTS = {\n    postgresql: 5432,\n    mysql: 3306,\n    mongodb: 27017\n};\n// Pagination\nconst DEFAULT_PAGE_SIZE = 50;\nconst MAX_PAGE_SIZE = 1000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY29uc3RhbnRzL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRUQsZUFBZTtBQUNSLE1BQU1BLHdCQUF3QixNQUFNLENBQUMsYUFBYTtBQUNsRCxNQUFNQyxvQkFBb0IsT0FBTyxDQUFDLFlBQVk7QUFDOUMsTUFBTUMsbUJBQW1CLEtBQUs7QUFDOUIsTUFBTUMsaUJBQWlCLE9BQU87QUFFckMsb0JBQW9CO0FBQ2IsTUFBTUMsNkJBQTZCLEtBQUssQ0FBQyxZQUFZO0FBQ3JELE1BQU1DLG9CQUFvQixHQUFHO0FBQzdCLE1BQU1DLGdCQUFnQixHQUFHO0FBQ3pCLE1BQU1DLGVBQWUsTUFBTSxDQUFDLGFBQWE7QUFFaEQsY0FBYztBQUNQLE1BQU1DLGFBQWE7SUFDdEJDLGtCQUFrQjtJQUNsQkMseUJBQXlCO0lBQ3pCQyxzQkFBc0I7SUFDdEJDLDBCQUEwQjtBQUM5QixFQUFXO0FBRVgseUJBQXlCO0FBQ2xCLE1BQU1DLGdCQUF3QztJQUNqREMsWUFBWTtJQUNaQyxPQUFPO0lBQ1BDLFNBQVM7QUFDYixFQUFFO0FBS0YsYUFBYTtBQUNOLE1BQU1DLG9CQUFvQixHQUFHO0FBQzdCLE1BQU1DLGdCQUFnQixLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9jb25zdGFudHMvaW5kZXgudHM/ZTc4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFwcGxpY2F0aW9uLXdpZGUgY29uc3RhbnRzXG4gKi9cblxuLy8gUXVlcnkgTGltaXRzXG5leHBvcnQgY29uc3QgREVGQVVMVF9RVUVSWV9USU1FT1VUID0gMzAwMDA7IC8vIDMwIHNlY29uZHNcbmV4cG9ydCBjb25zdCBNQVhfUVVFUllfVElNRU9VVCA9IDMwMDAwMDsgLy8gNSBtaW51dGVzXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfUk9XUyA9IDEwMDA7XG5leHBvcnQgY29uc3QgTUFYX1JPV1NfTElNSVQgPSAxMDAwMDA7XG5cbi8vIENvbm5lY3Rpb24gTGltaXRzXG5leHBvcnQgY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1MDAwOyAvLyA1IHNlY29uZHNcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xuZXhwb3J0IGNvbnN0IE1BWF9QT09MX1NJWkUgPSA1MDtcbmV4cG9ydCBjb25zdCBJRExFX1RJTUVPVVQgPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuXG4vLyBSYXRlIExpbWl0c1xuZXhwb3J0IGNvbnN0IFJBVEVfTElNSVQgPSB7XG4gICAgcXVlcmllc1Blck1pbnV0ZTogMzAsXG4gICAgY29ubmVjdGlvbnNQZXJXb3Jrc3BhY2U6IDEwLFxuICAgIG1heENvbmN1cnJlbnRRdWVyaWVzOiA1LFxuICAgIHNhdmVkUXVlcmllc1BlcldvcmtzcGFjZTogMTAwLFxufSBhcyBjb25zdDtcblxuLy8gRGF0YWJhc2UgRGVmYXVsdCBQb3J0c1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUE9SVFM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgcG9zdGdyZXNxbDogNTQzMixcbiAgICBteXNxbDogMzMwNixcbiAgICBtb25nb2RiOiAyNzAxNyxcbn07XG5cbi8vIEV4cG9ydCBGb3JtYXRcbmV4cG9ydCB0eXBlIEV4cG9ydEZvcm1hdCA9ICdjc3YnIHwgJ2pzb24nIHwgJ3NxbCc7XG5cbi8vIFBhZ2luYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BBR0VfU0laRSA9IDUwO1xuZXhwb3J0IGNvbnN0IE1BWF9QQUdFX1NJWkUgPSAxMDAwO1xuIl0sIm5hbWVzIjpbIkRFRkFVTFRfUVVFUllfVElNRU9VVCIsIk1BWF9RVUVSWV9USU1FT1VUIiwiREVGQVVMVF9NQVhfUk9XUyIsIk1BWF9ST1dTX0xJTUlUIiwiREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJERUZBVUxUX1BPT0xfU0laRSIsIk1BWF9QT09MX1NJWkUiLCJJRExFX1RJTUVPVVQiLCJSQVRFX0xJTUlUIiwicXVlcmllc1Blck1pbnV0ZSIsImNvbm5lY3Rpb25zUGVyV29ya3NwYWNlIiwibWF4Q29uY3VycmVudFF1ZXJpZXMiLCJzYXZlZFF1ZXJpZXNQZXJXb3Jrc3BhY2UiLCJERUZBVUxUX1BPUlRTIiwicG9zdGdyZXNxbCIsIm15c3FsIiwibW9uZ29kYiIsIkRFRkFVTFRfUEFHRV9TSVpFIiwiTUFYX1BBR0VfU0laRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/constants/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/index.ts":
/*!****************************************!*\
  !*** ../../packages/core/src/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BosDBError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.BosDBError),\n/* harmony export */   ConnectionError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionError),\n/* harmony export */   DEFAULT_CONNECTION_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CONNECTION_TIMEOUT),\n/* harmony export */   DEFAULT_MAX_ROWS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_MAX_ROWS),\n/* harmony export */   DEFAULT_PAGE_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PAGE_SIZE),\n/* harmony export */   DEFAULT_POOL_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_POOL_SIZE),\n/* harmony export */   DEFAULT_PORTS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PORTS),\n/* harmony export */   DEFAULT_QUERY_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_QUERY_TIMEOUT),\n/* harmony export */   IDLE_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.IDLE_TIMEOUT),\n/* harmony export */   MAX_PAGE_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_PAGE_SIZE),\n/* harmony export */   MAX_POOL_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_POOL_SIZE),\n/* harmony export */   MAX_QUERY_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_QUERY_TIMEOUT),\n/* harmony export */   MAX_ROWS_LIMIT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_ROWS_LIMIT),\n/* harmony export */   QueryExecutionError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.QueryExecutionError),\n/* harmony export */   RATE_LIMIT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.RATE_LIMIT),\n/* harmony export */   SecurityError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.SecurityError),\n/* harmony export */   ValidationError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.ValidationError)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(rsc)/../../packages/core/src/types/index.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(rsc)/../../packages/core/src/constants/index.ts\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9pbmRleC50cz8zYjk3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/types/index.ts":
/*!**********************************************!*\
  !*** ../../packages/core/src/types/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BosDBError: () => (/* binding */ BosDBError),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   QueryExecutionError: () => (/* binding */ QueryExecutionError),\n/* harmony export */   SecurityError: () => (/* binding */ SecurityError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError)\n/* harmony export */ });\n/**\n * Core type definitions for BosDB\n */ // Database Types\n// Error Types\nclass BosDBError extends Error {\n    constructor(message, code, details){\n        super(message);\n        this.code = code;\n        this.details = details;\n        this.name = \"BosDBError\";\n    }\n}\nclass ConnectionError extends BosDBError {\n    constructor(message, details){\n        super(message, \"CONNECTION_ERROR\", details);\n        this.name = \"ConnectionError\";\n    }\n}\nclass QueryExecutionError extends BosDBError {\n    constructor(message, details){\n        super(message, \"QUERY_EXECUTION_ERROR\", details);\n        this.name = \"QueryExecutionError\";\n    }\n}\nclass SecurityError extends BosDBError {\n    constructor(message, details){\n        super(message, \"SECURITY_ERROR\", details);\n        this.name = \"SecurityError\";\n    }\n}\nclass ValidationError extends BosDBError {\n    constructor(message, details){\n        super(message, \"VALIDATION_ERROR\", details);\n        this.name = \"ValidationError\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvdHlwZXMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELGlCQUFpQjtBQStNakIsY0FBYztBQUNQLE1BQU1BLG1CQUFtQkM7SUFDNUJDLFlBQ0lDLE9BQWUsRUFDZixJQUFvQixFQUNwQixPQUFvQixDQUN0QjtRQUNFLEtBQUssQ0FBQ0E7YUFIQ0MsT0FBQUE7YUFDQUMsVUFBQUE7UUFHUCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBRU8sTUFBTUMsd0JBQXdCUDtJQUNqQ0UsWUFBWUMsT0FBZSxFQUFFRSxPQUFhLENBQUU7UUFDeEMsS0FBSyxDQUFDRixTQUFTLG9CQUFvQkU7UUFDbkMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUVPLE1BQU1FLDRCQUE0QlI7SUFDckNFLFlBQVlDLE9BQWUsRUFBRUUsT0FBYSxDQUFFO1FBQ3hDLEtBQUssQ0FBQ0YsU0FBUyx5QkFBeUJFO1FBQ3hDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFFTyxNQUFNRyxzQkFBc0JUO0lBQy9CRSxZQUFZQyxPQUFlLEVBQUVFLE9BQWEsQ0FBRTtRQUN4QyxLQUFLLENBQUNGLFNBQVMsa0JBQWtCRTtRQUNqQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBRU8sTUFBTUksd0JBQXdCVjtJQUNqQ0UsWUFBWUMsT0FBZSxFQUFFRSxPQUFhLENBQUU7UUFDeEMsS0FBSyxDQUFDRixTQUFTLG9CQUFvQkU7UUFDbkMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvdHlwZXMvaW5kZXgudHM/Y2U3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgdHlwZSBkZWZpbml0aW9ucyBmb3IgQm9zREJcbiAqL1xuXG4vLyBEYXRhYmFzZSBUeXBlc1xuZXhwb3J0IHR5cGUgRGF0YWJhc2VUeXBlID0gJ3Bvc3RncmVzcWwnIHwgJ215c3FsJyB8ICdtYXJpYWRiJyB8ICdtb25nb2RiJyB8ICdyZWRpcyc7XG5cbmV4cG9ydCB0eXBlIERhdGFiYXNlU3RhdHVzID0gJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJyB8ICdlcnJvcic7XG5cbi8vIFVzZXIgJiBXb3Jrc3BhY2UgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgY3JlYXRlZEF0OiBEYXRlO1xuICAgIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3Jrc3BhY2Uge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG93bmVySWQ6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtzcGFjZU1lbWJlciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIHVzZXJJZDogc3RyaW5nO1xuICAgIHJvbGU6ICdvd25lcicgfCAnYWRtaW4nIHwgJ21lbWJlcicgfCAndmlld2VyJztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG59XG5cbi8vIENvbm5lY3Rpb24gVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBEYXRhYmFzZVR5cGU7XG4gICAgaG9zdDogc3RyaW5nO1xuICAgIHBvcnQ6IG51bWJlcjtcbiAgICBkYXRhYmFzZTogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgcmVhZE9ubHk6IGJvb2xlYW47XG4gICAgc3RhdHVzOiBEYXRhYmFzZVN0YXR1cztcbiAgICBjcmVhdGVkQnk6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25Db25maWcge1xuICAgIGlkPzogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBob3N0OiBzdHJpbmc7XG4gICAgcG9ydDogbnVtYmVyO1xuICAgIGRhdGFiYXNlOiBzdHJpbmc7XG4gICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIHNzbD86IGJvb2xlYW47XG4gICAgcmVhZE9ubHk/OiBib29sZWFuO1xuICAgIGNvbm5lY3Rpb25UaW1lb3V0PzogbnVtYmVyO1xuICAgIHF1ZXJ5VGltZW91dD86IG51bWJlcjtcbiAgICBtYXhQb29sU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uUmVzdWx0IHtcbiAgICBjb25uZWN0aW9uSWQ6IHN0cmluZztcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIHZlcnNpb24/OiBzdHJpbmc7XG4gICAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdFJlc3VsdCB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICAgIGxhdGVuY3k/OiBudW1iZXI7XG59XG5cbi8vIFF1ZXJ5IFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5UmVxdWVzdCB7XG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmc7XG4gICAgcXVlcnk6IHN0cmluZztcbiAgICB0aW1lb3V0PzogbnVtYmVyO1xuICAgIG1heFJvd3M/OiBudW1iZXI7XG4gICAgc3RyZWFtUmVzdWx0cz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlSZXN1bHQge1xuICAgIHJvd3M6IGFueVtdO1xuICAgIGZpZWxkczogUXVlcnlGaWVsZFtdO1xuICAgIHJvd0NvdW50OiBudW1iZXI7XG4gICAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICAgIGhhc01vcmU/OiBib29sZWFuO1xuICAgIGN1cnNvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUZpZWxkIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgICB0YWJsZUlEPzogbnVtYmVyO1xuICAgIGNvbHVtbklEPzogbnVtYmVyO1xuICAgIG51bGxhYmxlPzogYm9vbGVhbjtcbiAgICBpc1ByaW1hcnlLZXk/OiBib29sZWFuO1xuICAgIGlzRm9yZWlnbktleT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblJlc3VsdCB7XG4gICAgcGxhbjogYW55O1xuICAgIGV4ZWN1dGlvblRpbWU/OiBudW1iZXI7XG4gICAgdG90YWxDb3N0PzogbnVtYmVyO1xuICAgIHBsYW5UZXh0Pzogc3RyaW5nO1xufVxuXG4vLyBTY2hlbWEgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb3duZXI/OiBzdHJpbmc7XG4gICAgdGFibGVDb3VudD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZSB7XG4gICAgc2NoZW1hOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHR5cGU6ICd0YWJsZScgfCAndmlldycgfCAnbWF0ZXJpYWxpemVkX3ZpZXcnO1xuICAgIHJvd0NvdW50PzogbnVtYmVyO1xuICAgIHNpemU/OiBzdHJpbmc7XG4gICAgY29tbWVudD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU1ldGFkYXRhIHtcbiAgICBzY2hlbWE6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogQ29sdW1uW107XG4gICAgcHJpbWFyeUtleXM6IHN0cmluZ1tdO1xuICAgIGZvcmVpZ25LZXlzOiBGb3JlaWduS2V5W107XG4gICAgaW5kZXhlczogSW5kZXhbXTtcbiAgICByb3dDb3VudD86IG51bWJlcjtcbiAgICBzaXplPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGRhdGFUeXBlOiBzdHJpbmc7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIHByZWNpc2lvbj86IG51bWJlcjtcbiAgICBzY2FsZT86IG51bWJlcjtcbiAgICBudWxsYWJsZTogYm9vbGVhbjtcbiAgICBkZWZhdWx0VmFsdWU/OiBzdHJpbmc7XG4gICAgaXNQcmltYXJ5S2V5OiBib29sZWFuO1xuICAgIGlzRm9yZWlnbktleTogYm9vbGVhbjtcbiAgICBjb21tZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogc3RyaW5nW107XG4gICAgdW5pcXVlOiBib29sZWFuO1xuICAgIHByaW1hcnk6IGJvb2xlYW47XG4gICAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JlaWduS2V5IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogc3RyaW5nW107XG4gICAgcmVmZXJlbmNlZFRhYmxlOiBzdHJpbmc7XG4gICAgcmVmZXJlbmNlZENvbHVtbnM6IHN0cmluZ1tdO1xuICAgIG9uRGVsZXRlPzogc3RyaW5nO1xuICAgIG9uVXBkYXRlPzogc3RyaW5nO1xufVxuXG4vLyBTYXZlZCBRdWVyeSBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBTYXZlZFF1ZXJ5IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgY29ubmVjdGlvbklkPzogc3RyaW5nO1xuICAgIGNyZWF0ZWRCeTogc3RyaW5nO1xuICAgIGNyZWF0ZWRBdDogRGF0ZTtcbiAgICB1cGRhdGVkQXQ6IERhdGU7XG4gICAgdGFncz86IHN0cmluZ1tdO1xufVxuXG4vLyBRdWVyeSBIaXN0b3J5IFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5SGlzdG9yeSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nO1xuICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICAgIHJvd0NvdW50OiBudW1iZXI7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICBleGVjdXRlZEJ5OiBzdHJpbmc7XG4gICAgZXhlY3V0ZWRBdDogRGF0ZTtcbn1cblxuLy8gRGF0YWJhc2UgSW5mb1xuZXhwb3J0IGludGVyZmFjZSBEYXRhYmFzZUluZm8ge1xuICAgIHZlcnNpb246IHN0cmluZztcbiAgICBzZXJ2ZXJWZXJzaW9uPzogc3RyaW5nO1xuICAgIHVwdGltZT86IG51bWJlcjtcbiAgICBjdXJyZW50RGF0YWJhc2U/OiBzdHJpbmc7XG4gICAgY3VycmVudFVzZXI/OiBzdHJpbmc7XG4gICAgZW5jb2Rpbmc/OiBzdHJpbmc7XG4gICAgY29sbGF0aW9uPzogc3RyaW5nO1xufVxuXG4vLyBFcnJvciBUeXBlc1xuZXhwb3J0IGNsYXNzIEJvc0RCRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGNvZGU/OiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBkZXRhaWxzPzogYW55XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQm9zREJFcnJvcic7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQm9zREJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzPzogYW55KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdDT05ORUNUSU9OX0VSUk9SJywgZGV0YWlscyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDb25uZWN0aW9uRXJyb3InO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFF1ZXJ5RXhlY3V0aW9uRXJyb3IgZXh0ZW5kcyBCb3NEQkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM/OiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ1FVRVJZX0VYRUNVVElPTl9FUlJPUicsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUXVlcnlFeGVjdXRpb25FcnJvcic7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VjdXJpdHlFcnJvciBleHRlbmRzIEJvc0RCRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlscz86IGFueSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnU0VDVVJJVFlfRVJST1InLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NlY3VyaXR5RXJyb3InO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEJvc0RCRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlscz86IGFueSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnVkFMSURBVElPTl9FUlJPUicsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQm9zREJFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsImRldGFpbHMiLCJuYW1lIiwiQ29ubmVjdGlvbkVycm9yIiwiUXVlcnlFeGVjdXRpb25FcnJvciIsIlNlY3VyaXR5RXJyb3IiLCJWYWxpZGF0aW9uRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/types/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/AdapterFactory.ts":
/*!********************************************************!*\
  !*** ../../packages/db-adapters/src/AdapterFactory.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterFactory: () => (/* binding */ AdapterFactory)\n/* harmony export */ });\n/* harmony import */ var _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/postgresql/PostgreSQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\");\n/* harmony import */ var _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/mysql/MySQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts\");\n/* harmony import */ var _adapters_mongodb_MongoDBAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapters/mongodb/MongoDBAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts\");\n/* harmony import */ var _adapters_redis_RedisAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adapters/redis/RedisAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__]);\n_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n/**\n * Factory for creating database adapter instances\n */ class AdapterFactory {\n    /**\n     * Create a database adapter instance based on the database type\n     * @param type Database type ('postgresql', 'mysql', 'mongodb', 'redis', 'mariadb', etc.)\n     * @returns Database adapter instance\n     */ static create(type) {\n        switch(type.toLowerCase()){\n            case \"postgresql\":\n            case \"postgres\":\n                return new _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__.PostgreSQLAdapter();\n            case \"mysql\":\n                return new _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__.MySQLAdapter();\n            case \"mariadb\":\n                // MariaDB is MySQL-compatible, use MySQL adapter\n                return new _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__.MySQLAdapter();\n            case \"mongodb\":\n            case \"mongo\":\n                return new _adapters_mongodb_MongoDBAdapter__WEBPACK_IMPORTED_MODULE_2__.MongoDBAdapter();\n            case \"redis\":\n                return new _adapters_redis_RedisAdapter__WEBPACK_IMPORTED_MODULE_3__.RedisAdapter();\n            default:\n                throw new Error(`Unsupported database type: ${type}`);\n        }\n    }\n    /**\n     * Get list of supported database types\n     */ static getSupportedTypes() {\n        return [\n            \"postgresql\",\n            \"mysql\",\n            \"mariadb\",\n            \"mongodb\",\n            \"redis\"\n        ];\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL0FkYXB0ZXJGYWN0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRTRFO0FBQ2Y7QUFDTTtBQUNOO0FBRTdEOztDQUVDLEdBQ00sTUFBTUk7SUFDVDs7OztLQUlDLEdBQ0QsT0FBT0MsT0FBT0MsSUFBWSxFQUFjO1FBQ3BDLE9BQVFBLEtBQUtDLFdBQVc7WUFDcEIsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJUCxxRkFBaUJBO1lBRWhDLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJQyxzRUFBWUE7WUFFM0IsS0FBSztnQkFDRCxpREFBaUQ7Z0JBQ2pELE9BQU8sSUFBSUEsc0VBQVlBO1lBRTNCLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU8sSUFBSUMsNEVBQWNBO1lBRTdCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJQyxzRUFBWUE7WUFFM0I7Z0JBQ0ksTUFBTSxJQUFJSyxNQUFNLENBQUMsMkJBQTJCLEVBQUVGLEtBQUssQ0FBQztRQUM1RDtJQUNKO0lBRUE7O0tBRUMsR0FDRCxPQUFPRyxvQkFBb0M7UUFDdkMsT0FBTztZQUFDO1lBQWM7WUFBUztZQUFXO1lBQVc7U0FBUTtJQUNqRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvQWRhcHRlckZhY3RvcnkudHM/OGU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERhdGFiYXNlVHlwZSB9IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB0eXBlIHsgSURCQWRhcHRlciB9IGZyb20gJy4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB7IFBvc3RncmVTUUxBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9wb3N0Z3Jlc3FsL1Bvc3RncmVTUUxBZGFwdGVyJztcbmltcG9ydCB7IE15U1FMQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvbXlzcWwvTXlTUUxBZGFwdGVyJztcbmltcG9ydCB7IE1vbmdvREJBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9tb25nb2RiL01vbmdvREJBZGFwdGVyJztcbmltcG9ydCB7IFJlZGlzQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvcmVkaXMvUmVkaXNBZGFwdGVyJztcblxuLyoqXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyBkYXRhYmFzZSBhZGFwdGVyIGluc3RhbmNlc1xuICovXG5leHBvcnQgY2xhc3MgQWRhcHRlckZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRhdGFiYXNlIGFkYXB0ZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGRhdGFiYXNlIHR5cGVcbiAgICAgKiBAcGFyYW0gdHlwZSBEYXRhYmFzZSB0eXBlICgncG9zdGdyZXNxbCcsICdteXNxbCcsICdtb25nb2RiJywgJ3JlZGlzJywgJ21hcmlhZGInLCBldGMuKVxuICAgICAqIEByZXR1cm5zIERhdGFiYXNlIGFkYXB0ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHR5cGU6IHN0cmluZyk6IElEQkFkYXB0ZXIge1xuICAgICAgICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncG9zdGdyZXNxbCc6XG4gICAgICAgICAgICBjYXNlICdwb3N0Z3Jlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3JlU1FMQWRhcHRlcigpO1xuXG4gICAgICAgICAgICBjYXNlICdteXNxbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNeVNRTEFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSAnbWFyaWFkYic6XG4gICAgICAgICAgICAgICAgLy8gTWFyaWFEQiBpcyBNeVNRTC1jb21wYXRpYmxlLCB1c2UgTXlTUUwgYWRhcHRlclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXlTUUxBZGFwdGVyKCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vbmdvZGInOlxuICAgICAgICAgICAgY2FzZSAnbW9uZ28nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9uZ29EQkFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSAncmVkaXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVkaXNBZGFwdGVyKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGlzdCBvZiBzdXBwb3J0ZWQgZGF0YWJhc2UgdHlwZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3VwcG9ydGVkVHlwZXMoKTogRGF0YWJhc2VUeXBlW10ge1xuICAgICAgICByZXR1cm4gWydwb3N0Z3Jlc3FsJywgJ215c3FsJywgJ21hcmlhZGInLCAnbW9uZ29kYicsICdyZWRpcyddO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJQb3N0Z3JlU1FMQWRhcHRlciIsIk15U1FMQWRhcHRlciIsIk1vbmdvREJBZGFwdGVyIiwiUmVkaXNBZGFwdGVyIiwiQWRhcHRlckZhY3RvcnkiLCJjcmVhdGUiLCJ0eXBlIiwidG9Mb3dlckNhc2UiLCJFcnJvciIsImdldFN1cHBvcnRlZFR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/AdapterFactory.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts":
/*!*************************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MongoDBAdapter: () => (/* binding */ MongoDBAdapter)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"(rsc)/../../packages/db-adapters/node_modules/mongodb/lib/index.js\");\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"MongoDBAdapter\");\n/**\n * MongoDB Database Adapter\n * Implements IDBAdapter for MongoDB databases\n * \n * Note: MongoDB is document-oriented (NoSQL), so some SQL concepts don't apply:\n * - Schemas -> Databases\n * - Tables -> Collections\n * - Columns -> Document fields (dynamic)\n * - Query -> Aggregation pipelines or find operations\n */ class MongoDBAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"mongodb\");\n        try {\n            // Build MongoDB connection string\n            const uri = `mongodb://${config.username}:${config.password}@${config.host}:${config.port || 27017}/${config.database}?authSource=admin`;\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                connectTimeoutMS: config.connectionTimeout || 10000,\n                serverSelectionTimeoutMS: config.connectionTimeout || 10000\n            });\n            await client.connect();\n            const db = client.db(config.database);\n            // Test connection by running a simple command\n            const adminDb = client.db(\"admin\");\n            const serverInfo = await adminDb.command({\n                serverStatus: 1\n            });\n            this.clients.set(connectionId, client);\n            this.databases.set(connectionId, db);\n            logger.info(`Connected to MongoDB: ${config.host}:${config.port}/${config.database}`);\n            return {\n                connectionId,\n                success: true,\n                version: serverInfo.version\n            };\n        } catch (error) {\n            logger.error(`MongoDB connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (client) {\n            await client.close();\n            this.clients.delete(connectionId);\n            this.databases.delete(connectionId);\n            logger.info(`Disconnected from MongoDB: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const uri = `mongodb://${config.username}:${config.password}@${config.host}:${config.port || 27017}/${config.database}?authSource=admin`;\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                connectTimeoutMS: 5000,\n                serverSelectionTimeoutMS: 5000\n            });\n            await client.connect();\n            await client.db(\"admin\").command({\n                ping: 1\n            });\n            await client.close();\n            return {\n                success: true,\n                message: \"MongoDB connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`MongoDB test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const result = await adminDb.command({\n                listDatabases: 1\n            });\n            const schemas = [];\n            for (const dbInfo of result.databases){\n                if ([\n                    \"admin\",\n                    \"local\",\n                    \"config\"\n                ].includes(dbInfo.name)) {\n                    continue; // Skip system databases\n                }\n                // Get collection count for each database\n                const db = client.db(dbInfo.name);\n                const collections = await db.listCollections().toArray();\n                schemas.push({\n                    name: dbInfo.name,\n                    tableCount: collections.length\n                });\n            }\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list MongoDB databases: ${error.message}`, error);\n            throw new Error(`Failed to list databases: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const db = this.databases.get(connectionId);\n        const client = this.clients.get(connectionId);\n        if (!db || !client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        const dbName = schemaName || db.databaseName;\n        const targetDb = client.db(dbName);\n        try {\n            const collections = await targetDb.listCollections().toArray();\n            const tables = [];\n            for (const coll of collections){\n                // Get document count\n                const collection = targetDb.collection(coll.name);\n                const count = await collection.estimatedDocumentCount();\n                tables.push({\n                    schema: dbName,\n                    name: coll.name,\n                    type: coll.type === \"view\" ? \"view\" : \"table\",\n                    rowCount: count\n                });\n            }\n            return tables;\n        } catch (error) {\n            logger.error(`Failed to list MongoDB collections: ${error.message}`, error);\n            throw new Error(`Failed to list collections: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const db = client.db(schemaName);\n            const collection = db.collection(tableName);\n            // Sample documents to infer schema (MongoDB has dynamic schema)\n            const sampleDocs = await collection.find({}).limit(100).toArray();\n            // Infer fields from sample documents\n            const fieldSet = new Set();\n            for (const doc of sampleDocs){\n                Object.keys(doc).forEach((key)=>fieldSet.add(key));\n            }\n            const columns = Array.from(fieldSet).map((fieldName)=>({\n                    name: fieldName,\n                    dataType: this.inferMongoType(sampleDocs, fieldName),\n                    nullable: true,\n                    defaultValue: undefined,\n                    isPrimaryKey: fieldName === \"_id\",\n                    isForeignKey: false\n                }));\n            // Get indexes\n            const indexes = await this.getIndexes(connectionId, schemaName, tableName);\n            // Get document count\n            const rowCount = await collection.estimatedDocumentCount();\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys: [\n                    \"_id\"\n                ],\n                foreignKeys: [],\n                indexes,\n                rowCount\n            };\n        } catch (error) {\n            logger.error(`Failed to describe MongoDB collection: ${error.message}`, error);\n            throw new Error(`Failed to describe collection: ${error.message}`);\n        }\n    }\n    async getIndexes(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const db = client.db(schemaName);\n            const collection = db.collection(tableName);\n            const indexInfo = await collection.indexes();\n            return indexInfo.map((idx)=>({\n                    name: idx.name || \"unknown\",\n                    columns: Object.keys(idx.key),\n                    unique: idx.unique || false,\n                    primary: idx.name === \"_id_\",\n                    type: \"btree\"\n                }));\n        } catch (error) {\n            logger.error(`Failed to get MongoDB indexes: ${error.message}`, error);\n            throw new Error(`Failed to get indexes: ${error.message}`);\n        }\n    }\n    async executeQuery(request) {\n        const db = this.databases.get(request.connectionId);\n        if (!db) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            // Parse MongoDB query (JSON format)\n            // Supports: { \"find\": \"collection\", \"filter\": {...}, \"limit\": 10 }\n            // Or aggregation: { \"aggregate\": \"collection\", \"pipeline\": [...] }\n            const queryObj = JSON.parse(request.query);\n            let rows = [];\n            let fields = [];\n            if (queryObj.find) {\n                // Find operation\n                const collection = db.collection(queryObj.find);\n                const filter = queryObj.filter || {};\n                const options = {};\n                if (queryObj.sort) options.sort = queryObj.sort;\n                if (queryObj.limit) options.limit = queryObj.limit;\n                if (queryObj.skip) options.skip = queryObj.skip;\n                rows = await collection.find(filter, options).toArray();\n            } else if (queryObj.aggregate) {\n                // Aggregation pipeline\n                const collection = db.collection(queryObj.aggregate);\n                const pipeline = queryObj.pipeline || [];\n                rows = await collection.aggregate(pipeline).toArray();\n            } else {\n                throw new Error('Invalid query format. Use {\"find\": \"collection\", \"filter\": {...}} or {\"aggregate\": \"collection\", \"pipeline\": [...]}');\n            }\n            // Infer fields from results\n            if (rows.length > 0) {\n                const fieldNames = new Set();\n                rows.forEach((row)=>Object.keys(row).forEach((key)=>fieldNames.add(key)));\n                fields = Array.from(fieldNames).map((name)=>({\n                        name,\n                        dataType: \"mixed\"\n                    }));\n            }\n            const executionTime = Date.now() - startTime;\n            return {\n                rows: rows.slice(0, request.maxRows || 1000),\n                fields,\n                rowCount: rows.length,\n                executionTime,\n                hasMore: rows.length > (request.maxRows || 1000)\n            };\n        } catch (error) {\n            logger.error(`MongoDB query execution failed: ${error.message}`, error);\n            throw new Error(`Query execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const db = this.databases.get(connectionId);\n        if (!db) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const queryObj = JSON.parse(query);\n            if (queryObj.find) {\n                const collection = db.collection(queryObj.find);\n                const explainResult = await collection.find(queryObj.filter || {}).explain();\n                return {\n                    plan: explainResult,\n                    planText: JSON.stringify(explainResult, null, 2)\n                };\n            } else if (queryObj.aggregate) {\n                const collection = db.collection(queryObj.aggregate);\n                const explainResult = await collection.aggregate(queryObj.pipeline || [], {\n                    explain: true\n                }).toArray();\n                return {\n                    plan: explainResult,\n                    planText: JSON.stringify(explainResult, null, 2)\n                };\n            }\n            throw new Error(\"Cannot explain this query type\");\n        } catch (error) {\n            logger.error(`MongoDB EXPLAIN failed: ${error.message}`, error);\n            throw new Error(`EXPLAIN failed: ${error.message}`);\n        }\n    }\n    async getVersion(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const buildInfo = await adminDb.command({\n                buildInfo: 1\n            });\n            return buildInfo.version;\n        } catch (error) {\n            logger.error(`Failed to get MongoDB version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const client = this.clients.get(connectionId);\n        const db = this.databases.get(connectionId);\n        if (!client || !db) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const serverStatus = await adminDb.command({\n                serverStatus: 1\n            });\n            return {\n                version: serverStatus.version,\n                serverVersion: serverStatus.version,\n                uptime: serverStatus.uptime,\n                currentDatabase: db.databaseName,\n                currentUser: serverStatus.connections?.current?.toString()\n            };\n        } catch (error) {\n            logger.error(`Failed to get MongoDB database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    /**\n     * Infer MongoDB field type from sample documents\n     */ inferMongoType(docs, fieldName) {\n        const types = new Set();\n        for (const doc of docs){\n            const value = doc[fieldName];\n            if (value === null || value === undefined) continue;\n            const type = Array.isArray(value) ? \"array\" : typeof value;\n            types.add(type);\n        }\n        if (types.size === 0) return \"null\";\n        if (types.size === 1) return Array.from(types)[0];\n        return \"mixed\";\n    }\n    constructor(...args){\n        super(...args);\n        this.clients = new Map();\n        this.databases = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL21vbmdvZGIvTW9uZ29EQkFkYXB0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNRO0FBZ0J0QjtBQUV0QyxNQUFNRyxTQUFTLElBQUlELGdEQUFNQSxDQUFDO0FBRTFCOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1FLHVCQUF1QkgsaUVBQWFBO0lBSTdDLE1BQU1JLFFBQVFDLE1BQXdCLEVBQTZCO1FBQy9ELE1BQU1DLGVBQWUsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQztRQUUvQyxJQUFJO1lBQ0Esa0NBQWtDO1lBQ2xDLE1BQU1DLE1BQU0sQ0FBQyxVQUFVLEVBQUVILE9BQU9JLFFBQVEsQ0FBQyxDQUFDLEVBQUVKLE9BQU9LLFFBQVEsQ0FBQyxDQUFDLEVBQUVMLE9BQU9NLElBQUksQ0FBQyxDQUFDLEVBQUVOLE9BQU9PLElBQUksSUFBSSxNQUFNLENBQUMsRUFBRVAsT0FBT1EsUUFBUSxDQUFDLGlCQUFpQixDQUFDO1lBRXhJLE1BQU1DLFNBQVMsSUFBSWYsZ0RBQVdBLENBQUNTLEtBQUs7Z0JBQ2hDTyxrQkFBa0JWLE9BQU9XLGlCQUFpQixJQUFJO2dCQUM5Q0MsMEJBQTBCWixPQUFPVyxpQkFBaUIsSUFBSTtZQUMxRDtZQUVBLE1BQU1GLE9BQU9WLE9BQU87WUFDcEIsTUFBTWMsS0FBS0osT0FBT0ksRUFBRSxDQUFDYixPQUFPUSxRQUFRO1lBRXBDLDhDQUE4QztZQUM5QyxNQUFNTSxVQUFVTCxPQUFPSSxFQUFFLENBQUM7WUFDMUIsTUFBTUUsYUFBYSxNQUFNRCxRQUFRRSxPQUFPLENBQUM7Z0JBQUVDLGNBQWM7WUFBRTtZQUUzRCxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDbEIsY0FBY1E7WUFDL0IsSUFBSSxDQUFDVyxTQUFTLENBQUNELEdBQUcsQ0FBQ2xCLGNBQWNZO1lBRWpDaEIsT0FBT3dCLElBQUksQ0FBQyxDQUFDLHNCQUFzQixFQUFFckIs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QU8yQixLQUFLLENBQUMsQ0FBQyxxQ0FBcUMsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENBQUMsRUFBRUQ7WUFDdEUsTUFBTSxJQUFJYSxNQUFNLENBQUMsNkJBQTZCLEVBQUViLE1BQU1DLE9BQU8sQ0FBQyxDQUFDO1FBQ25FO0lBQ0o7SUFFQTs7S0FFQyxHQUNELGVBQXVCMkcsSUFBZ0IsRUFBRXBELFNBQWlCLEVBQVU7UUFDaEUsTUFBTXFELFFBQVEsSUFBSWhFO1FBRWxCLEtBQUssTUFBTUMsT0FBTzhELEtBQU07WUFDcEIsTUFBTUUsUUFBUWhFLEdBQUcsQ0FBQ1UsVUFBVTtZQUM1QixJQUFJc0QsVUFBVSxRQUFRQSxVQUFVakQsV0FBVztZQUUzQyxNQUFNeEIsT0FBT2dCLE1BQU0wRCxPQUFPLENBQUNELFNBQVMsVUFBVSxPQUFPQTtZQUNyREQsTUFBTTFELEdBQUcsQ0FBQ2Q7UUFDZDtRQUVBLElBQUl3RSxNQUFNRyxJQUFJLEtBQUssR0FBRyxPQUFPO1FBQzdCLElBQUlILE1BQU1HLElBQUksS0FBSyxHQUFHLE9BQU8zRCxNQUFNQyxJQUFJLENBQUN1RCxNQUFNLENBQUMsRUFBRTtRQUNqRCxPQUFPO0lBQ1g7OzthQW5YUW5ILFVBQW9DLElBQUl1SDthQUN4Q3JILFlBQTZCLElBQUlxSDs7QUFtWDdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvYWRhcHRlcnMvbW9uZ29kYi9Nb25nb0RCQWRhcHRlci50cz9kMzZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vbmdvQ2xpZW50LCBEYiwgRG9jdW1lbnQgfSBmcm9tICdtb25nb2RiJztcbmltcG9ydCB7IEJhc2VEQkFkYXB0ZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuaW1wb3J0IHR5cGUge1xuICAgIENvbm5lY3Rpb25Db25maWcsXG4gICAgQ29ubmVjdGlvblJlc3VsdCxcbiAgICBUZXN0UmVzdWx0LFxuICAgIFF1ZXJ5UmVxdWVzdCxcbiAgICBRdWVyeVJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBDb2x1bW4sXG4gICAgSW5kZXgsXG5cbiAgICBEYXRhYmFzZUluZm8sXG4gICAgRXhwbGFpblJlc3VsdCxcbn0gZnJvbSAnQGJvc2RiL2NvcmUnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGJvc2RiL3V0aWxzJztcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignTW9uZ29EQkFkYXB0ZXInKTtcblxuLyoqXG4gKiBNb25nb0RCIERhdGFiYXNlIEFkYXB0ZXJcbiAqIEltcGxlbWVudHMgSURCQWRhcHRlciBmb3IgTW9uZ29EQiBkYXRhYmFzZXNcbiAqIFxuICogTm90ZTogTW9uZ29EQiBpcyBkb2N1bWVudC1vcmllbnRlZCAoTm9TUUwpLCBzbyBzb21lIFNRTCBjb25jZXB0cyBkb24ndCBhcHBseTpcbiAqIC0gU2NoZW1hcyAtPiBEYXRhYmFzZXNcbiAqIC0gVGFibGVzIC0+IENvbGxlY3Rpb25zXG4gKiAtIENvbHVtbnMgLT4gRG9jdW1lbnQgZmllbGRzIChkeW5hbWljKVxuICogLSBRdWVyeSAtPiBBZ2dyZWdhdGlvbiBwaXBlbGluZXMgb3IgZmluZCBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25nb0RCQWRhcHRlciBleHRlbmRzIEJhc2VEQkFkYXB0ZXIge1xuICAgIHByaXZhdGUgY2xpZW50czogTWFwPHN0cmluZywgTW9uZ29DbGllbnQ+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgZGF0YWJhc2VzOiBNYXA8c3RyaW5nLCBEYj4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdtb25nb2RiJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJ1aWxkIE1vbmdvREIgY29ubmVjdGlvbiBzdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IGBtb25nb2RiOi8vJHtjb25maWcudXNlcm5hbWV9OiR7Y29uZmlnLnBhc3N3b3JkfUAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0IHx8IDI3MDE3fS8ke2NvbmZpZy5kYXRhYmFzZX0/YXV0aFNvdXJjZT1hZG1pbmA7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBNb25nb0NsaWVudCh1cmksIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dE1TOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgMTAwMDAsXG4gICAgICAgICAgICAgICAgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgMTAwMDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKGNvbmZpZy5kYXRhYmFzZSk7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgY29ubmVjdGlvbiBieSBydW5uaW5nIGEgc2ltcGxlIGNvbW1hbmRcbiAgICAgICAgICAgIGNvbnN0IGFkbWluRGIgPSBjbGllbnQuZGIoJ2FkbWluJyk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgYWRtaW5EYi5jb21tYW5kKHsgc2VydmVyU3RhdHVzOiAxIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNsaWVudHMuc2V0KGNvbm5lY3Rpb25JZCwgY2xpZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2VzLnNldChjb25uZWN0aW9uSWQsIGRiKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYENvbm5lY3RlZCB0byBNb25nb0RCOiAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0fS8ke2NvbmZpZy5kYXRhYmFzZX1gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzZXJ2ZXJJbmZvLnZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE1vbmdvREIgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogJycsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhYmFzZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgRGlzY29ubmVjdGVkIGZyb20gTW9uZ29EQjogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IGBtb25nb2RiOi8vJHtjb25maWcudXNlcm5hbWV9OiR7Y29uZmlnLnBhc3N3b3JkfUAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0IHx8IDI3MDE3fS8ke2NvbmZpZy5kYXRhYmFzZX0/YXV0aFNvdXJjZT1hZG1pbmA7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBNb25nb0NsaWVudCh1cmksIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dE1TOiA1MDAwLFxuICAgICAgICAgICAgICAgIHNlcnZlclNlbGVjdGlvblRpbWVvdXRNUzogNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRiKCdhZG1pbicpLmNvbW1hbmQoeyBwaW5nOiAxIH0pO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsb3NlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTW9uZ29EQiBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE1vbmdvREIgdGVzdCBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRtaW5EYiA9IGNsaWVudC5kYignYWRtaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkbWluRGIuY29tbWFuZCh7IGxpc3REYXRhYmFzZXM6IDEgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYXM6IFNjaGVtYVtdID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRiSW5mbyBvZiByZXN1bHQuZGF0YWJhc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsnYWRtaW4nLCAnbG9jYWwnLCAnY29uZmlnJ10uaW5jbHVkZXMoZGJJbmZvLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHN5c3RlbSBkYXRhYmFzZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGVjdGlvbiBjb3VudCBmb3IgZWFjaCBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKGRiSW5mby5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9ucyA9IGF3YWl0IGRiLmxpc3RDb2xsZWN0aW9ucygpLnRvQXJyYXkoKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNvdW50OiBjb2xsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBsaXN0IE1vbmdvREIgZGF0YWJhc2VzOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBkYXRhYmFzZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxpc3RUYWJsZXMoY29ubmVjdGlvbklkOiBzdHJpbmcsIHNjaGVtYU5hbWU/OiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlW10+IHtcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmRhdGFiYXNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiIHx8ICFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYk5hbWUgPSBzY2hlbWFOYW1lIHx8IGRiLmRhdGFiYXNlTmFtZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGIgPSBjbGllbnQuZGIoZGJOYW1lKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbnMgPSBhd2FpdCB0YXJnZXREYi5saXN0Q29sbGVjdGlvbnMoKS50b0FycmF5KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhYmxlczogVGFibGVbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsIG9mIGNvbGxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50IGNvdW50XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRhcmdldERiLmNvbGxlY3Rpb24oY29sbC5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGF3YWl0IGNvbGxlY3Rpb24uZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgdGFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGRiTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb2xsLnR5cGUgPT09ICd2aWV3JyA/ICd2aWV3JyA6ICd0YWJsZScsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBNb25nb0RCIGNvbGxlY3Rpb25zOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBjb2xsZWN0aW9uczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVzY3JpYmVUYWJsZShjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZTogc3RyaW5nLCB0YWJsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKHNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24odGFibGVOYW1lKTtcblxuICAgICAgICAgICAgLy8gU2FtcGxlIGRvY3VtZW50cyB0byBpbmZlciBzY2hlbWEgKE1vbmdvREIgaGFzIGR5bmFtaWMgc2NoZW1hKVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRG9jcyA9IGF3YWl0IGNvbGxlY3Rpb24uZmluZCh7fSkubGltaXQoMTAwKS50b0FycmF5KCk7XG5cbiAgICAgICAgICAgIC8vIEluZmVyIGZpZWxkcyBmcm9tIHNhbXBsZSBkb2N1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBzYW1wbGVEb2NzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZG9jKS5mb3JFYWNoKGtleSA9PiBmaWVsZFNldC5hZGQoa2V5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gQXJyYXkuZnJvbShmaWVsZFNldCkubWFwKGZpZWxkTmFtZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5pbmZlck1vbmdvVHlwZShzYW1wbGVEb2NzLCBmaWVsZE5hbWUpLFxuICAgICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLCAvLyBNb25nb0RCIGZpZWxkcyBhcmUgYWx3YXlzIG9wdGlvbmFsIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IGZpZWxkTmFtZSA9PT0gJ19pZCcsXG4gICAgICAgICAgICAgICAgaXNGb3JlaWduS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gR2V0IGluZGV4ZXNcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZXMgPSBhd2FpdCB0aGlzLmdldEluZGV4ZXMoY29ubmVjdGlvbklkLCBzY2hlbWFOYW1lLCB0YWJsZU5hbWUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgY291bnRcbiAgICAgICAgICAgIGNvbnN0IHJvd0NvdW50ID0gYXdhaXQgY29sbGVjdGlvbi5lc3RpbWF0ZWREb2N1bWVudENvdW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlzOiBbJ19pZCddLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25LZXlzOiBbXSwgLy8gTW9uZ29EQiBkb2Vzbid0IGhhdmUgZW5mb3JjZWQgZm9yZWlnbiBrZXlzXG4gICAgICAgICAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgICAgICAgICByb3dDb3VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGRlc2NyaWJlIE1vbmdvREIgY29sbGVjdGlvbjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlc2NyaWJlIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEluZGV4ZXMoY29ubmVjdGlvbklkOiBzdHJpbmcsIHNjaGVtYU5hbWU6IHN0cmluZywgdGFibGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IGNsaWVudC5kYihzY2hlbWFOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBkYi5jb2xsZWN0aW9uKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluZm8gPSBhd2FpdCBjb2xsZWN0aW9uLmluZGV4ZXMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4SW5mby5tYXAoaWR4ID0+ICh7XG4gICAgICAgICAgICAgICAgbmFtZTogaWR4Lm5hbWUgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IE9iamVjdC5rZXlzKGlkeC5rZXkpLFxuICAgICAgICAgICAgICAgIHVuaXF1ZTogaWR4LnVuaXF1ZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiBpZHgubmFtZSA9PT0gJ19pZF8nLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdidHJlZScsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIGluZGV4ZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgaW5kZXhlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmRhdGFiYXNlcy5nZXQocmVxdWVzdC5jb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtyZXF1ZXN0LmNvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBNb25nb0RCIHF1ZXJ5IChKU09OIGZvcm1hdClcbiAgICAgICAgICAgIC8vIFN1cHBvcnRzOiB7IFwiZmluZFwiOiBcImNvbGxlY3Rpb25cIiwgXCJmaWx0ZXJcIjogey4uLn0sIFwibGltaXRcIjogMTAgfVxuICAgICAgICAgICAgLy8gT3IgYWdncmVnYXRpb246IHsgXCJhZ2dyZWdhdGVcIjogXCJjb2xsZWN0aW9uXCIsIFwicGlwZWxpbmVcIjogWy4uLl0gfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlPYmogPSBKU09OLnBhcnNlKHJlcXVlc3QucXVlcnkpO1xuXG4gICAgICAgICAgICBsZXQgcm93czogYW55W10gPSBbXTtcbiAgICAgICAgICAgIGxldCBmaWVsZHM6IGFueVtdID0gW107XG5cbiAgICAgICAgICAgIGlmIChxdWVyeU9iai5maW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gZGIuY29sbGVjdGlvbihxdWVyeU9iai5maW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBxdWVyeU9iai5maWx0ZXIgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogYW55ID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmouc29ydCkgb3B0aW9ucy5zb3J0ID0gcXVlcnlPYmouc29ydDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmoubGltaXQpIG9wdGlvbnMubGltaXQgPSBxdWVyeU9iai5saW1pdDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmouc2tpcCkgb3B0aW9ucy5za2lwID0gcXVlcnlPYmouc2tpcDtcblxuICAgICAgICAgICAgICAgIHJvd3MgPSBhd2FpdCBjb2xsZWN0aW9uLmZpbmQoZmlsdGVyLCBvcHRpb25zKS50b0FycmF5KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5T2JqLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEFnZ3JlZ2F0aW9uIHBpcGVsaW5lXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouYWdncmVnYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXBlbGluZSA9IHF1ZXJ5T2JqLnBpcGVsaW5lIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJvd3MgPSBhd2FpdCBjb2xsZWN0aW9uLmFnZ3JlZ2F0ZShwaXBlbGluZSkudG9BcnJheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcXVlcnkgZm9ybWF0LiBVc2Uge1wiZmluZFwiOiBcImNvbGxlY3Rpb25cIiwgXCJmaWx0ZXJcIjogey4uLn19IG9yIHtcImFnZ3JlZ2F0ZVwiOiBcImNvbGxlY3Rpb25cIiwgXCJwaXBlbGluZVwiOiBbLi4uXX0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5mZXIgZmllbGRzIGZyb20gcmVzdWx0c1xuICAgICAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgICAgICByb3dzLmZvckVhY2gocm93ID0+IE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChrZXkgPT4gZmllbGROYW1lcy5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgICAgIGZpZWxkcyA9IEFycmF5LmZyb20oZmllbGROYW1lcykubWFwKG5hbWUgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdtaXhlZCcsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzOiByb3dzLnNsaWNlKDAsIHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICAgICAgaGFzTW9yZTogcm93cy5sZW5ndGggPiAocmVxdWVzdC5tYXhSb3dzIHx8IDEwMDApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBNb25nb0RCIHF1ZXJ5IGV4ZWN1dGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXJ5IGV4ZWN1dGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGV4cGxhaW5RdWVyeShjb25uZWN0aW9uSWQ6IHN0cmluZywgcXVlcnk6IHN0cmluZyk6IFByb21pc2U8RXhwbGFpblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGF0YWJhc2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5T2JqID0gSlNPTi5wYXJzZShxdWVyeSk7XG5cbiAgICAgICAgICAgIGlmIChxdWVyeU9iai5maW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouZmluZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwbGFpblJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb24uZmluZChxdWVyeU9iai5maWx0ZXIgfHwge30pLmV4cGxhaW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwbGFuOiBleHBsYWluUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBwbGFuVGV4dDogSlNPTi5zdHJpbmdpZnkoZXhwbGFpblJlc3VsdCwgbnVsbCwgMiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnlPYmouYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouYWdncmVnYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBsYWluUmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbi5hZ2dyZWdhdGUocXVlcnlPYmoucGlwZWxpbmUgfHwgW10sIHsgZXhwbGFpbjogdHJ1ZSB9KS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhbjogZXhwbGFpblJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcGxhblRleHQ6IEpTT04uc3RyaW5naWZ5KGV4cGxhaW5SZXN1bHQsIG51bGwsIDIpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4cGxhaW4gdGhpcyBxdWVyeSB0eXBlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTW9uZ29EQiBFWFBMQUlOIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRVhQTEFJTiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkbWluRGIgPSBjbGllbnQuZGIoJ2FkbWluJyk7XG4gICAgICAgICAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCBhZG1pbkRiLmNvbW1hbmQoeyBidWlsZEluZm86IDEgfSk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRJbmZvLnZlcnNpb247XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdmVyc2lvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGF0YWJhc2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCB8fCAhZGIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRtaW5EYiA9IGNsaWVudC5kYignYWRtaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN0YXR1cyA9IGF3YWl0IGFkbWluRGIuY29tbWFuZCh7IHNlcnZlclN0YXR1czogMSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzZXJ2ZXJTdGF0dXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJWZXJzaW9uOiBzZXJ2ZXJTdGF0dXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICB1cHRpbWU6IHNlcnZlclN0YXR1cy51cHRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFiYXNlOiBkYi5kYXRhYmFzZU5hbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXI6IHNlcnZlclN0YXR1cy5jb25uZWN0aW9ucz8uY3VycmVudD8udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mZXIgTW9uZ29EQiBmaWVsZCB0eXBlIGZyb20gc2FtcGxlIGRvY3VtZW50c1xuICAgICAqL1xuICAgIHByaXZhdGUgaW5mZXJNb25nb1R5cGUoZG9jczogRG9jdW1lbnRbXSwgZmllbGROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdhcnJheScgOiB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICB0eXBlcy5hZGQodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZXMuc2l6ZSA9PT0gMCkgcmV0dXJuICdudWxsJztcbiAgICAgICAgaWYgKHR5cGVzLnNpemUgPT09IDEpIHJldHVybiBBcnJheS5mcm9tKHR5cGVzKVswXTtcbiAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk1vbmdvQ2xpZW50IiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIk1vbmdvREJBZGFwdGVyIiwiY29ubmVjdCIsImNvbmZpZyIsImNvbm5lY3Rpb25JZCIsImdlbmVyYXRlQ29ubmVjdGlvbklkIiwidXJpIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImhvc3QiLCJwb3J0IiwiZGF0YWJhc2UiLCJjbGllbnQiLCJjb25uZWN0VGltZW91dE1TIiwiY29ubmVjdGlvblRpbWVvdXQiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJkYiIsImFkbWluRGIiLCJzZXJ2ZXJJbmZvIiwiY29tbWFuZCIsInNlcnZlclN0YXR1cyIsImNsaWVudHMiLCJzZXQiLCJkYXRhYmFzZXMiLCJpbmZvIiwic3VjY2VzcyIsInZlcnNpb24iLCJlcnJvciIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0IiwiZ2V0IiwiY2xvc2UiLCJkZWxldGUiLCJ0ZXN0Q29ubmVjdGlvbiIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJwaW5nIiwibGF0ZW5jeSIsImxpc3RTY2hlbWFzIiwiRXJyb3IiLCJyZXN1bHQiLCJsaXN0RGF0YWJhc2VzIiwic2NoZW1hcyIsImRiSW5mbyIsImluY2x1ZGVzIiwibmFtZSIsImNvbGxlY3Rpb25zIiwibGlzdENvbGxlY3Rpb25zIiwidG9BcnJheSIsInB1c2giLCJ0YWJsZUNvdW50IiwibGVuZ3RoIiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJkYk5hbWUiLCJkYXRhYmFzZU5hbWUiLCJ0YXJnZXREYiIsInRhYmxlcyIsImNvbGwiLCJjb2xsZWN0aW9uIiwiY291bnQiLCJlc3RpbWF0ZWREb2N1bWVudENvdW50Iiwic2NoZW1hIiwidHlwZSIsInJvd0NvdW50IiwiZGVzY3JpYmVUYWJsZSIsInRhYmxlTmFtZSIsInNhbXBsZURvY3MiLCJmaW5kIiwibGltaXQiLCJmaWVsZFNldCIsIlNldCIsImRvYyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiYWRkIiwiY29sdW1ucyIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImZpZWxkTmFtZSIsImRhdGFUeXBlIiwiaW5mZXJNb25nb1R5cGUiLCJudWxsYWJsZSIsImRlZmF1bHRWYWx1ZSIsInVuZGVmaW5lZCIsImlzUHJpbWFyeUtleSIsImlzRm9yZWlnbktleSIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwicHJpbWFyeUtleXMiLCJmb3JlaWduS2V5cyIsImluZGV4SW5mbyIsImlkeCIsInVuaXF1ZSIsInByaW1hcnkiLCJleGVjdXRlUXVlcnkiLCJyZXF1ZXN0IiwicXVlcnlPYmoiLCJKU09OIiwicGFyc2UiLCJxdWVyeSIsInJvd3MiLCJmaWVsZHMiLCJmaWx0ZXIiLCJvcHRpb25zIiwic29ydCIsInNraXAiLCJhZ2dyZWdhdGUiLCJwaXBlbGluZSIsImZpZWxkTmFtZXMiLCJyb3ciLCJleGVjdXRpb25UaW1lIiwic2xpY2UiLCJtYXhSb3dzIiwiaGFzTW9yZSIsImV4cGxhaW5RdWVyeSIsImV4cGxhaW5SZXN1bHQiLCJleHBsYWluIiwicGxhbiIsInBsYW5UZXh0Iiwic3RyaW5naWZ5IiwiZ2V0VmVyc2lvbiIsImJ1aWxkSW5mbyIsImdldERhdGFiYXNlSW5mbyIsInNlcnZlclZlcnNpb24iLCJ1cHRpbWUiLCJjdXJyZW50RGF0YWJhc2UiLCJjdXJyZW50VXNlciIsImNvbm5lY3Rpb25zIiwiY3VycmVudCIsInRvU3RyaW5nIiwiZG9jcyIsInR5cGVzIiwidmFsdWUiLCJpc0FycmF5Iiwic2l6ZSIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts":
/*!*********************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MySQLAdapter: () => (/* binding */ MySQLAdapter)\n/* harmony export */ });\n/* harmony import */ var mysql2_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mysql2/promise */ \"mysql2/promise\");\n/* harmony import */ var mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mysql2_promise__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"MySQLAdapter\");\n/**\n * MySQL Database Adapter\n * Implements IDBAdapter for MySQL databases using mysql2\n */ class MySQLAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"mysql\");\n        try {\n            const pool = mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default().createPool({\n                host: config.host,\n                port: config.port || 3306,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : undefined,\n                connectionLimit: config.maxPoolSize || 10,\n                waitForConnections: true,\n                queueLimit: 0,\n                enableKeepAlive: true,\n                keepAliveInitialDelay: 0\n            });\n            // Test connection\n            const connection = await pool.getConnection();\n            const [versionRows] = await connection.query(\"SELECT VERSION() as version\");\n            const version = versionRows[0].version;\n            connection.release();\n            this.pools.set(connectionId, pool);\n            logger.info(`Connected to MySQL: ${config.host}:${config.port}/${config.database}`);\n            return {\n                connectionId,\n                success: true,\n                version\n            };\n        } catch (error) {\n            logger.error(`MySQL connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (pool) {\n            await pool.end();\n            this.pools.delete(connectionId);\n            logger.info(`Disconnected from MySQL: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const connection = await mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default().createConnection({\n                host: config.host,\n                port: config.port || 3306,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : undefined\n            });\n            await connection.ping();\n            await connection.end();\n            return {\n                success: true,\n                message: \"MySQL connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`MySQL test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    SCHEMA_NAME as name,\n                    DEFAULT_CHARACTER_SET_NAME as charset\n                FROM information_schema.SCHEMATA\n                WHERE SCHEMA_NAME NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')\n                ORDER BY SCHEMA_NAME\n            `);\n            const schemas = [];\n            for (const row of rows){\n                // Get table count for schema\n                const [countRows] = await pool.query(`SELECT COUNT(*) as count FROM information_schema.TABLES WHERE TABLE_SCHEMA = ?`, [\n                    row.name\n                ]);\n                schemas.push({\n                    name: row.name,\n                    tableCount: countRows[0].count\n                });\n            }\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list MySQL schemas: ${error.message}`, error);\n            throw new Error(`Failed to list schemas: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        const schema = schemaName || \"public\";\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    TABLE_SCHEMA as schema_name,\n                    TABLE_NAME as name,\n                    TABLE_TYPE as table_type,\n                    TABLE_ROWS as row_count\n                FROM information_schema.TABLES\n                WHERE TABLE_SCHEMA = ?\n                ORDER BY TABLE_NAME\n            `, [\n                schema\n            ]);\n            return rows.map((row)=>({\n                    schema: row.schema_name,\n                    name: row.name,\n                    type: row.table_type === \"BASE TABLE\" ? \"table\" : \"view\",\n                    rowCount: row.row_count\n                }));\n        } catch (error) {\n            logger.error(`Failed to list MySQL tables: ${error.message}`, error);\n            throw new Error(`Failed to list tables: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Get columns\n            const [columnRows] = await pool.query(`\n                SELECT \n                    COLUMN_NAME as name,\n                    DATA_TYPE as data_type,\n                    IS_NULLABLE as is_nullable,\n                    COLUMN_DEFAULT as default_value,\n                    CHARACTER_MAXIMUM_LENGTH as max_length,\n                    NUMERIC_PRECISION as precision,\n                    NUMERIC_SCALE as scale,\n                    COLUMN_KEY as column_key\n                FROM information_schema.COLUMNS\n                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?\n                ORDER BY ORDINAL_POSITION\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const columns = columnRows.map((row)=>({\n                    name: row.name,\n                    dataType: row.data_type,\n                    maxLength: row.max_length,\n                    precision: row.precision,\n                    scale: row.scale,\n                    nullable: row.is_nullable === \"YES\",\n                    defaultValue: row.default_value,\n                    isPrimaryKey: row.column_key === \"PRI\",\n                    isForeignKey: row.column_key === \"MUL\"\n                }));\n            // Get primary keys\n            const primaryKeys = columns.filter((c)=>c.isPrimaryKey).map((c)=>c.name);\n            // Get foreign keys\n            const [fkRows] = await pool.query(`\n                SELECT \n                    CONSTRAINT_NAME as name,\n                    COLUMN_NAME as column_name,\n                    REFERENCED_TABLE_NAME as ref_table,\n                    REFERENCED_COLUMN_NAME as ref_column\n                FROM information_schema.KEY_COLUMN_USAGE\n                WHERE TABLE_SCHEMA = ? \n                    AND TABLE_NAME = ? \n                    AND REFERENCED_TABLE_NAME IS NOT NULL\n                ORDER BY CONSTRAINT_NAME, ORDINAL_POSITION\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const foreignKeysMap = new Map();\n            for (const row of fkRows){\n                if (!foreignKeysMap.has(row.name)) {\n                    foreignKeysMap.set(row.name, {\n                        name: row.name,\n                        columns: [\n                            row.column_name\n                        ],\n                        referencedTable: row.ref_table,\n                        referencedColumns: [\n                            row.ref_column\n                        ]\n                    });\n                } else {\n                    const fk = foreignKeysMap.get(row.name);\n                    fk.columns.push(row.column_name);\n                    fk.referencedColumns.push(row.ref_column);\n                }\n            }\n            // Get indexes\n            const indexes = await this.getIndexes(connectionId, schemaName, tableName);\n            // Get row count\n            const [countRows] = await pool.query(`SELECT TABLE_ROWS as row_count FROM information_schema.TABLES WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?`, [\n                schemaName,\n                tableName\n            ]);\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys,\n                foreignKeys: Array.from(foreignKeysMap.values()),\n                indexes,\n                rowCount: countRows[0]?.row_count\n            };\n        } catch (error) {\n            logger.error(`Failed to describe MySQL table: ${error.message}`, error);\n            throw new Error(`Failed to describe table: ${error.message}`);\n        }\n    }\n    async getIndexes(connectionId, schemaName, tableName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    INDEX_NAME as name,\n                    COLUMN_NAME as column_name,\n                    NOT NON_UNIQUE as is_unique,\n                    INDEX_TYPE as type\n                FROM information_schema.STATISTICS\n                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?\n                ORDER BY INDEX_NAME, SEQ_IN_INDEX\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const indexMap = new Map();\n            for (const row of rows){\n                if (!indexMap.has(row.name)) {\n                    indexMap.set(row.name, {\n                        name: row.name,\n                        columns: [\n                            row.column_name\n                        ],\n                        unique: row.is_unique === 1,\n                        primary: row.name === \"PRIMARY\",\n                        type: row.type\n                    });\n                } else {\n                    indexMap.get(row.name).columns.push(row.column_name);\n                }\n            }\n            return Array.from(indexMap.values());\n        } catch (error) {\n            logger.error(`Failed to get MySQL indexes: ${error.message}`, error);\n            throw new Error(`Failed to get indexes: ${error.message}`);\n        }\n    }\n    async executeQuery(request) {\n        const pool = this.pools.get(request.connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            const [rows, fields] = await pool.query(request.query);\n            const queryFields = Array.isArray(fields) ? fields.map((field)=>({\n                    name: field.name,\n                    dataType: this.mapMySQLType(field.type)\n                })) : [];\n            const resultRows = Array.isArray(rows) ? rows : [];\n            const executionTime = Date.now() - startTime;\n            return {\n                rows: resultRows.slice(0, request.maxRows || 1000),\n                fields: queryFields,\n                rowCount: resultRows.length,\n                executionTime,\n                hasMore: resultRows.length > (request.maxRows || 1000)\n            };\n        } catch (error) {\n            logger.error(`MySQL query execution failed: ${error.message}`, error);\n            throw new Error(`Query execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`EXPLAIN ${query}`);\n            return {\n                plan: rows,\n                planText: JSON.stringify(rows, null, 2)\n            };\n        } catch (error) {\n            logger.error(`MySQL EXPLAIN failed: ${error.message}`, error);\n            throw new Error(`EXPLAIN failed: ${error.message}`);\n        }\n    }\n    async getVersion(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(\"SELECT VERSION() as version\");\n            return rows[0].version;\n        } catch (error) {\n            logger.error(`Failed to get MySQL version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [versionRows] = await pool.query(\"SELECT VERSION() as version\");\n            const [userRows] = await pool.query(\"SELECT USER() as user\");\n            const [dbRows] = await pool.query(\"SELECT DATABASE() as db\");\n            return {\n                version: versionRows[0].version,\n                serverVersion: versionRows[0].version,\n                currentUser: userRows[0].user,\n                currentDatabase: dbRows[0].db\n            };\n        } catch (error) {\n            logger.error(`Failed to get MySQL database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    mapMySQLType(type) {\n        // MySQL field type constants\n        const types = {\n            0: \"DECIMAL\",\n            1: \"TINY\",\n            2: \"SHORT\",\n            3: \"LONG\",\n            4: \"FLOAT\",\n            5: \"DOUBLE\",\n            6: \"NULL\",\n            7: \"TIMESTAMP\",\n            8: \"LONGLONG\",\n            9: \"INT24\",\n            10: \"DATE\",\n            11: \"TIME\",\n            12: \"DATETIME\",\n            13: \"YEAR\",\n            15: \"VARCHAR\",\n            16: \"BIT\",\n            245: \"JSON\",\n            246: \"NEWDECIMAL\",\n            247: \"ENUM\",\n            248: \"SET\",\n            249: \"TINY_BLOB\",\n            250: \"MEDIUM_BLOB\",\n            251: \"LONG_BLOB\",\n            252: \"BLOB\",\n            253: \"VAR_STRING\",\n            254: \"STRING\",\n            255: \"GEOMETRY\"\n        };\n        return types[type] || \"UNKNOWN\";\n    }\n    constructor(...args){\n        super(...args);\n        this.pools = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL215c3FsL015U1FMQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQztBQUN5QjtBQWdCdEI7QUFFdEMsTUFBTUcsU0FBUyxJQUFJRCxnREFBTUEsQ0FBQztBQUUxQjs7O0NBR0MsR0FDTSxNQUFNRSxxQkFBcUJILGlFQUFhQTtJQUczQyxNQUFNSSxRQUFRQyxNQUF3QixFQUE2QjtRQUMvRCxNQUFNQyxlQUFlLElBQUksQ0FBQ0Msb0JBQW9CLENBQUM7UUFFL0MsSUFBSTtZQUNBLE1BQU1DLE9BQU9ULGdFQUFnQixDQUFDO2dCQUMxQlcsTUFBTUwsT0FBT0ssSUFBSTtnQkFDakJDLE1BQU1OLE9BQU9NLElBQUksSUFBSTtnQkFDckJDLFVBQVVQLE9BQU9PLFFBQVE7Z0JBQ3pCQyxNQUFNUixPQUFPUyxRQUFRO2dCQUNyQkMsVUFBVVYsT0FBT1UsUUFBUTtnQkFDekJDLEtBQUtYLE9BQU9XLEdBQUcsR0FBRztvQkFBRUMsb0JBQW9CO2dCQUFNLElBQUlDO2dCQUNsREMsaUJBQWlCZCxPQUFPZSxXQUFXLElBQUk7Z0JBQ3ZDQyxvQkFBb0I7Z0JBQ3BCQyxZQUFZO2dCQUNaQyxpQkFBaUI7Z0JBQ2pCQyx1QkFBdUI7WUFDM0I7WUFFQSxrQkFBa0I7WUFDbEIsTUFBTUMsYUFBYSxNQUFNakIsS0FBS2tCLGFBQWE7WUFDM0MsTUFBTSxDQUFDQyxZQUFZLEdBQUcsTUFBTUYsV0FBV0csS0FBSyxDQUF3QjtZQUNwRSxNQUFNQyxVQUFVRixXQUFXLENBQUMsRUFBRSxDQUFDRSxPQUFPO1lBQ3RDSixXQUFXSyxPQUFPO1lBRWxCLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUMxQixjQUFjRTtZQUU3Qk4sT0FBTytCLElBQUksQ0FBQyxDQUFDLG9CQUFvQixFQUFFNUIsT0FBT0ssSUFBSSxDQUFDLENBQUMsRUFBRUwsT0FBT00sSUFBSSxDQUFDLENBQUMsRUFBRU4sT0FB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S29CLEtBQUssQ0FBd0I7WUFFekQsT0FBTztnQkFDSEMsU0FBU0YsV0FBVyxDQUFDLEVBQUUsQ0FBQ0UsT0FBTztnQkFDL0JvRyxlQUFldEcsV0FBVyxDQUFDLEVBQUUsQ0FBQ0UsT0FBTztnQkFDckNxRyxhQUFhSCxRQUFRLENBQUMsRUFBRSxDQUFDbEgsSUFBSTtnQkFDN0JzSCxpQkFBaUJILE1BQU0sQ0FBQyxFQUFFLENBQUNJLEVBQUU7WUFDakM7UUFDSixFQUFFLE9BQU9qRyxPQUFZO1lBQ2pCakMsT0FBT2lDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFQSxNQUFNQyxPQUFPLENBQUMsQ0FBQyxFQUFFRDtZQUNwRSxNQUFNLElBQUljLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRWQsTUFBTUMsT0FBTyxDQUFDLENBQUM7UUFDbkU7SUFDSjtJQUVRNkUsYUFBYWxELElBQVksRUFBVTtRQUN2Qyw2QkFBNkI7UUFDN0IsTUFBTXNFLFFBQW1DO1lBQ3JDLEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztRQUNUO1FBRUEsT0FBT0EsS0FBSyxDQUFDdEUsS0FBSyxJQUFJO0lBQzFCOzs7YUFwYVFoQyxRQUFpQyxJQUFJMEQ7O0FBcWFqRCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL215c3FsL015U1FMQWRhcHRlci50cz8zMTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBteXNxbCBmcm9tICdteXNxbDIvcHJvbWlzZSc7XG5pbXBvcnQgeyBCYXNlREJBZGFwdGVyIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgU2NoZW1hLFxuICAgIFRhYmxlLFxuICAgIFRhYmxlTWV0YWRhdGEsXG4gICAgQ29sdW1uLFxuICAgIEluZGV4LFxuICAgIEZvcmVpZ25LZXksXG4gICAgRGF0YWJhc2VJbmZvLFxuICAgIEV4cGxhaW5SZXN1bHQsXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0Bib3NkYi91dGlscyc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ015U1FMQWRhcHRlcicpO1xuXG4vKipcbiAqIE15U1FMIERhdGFiYXNlIEFkYXB0ZXJcbiAqIEltcGxlbWVudHMgSURCQWRhcHRlciBmb3IgTXlTUUwgZGF0YWJhc2VzIHVzaW5nIG15c3FsMlxuICovXG5leHBvcnQgY2xhc3MgTXlTUUxBZGFwdGVyIGV4dGVuZHMgQmFzZURCQWRhcHRlciB7XG4gICAgcHJpdmF0ZSBwb29sczogTWFwPHN0cmluZywgbXlzcWwuUG9vbD4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdteXNxbCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gbXlzcWwuY3JlYXRlUG9vbCh7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgMzMwNixcbiAgICAgICAgICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICAgICAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHNzbDogY29uZmlnLnNzbCA/IHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25MaW1pdDogY29uZmlnLm1heFBvb2xTaXplIHx8IDEwLFxuICAgICAgICAgICAgICAgIHdhaXRGb3JDb25uZWN0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUxpbWl0OiAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZUtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVJbml0aWFsRGVsYXk6IDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVGVzdCBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgcG9vbC5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBbdmVyc2lvblJvd3NdID0gYXdhaXQgY29ubmVjdGlvbi5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KCdTRUxFQ1QgVkVSU0lPTigpIGFzIHZlcnNpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uUm93c1swXS52ZXJzaW9uO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5yZWxlYXNlKCk7XG5cbiAgICAgICAgICAgIHRoaXMucG9vbHMuc2V0KGNvbm5lY3Rpb25JZCwgcG9vbCk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBDb25uZWN0ZWQgdG8gTXlTUUw6ICR7Y29uZmlnLmhvc3R9OiR7Y29uZmlnLnBvcnR9LyR7Y29uZmlnLmRhdGFiYXNlfWApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE15U1FMIGNvbm5lY3Rpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6ICcnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmIChwb29sKSB7XG4gICAgICAgICAgICBhd2FpdCBwb29sLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5wb29scy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBEaXNjb25uZWN0ZWQgZnJvbSBNeVNRTDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBteXNxbC5jcmVhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiBjb25maWcucG9ydCB8fCAzMzA2LFxuICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc3NsOiBjb25maWcuc3NsID8geyByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5waW5nKCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ015U1FMIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgdGVzdCBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KGBcbiAgICAgICAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICAgICAgICAgIFNDSEVNQV9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQ0hBUkFDVEVSX1NFVF9OQU1FIGFzIGNoYXJzZXRcbiAgICAgICAgICAgICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5TQ0hFTUFUQVxuICAgICAgICAgICAgICAgIFdIRVJFIFNDSEVNQV9OQU1FIE5PVCBJTiAoJ2luZm9ybWF0aW9uX3NjaGVtYScsICdwZXJmb3JtYW5jZV9zY2hlbWEnLCAnbXlzcWwnLCAnc3lzJylcbiAgICAgICAgICAgICAgICBPUkRFUiBCWSBTQ0hFTUFfTkFNRVxuICAgICAgICAgICAgYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYXM6IFNjaGVtYVtdID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRhYmxlIGNvdW50IGZvciBzY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBbY291bnRSb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICAgICAgYFNFTEVDVCBDT1VOVCgqKSBhcyBjb3VudCBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5UQUJMRVMgV0hFUkUgVEFCTEVfU0NIRU1BID0gP2AsXG4gICAgICAgICAgICAgICAgICAgIFtyb3cubmFtZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ291bnQ6IGNvdW50Um93c1swXS5jb3VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGxpc3QgTXlTUUwgc2NoZW1hczogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2NoZW1hczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZT86IHN0cmluZyk6IFByb21pc2U8VGFibGVbXT4ge1xuICAgICAgICBjb25zdCBwb29sID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hTmFtZSB8fCAncHVibGljJztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICAgICAgICAgIFRBQkxFX1NDSEVNQSBhcyBzY2hlbWFfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgVEFCTEVfTkFNRSBhcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBUQUJMRV9UWVBFIGFzIHRhYmxlX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIFRBQkxFX1JPV1MgYXMgcm93X2NvdW50XG4gICAgICAgICAgICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVTXG4gICAgICAgICAgICAgICAgV0hFUkUgVEFCTEVfU0NIRU1BID0gP1xuICAgICAgICAgICAgICAgIE9SREVSIEJZIFRBQkxFX05BTUVcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICAgICAgW3NjaGVtYV1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiByb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogcm93LnNjaGVtYV9uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHJvdy50YWJsZV90eXBlID09PSAnQkFTRSBUQUJMRScgPyAndGFibGUnIDogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByb3cucm93X2NvdW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBsaXN0IE15U1FMIHRhYmxlczogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgdGFibGVzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZXNjcmliZVRhYmxlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWFOYW1lOiBzdHJpbmcsIHRhYmxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGNvbHVtbnNcbiAgICAgICAgICAgIGNvbnN0IFtjb2x1bW5Sb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgICAgICAgICBDT0xVTU5fTkFNRSBhcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBEQVRBX1RZUEUgYXMgZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgICAgICBJU19OVUxMQUJMRSBhcyBpc19udWxsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgQ09MVU1OX0RFRkFVTFQgYXMgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIIGFzIG1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIE5VTUVSSUNfUFJFQ0lTSU9OIGFzIHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgTlVNRVJJQ19TQ0FMRSBhcyBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgQ09MVU1OX0tFWSBhcyBjb2x1bW5fa2V5XG4gICAgICAgICAgICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuQ09MVU1OU1xuICAgICAgICAgICAgICAgIFdIRVJFIFRBQkxFX1NDSEVNQSA9ID8gQU5EIFRBQkxFX05BTUUgPSA/XG4gICAgICAgICAgICAgICAgT1JERVIgQlkgT1JESU5BTF9QT1NJVElPTlxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBjb2x1bW5Sb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiByb3cuZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aDogcm93Lm1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiByb3cucHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiByb3cuc2NhbGUsXG4gICAgICAgICAgICAgICAgbnVsbGFibGU6IHJvdy5pc19udWxsYWJsZSA9PT0gJ1lFUycsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiByb3cuZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHJvdy5jb2x1bW5fa2V5ID09PSAnUFJJJyxcbiAgICAgICAgICAgICAgICBpc0ZvcmVpZ25LZXk6IHJvdy5jb2x1bW5fa2V5ID09PSAnTVVMJyxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gR2V0IHByaW1hcnkga2V5c1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBjb2x1bW5zLmZpbHRlcigoYykgPT4gYy5pc1ByaW1hcnlLZXkpLm1hcCgoYykgPT4gYy5uYW1lKTtcblxuICAgICAgICAgICAgLy8gR2V0IGZvcmVpZ24ga2V5c1xuICAgICAgICAgICAgY29uc3QgW2ZrUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIFNFTEVDVCBcbiAgICAgICAgICAgICAgICAgICAgQ09OU1RSQUlOVF9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIENPTFVNTl9OQU1FIGFzIGNvbHVtbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgYXMgcmVmX3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICBSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIGFzIHJlZl9jb2x1bW5cbiAgICAgICAgICAgICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5LRVlfQ09MVU1OX1VTQUdFXG4gICAgICAgICAgICAgICAgV0hFUkUgVEFCTEVfU0NIRU1BID0gPyBcbiAgICAgICAgICAgICAgICAgICAgQU5EIFRBQkxFX05BTUUgPSA/IFxuICAgICAgICAgICAgICAgICAgICBBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXG4gICAgICAgICAgICAgICAgT1JERVIgQlkgQ09OU1RSQUlOVF9OQU1FLCBPUkRJTkFMX1BPU0lUSU9OXG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgICAgIFtzY2hlbWFOYW1lLCB0YWJsZU5hbWVdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBmb3JlaWduS2V5c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBGb3JlaWduS2V5PigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgZmtSb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JlaWduS2V5c01hcC5oYXMocm93Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXlzTWFwLnNldChyb3cubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbcm93LmNvbHVtbl9uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRUYWJsZTogcm93LnJlZl90YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRDb2x1bW5zOiBbcm93LnJlZl9jb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmayA9IGZvcmVpZ25LZXlzTWFwLmdldChyb3cubmFtZSkhO1xuICAgICAgICAgICAgICAgICAgICBmay5jb2x1bW5zLnB1c2gocm93LmNvbHVtbl9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmsucmVmZXJlbmNlZENvbHVtbnMucHVzaChyb3cucmVmX2NvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgaW5kZXhlc1xuICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQsIHNjaGVtYU5hbWUsIHRhYmxlTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIEdldCByb3cgY291bnRcbiAgICAgICAgICAgIGNvbnN0IFtjb3VudFJvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KFxuICAgICAgICAgICAgICAgIGBTRUxFQ1QgVEFCTEVfUk9XUyBhcyByb3dfY291bnQgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVTIFdIRVJFIFRBQkxFX1NDSEVNQSA9ID8gQU5EIFRBQkxFX05BTUUgPSA/YCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleXMsXG4gICAgICAgICAgICAgICAgZm9yZWlnbktleXM6IEFycmF5LmZyb20oZm9yZWlnbktleXNNYXAudmFsdWVzKCkpLFxuICAgICAgICAgICAgICAgIGluZGV4ZXMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IGNvdW50Um93c1swXT8ucm93X2NvdW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVzY3JpYmUgTXlTUUwgdGFibGU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSB0YWJsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZTogc3RyaW5nLCB0YWJsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8SW5kZXhbXT4ge1xuICAgICAgICBjb25zdCBwb29sID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgICAgICAgICBJTkRFWF9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIENPTFVNTl9OQU1FIGFzIGNvbHVtbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBOT1QgTk9OX1VOSVFVRSBhcyBpc191bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgIElOREVYX1RZUEUgYXMgdHlwZVxuICAgICAgICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLlNUQVRJU1RJQ1NcbiAgICAgICAgICAgICAgICBXSEVSRSBUQUJMRV9TQ0hFTUEgPSA/IEFORCBUQUJMRV9OQU1FID0gP1xuICAgICAgICAgICAgICAgIE9SREVSIEJZIElOREVYX05BTUUsIFNFUV9JTl9JTkRFWFxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBuZXcgTWFwPHN0cmluZywgSW5kZXg+KCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4TWFwLmhhcyhyb3cubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXAuc2V0KHJvdy5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtyb3cuY29sdW1uX25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiByb3cuaXNfdW5pcXVlID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTogcm93Lm5hbWUgPT09ICdQUklNQVJZJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJvdy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcC5nZXQocm93Lm5hbWUpIS5jb2x1bW5zLnB1c2gocm93LmNvbHVtbl9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGluZGV4TWFwLnZhbHVlcygpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIGluZGV4ZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgaW5kZXhlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KHJlcXVlc3QuY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtyZXF1ZXN0LmNvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbcm93cywgZmllbGRzXSA9IGF3YWl0IHBvb2wucXVlcnkocmVxdWVzdC5xdWVyeSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5RmllbGRzID0gQXJyYXkuaXNBcnJheShmaWVsZHMpXG4gICAgICAgICAgICAgICAgPyBmaWVsZHMubWFwKChmaWVsZDogYW55KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5tYXBNeVNRTFR5cGUoZmllbGQudHlwZSksXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgOiBbXTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Um93cyA9IEFycmF5LmlzQXJyYXkocm93cykgPyByb3dzIDogW107XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzOiByZXN1bHRSb3dzLnNsaWNlKDAsIHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHF1ZXJ5RmllbGRzLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByZXN1bHRSb3dzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIGhhc01vcmU6IHJlc3VsdFJvd3MubGVuZ3RoID4gKHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgcXVlcnkgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVlcnkgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhwbGFpblF1ZXJ5KGNvbm5lY3Rpb25JZDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxFeHBsYWluUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeShgRVhQTEFJTiAke3F1ZXJ5fWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbGFuOiByb3dzLFxuICAgICAgICAgICAgICAgIHBsYW5UZXh0OiBKU09OLnN0cmluZ2lmeShyb3dzLCBudWxsLCAyKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgRVhQTEFJTiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVYUExBSU4gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRWZXJzaW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbcm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBWRVJTSU9OKCkgYXMgdmVyc2lvbicpO1xuICAgICAgICAgICAgcmV0dXJuIHJvd3NbMF0udmVyc2lvbjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdmVyc2lvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbdmVyc2lvblJvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KCdTRUxFQ1QgVkVSU0lPTigpIGFzIHZlcnNpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IFt1c2VyUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBVU0VSKCkgYXMgdXNlcicpO1xuICAgICAgICAgICAgY29uc3QgW2RiUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBEQVRBQkFTRSgpIGFzIGRiJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblJvd3NbMF0udmVyc2lvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJWZXJzaW9uOiB2ZXJzaW9uUm93c1swXS52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyOiB1c2VyUm93c1swXS51c2VyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhYmFzZTogZGJSb3dzWzBdLmRiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXBNeVNRTFR5cGUodHlwZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgLy8gTXlTUUwgZmllbGQgdHlwZSBjb25zdGFudHNcbiAgICAgICAgY29uc3QgdHlwZXM6IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAwOiAnREVDSU1BTCcsXG4gICAgICAgICAgICAxOiAnVElOWScsXG4gICAgICAgICAgICAyOiAnU0hPUlQnLFxuICAgICAgICAgICAgMzogJ0xPTkcnLFxuICAgICAgICAgICAgNDogJ0ZMT0FUJyxcbiAgICAgICAgICAgIDU6ICdET1VCTEUnLFxuICAgICAgICAgICAgNjogJ05VTEwnLFxuICAgICAgICAgICAgNzogJ1RJTUVTVEFNUCcsXG4gICAgICAgICAgICA4OiAnTE9OR0xPTkcnLFxuICAgICAgICAgICAgOTogJ0lOVDI0JyxcbiAgICAgICAgICAgIDEwOiAnREFURScsXG4gICAgICAgICAgICAxMTogJ1RJTUUnLFxuICAgICAgICAgICAgMTI6ICdEQVRFVElNRScsXG4gICAgICAgICAgICAxMzogJ1lFQVInLFxuICAgICAgICAgICAgMTU6ICdWQVJDSEFSJyxcbiAgICAgICAgICAgIDE2OiAnQklUJyxcbiAgICAgICAgICAgIDI0NTogJ0pTT04nLFxuICAgICAgICAgICAgMjQ2OiAnTkVXREVDSU1BTCcsXG4gICAgICAgICAgICAyNDc6ICdFTlVNJyxcbiAgICAgICAgICAgIDI0ODogJ1NFVCcsXG4gICAgICAgICAgICAyNDk6ICdUSU5ZX0JMT0InLFxuICAgICAgICAgICAgMjUwOiAnTUVESVVNX0JMT0InLFxuICAgICAgICAgICAgMjUxOiAnTE9OR19CTE9CJyxcbiAgICAgICAgICAgIDI1MjogJ0JMT0InLFxuICAgICAgICAgICAgMjUzOiAnVkFSX1NUUklORycsXG4gICAgICAgICAgICAyNTQ6ICdTVFJJTkcnLFxuICAgICAgICAgICAgMjU1OiAnR0VPTUVUUlknLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0eXBlc1t0eXBlXSB8fCAnVU5LTk9XTic7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIm15c3FsIiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIk15U1FMQWRhcHRlciIsImNvbm5lY3QiLCJjb25maWciLCJjb25uZWN0aW9uSWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInBvb2wiLCJjcmVhdGVQb29sIiwiaG9zdCIsInBvcnQiLCJkYXRhYmFzZSIsInVzZXIiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic3NsIiwicmVqZWN0VW5hdXRob3JpemVkIiwidW5kZWZpbmVkIiwiY29ubmVjdGlvbkxpbWl0IiwibWF4UG9vbFNpemUiLCJ3YWl0Rm9yQ29ubmVjdGlvbnMiLCJxdWV1ZUxpbWl0IiwiZW5hYmxlS2VlcEFsaXZlIiwia2VlcEFsaXZlSW5pdGlhbERlbGF5IiwiY29ubmVjdGlvbiIsImdldENvbm5lY3Rpb24iLCJ2ZXJzaW9uUm93cyIsInF1ZXJ5IiwidmVyc2lvbiIsInJlbGVhc2UiLCJwb29scyIsInNldCIsImluZm8iLCJzdWNjZXNzIiwiZXJyb3IiLCJtZXNzYWdlIiwiZGlzY29ubmVjdCIsImdldCIsImVuZCIsImRlbGV0ZSIsInRlc3RDb25uZWN0aW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJwaW5nIiwibGF0ZW5jeSIsImxpc3RTY2hlbWFzIiwiRXJyb3IiLCJyb3dzIiwic2NoZW1hcyIsInJvdyIsImNvdW50Um93cyIsIm5hbWUiLCJwdXNoIiwidGFibGVDb3VudCIsImNvdW50IiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJzY2hlbWEiLCJtYXAiLCJzY2hlbWFfbmFtZSIsInR5cGUiLCJ0YWJsZV90eXBlIiwicm93Q291bnQiLCJyb3dfY291bnQiLCJkZXNjcmliZVRhYmxlIiwidGFibGVOYW1lIiwiY29sdW1uUm93cyIsImNvbHVtbnMiLCJkYXRhVHlwZSIsImRhdGFfdHlwZSIsIm1heExlbmd0aCIsIm1heF9sZW5ndGgiLCJwcmVjaXNpb24iLCJzY2FsZSIsIm51bGxhYmxlIiwiaXNfbnVsbGFibGUiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0X3ZhbHVlIiwiaXNQcmltYXJ5S2V5IiwiY29sdW1uX2tleSIsImlzRm9yZWlnbktleSIsInByaW1hcnlLZXlzIiwiZmlsdGVyIiwiYyIsImZrUm93cyIsImZvcmVpZ25LZXlzTWFwIiwiTWFwIiwiaGFzIiwiY29sdW1uX25hbWUiLCJyZWZlcmVuY2VkVGFibGUiLCJyZWZfdGFibGUiLCJyZWZlcmVuY2VkQ29sdW1ucyIsInJlZl9jb2x1bW4iLCJmayIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwiZm9yZWlnbktleXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJpbmRleE1hcCIsInVuaXF1ZSIsImlzX3VuaXF1ZSIsInByaW1hcnkiLCJleGVjdXRlUXVlcnkiLCJyZXF1ZXN0IiwiZmllbGRzIiwicXVlcnlGaWVsZHMiLCJpc0FycmF5IiwiZmllbGQiLCJtYXBNeVNRTFR5cGUiLCJyZXN1bHRSb3dzIiwiZXhlY3V0aW9uVGltZSIsInNsaWNlIiwibWF4Um93cyIsImxlbmd0aCIsImhhc01vcmUiLCJleHBsYWluUXVlcnkiLCJwbGFuIiwicGxhblRleHQiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0VmVyc2lvbiIsImdldERhdGFiYXNlSW5mbyIsInVzZXJSb3dzIiwiZGJSb3dzIiwic2VydmVyVmVyc2lvbiIsImN1cnJlbnRVc2VyIiwiY3VycmVudERhdGFiYXNlIiwiZGIiLCJ0eXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts":
/*!*******************************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgreSQLAdapter: () => (/* binding */ PostgreSQLAdapter)\n/* harmony export */ });\n/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ \"pg\");\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/core */ \"(rsc)/../../packages/core/src/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([pg__WEBPACK_IMPORTED_MODULE_0__]);\npg__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n/**\n * PostgreSQL database adapter\n * Implements full PostgreSQL support with connection pooling and security\n */ class PostgreSQLAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = config.id || this.generateConnectionId(\"pg\");\n        try {\n            const poolConfig = {\n                host: config.host,\n                port: config.port,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : false,\n                max: config.maxPoolSize || 10,\n                idleTimeoutMillis: 30000,\n                connectionTimeoutMillis: config.connectionTimeout || 5000,\n                allowExitOnIdle: false\n            };\n            const pool = new pg__WEBPACK_IMPORTED_MODULE_0__.Pool(poolConfig);\n            // Test the connection\n            const client = await pool.connect();\n            try {\n                const result = await client.query(\"SELECT version() as version\");\n                const version = result.rows[0]?.version || \"Unknown\";\n                // Store pool info\n                this.pools.set(connectionId, {\n                    pool,\n                    config,\n                    createdAt: new Date(),\n                    lastUsed: new Date()\n                });\n                return {\n                    connectionId,\n                    success: true,\n                    version\n                };\n            } finally{\n                client.release();\n            }\n        } catch (error) {\n            throw new Error(`Failed to connect to PostgreSQL: ${error.message}`);\n        }\n    }\n    async disconnect(connectionId) {\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        await poolInfo.pool.end();\n        this.pools.delete(connectionId);\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const pool = new pg__WEBPACK_IMPORTED_MODULE_0__.Pool({\n                host: config.host,\n                port: config.port,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : false,\n                max: 1,\n                connectionTimeoutMillis: config.connectionTimeout || 5000\n            });\n            const client = await pool.connect();\n            await client.query(\"SELECT 1\");\n            client.release();\n            await pool.end();\n            const latency = Date.now() - startTime;\n            return {\n                success: true,\n                message: \"Connection successful\",\n                latency\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message,\n                latency: Date.now() - startTime\n            };\n        }\n    }\n    async executeQuery(request) {\n        const poolInfo = this.pools.get(request.connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${request.connectionId}`);\n        }\n        poolInfo.lastUsed = new Date();\n        const startTime = Date.now();\n        let client = null;\n        try {\n            client = await poolInfo.pool.connect();\n            // Set query timeout\n            const timeout = request.timeout || _bosdb_core__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_QUERY_TIMEOUT;\n            await client.query(`SET statement_timeout = ${timeout}`);\n            // Execute query\n            const result = await client.query(request.query);\n            const executionTime = Date.now() - startTime;\n            // Apply row limit (handle queries that don't return rows)\n            const maxRows = request.maxRows || _bosdb_core__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_MAX_ROWS;\n            const rows = result.rows ? result.rows.slice(0, maxRows) : [];\n            const hasMore = result.rows ? result.rows.length > maxRows : false;\n            // Map fields (handle queries that don't return fields)\n            const fields = result.fields ? result.fields.map((field)=>({\n                    name: field.name,\n                    dataType: this.mapDataType(field.dataTypeID),\n                    tableID: field.tableID,\n                    columnID: field.columnID\n                })) : [];\n            return {\n                rows,\n                fields,\n                rowCount: result.rowCount || 0,\n                executionTime,\n                hasMore\n            };\n        } catch (error) {\n            throw new Error(`Query execution failed: ${error.message}`);\n        } finally{\n            if (client) {\n                client.release();\n            }\n        }\n    }\n    async listSchemas(connectionId) {\n        const query = `\n      SELECT \n        schema_name as name,\n        schema_owner as owner,\n        (SELECT COUNT(*) FROM information_schema.tables \n         WHERE table_schema = s.schema_name) as table_count\n      FROM information_schema.schemata s\n      WHERE schema_name NOT IN ('pg_catalog', 'information_schema', 'pg_toast')\n      ORDER BY schema_name;\n    `;\n        const result = await this.executeQuery({\n            connectionId,\n            query,\n            maxRows: 1000\n        });\n        return result.rows.map((row)=>({\n                name: row.name,\n                owner: row.owner,\n                tableCount: parseInt(row.table_count) || 0\n            }));\n    }\n    async listTables(connectionId, schema = \"public\") {\n        const query = `\n      SELECT \n        table_schema as schema,\n        table_name as name,\n        table_type as type,\n        (SELECT reltuples::bigint \n         FROM pg_class \n         WHERE oid = (quote_ident(table_schema) || '.' || quote_ident(table_name))::regclass\n        ) as row_count,\n        pg_size_pretty(pg_total_relation_size(\n          (quote_ident(table_schema) || '.' || quote_ident(table_name))::regclass\n        )) as size\n      FROM information_schema.tables\n      WHERE table_schema = $1\n      ORDER BY table_name;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema\n            ]);\n            return result.rows.map((row)=>({\n                    schema: row.schema,\n                    name: row.name,\n                    type: row.type === \"BASE TABLE\" ? \"table\" : \"view\",\n                    rowCount: row.row_count,\n                    size: row.size\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async describeTable(connectionId, schema, table) {\n        const columns = await this.getColumns(connectionId, schema, table);\n        const indexes = await this.getIndexes(connectionId, schema, table);\n        const foreignKeys = await this.getForeignKeys(connectionId, schema, table);\n        // Get primary keys\n        const primaryKeys = columns.filter((col)=>col.isPrimaryKey).map((col)=>col.name);\n        return {\n            schema,\n            name: table,\n            columns,\n            primaryKeys,\n            foreignKeys,\n            indexes\n        };\n    }\n    async getIndexes(connectionId, schema, table) {\n        const query = `\n      SELECT\n        i.relname as name,\n        array_agg(a.attname ORDER BY a.attnum) as columns,\n        ix.indisunique as unique,\n        ix.indisprimary as primary,\n        am.amname as type\n      FROM pg_class t\n      JOIN pg_namespace n ON n.oid = t.relnamespace\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_am am ON i.relam = am.oid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE n.nspname = $1 AND t.relname = $2\n      GROUP BY i.relname, ix.indisunique, ix.indisprimary, am.amname\n      ORDER BY i.relname;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    columns: row.columns,\n                    unique: row.unique,\n                    primary: row.primary,\n                    type: row.type\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const explainQuery = `EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ${query}`;\n        const result = await this.executeQuery({\n            connectionId,\n            query: explainQuery,\n            maxRows: 1\n        });\n        const plan = result.rows[0]?.[\"QUERY PLAN\"];\n        return {\n            plan,\n            executionTime: plan?.[0]?.[\"Execution Time\"],\n            totalCost: plan?.[0]?.[\"Plan\"]?.[\"Total Cost\"],\n            planText: JSON.stringify(plan, null, 2)\n        };\n    }\n    async getVersion(connectionId) {\n        const result = await this.executeQuery({\n            connectionId,\n            query: \"SELECT version() as version\",\n            maxRows: 1\n        });\n        return result.rows[0]?.version || \"Unknown\";\n    }\n    async getDatabaseInfo(connectionId) {\n        const query = `\n      SELECT\n        version() as version,\n        current_database() as current_database,\n        current_user as current_user,\n        pg_encoding_to_char(encoding) as encoding\n      FROM pg_database\n      WHERE datname = current_database();\n    `;\n        const result = await this.executeQuery({\n            connectionId,\n            query,\n            maxRows: 1\n        });\n        const row = result.rows[0];\n        return {\n            version: row?.version || \"Unknown\",\n            currentDatabase: row?.current_database,\n            currentUser: row?.current_user,\n            encoding: row?.encoding\n        };\n    }\n    // Helper methods\n    async getColumns(connectionId, schema, table) {\n        const query = `\n      SELECT\n        c.column_name as name,\n        c.data_type as data_type,\n        c.character_maximum_length as max_length,\n        c.numeric_precision as precision,\n        c.numeric_scale as scale,\n        c.is_nullable = 'YES' as nullable,\n        c.column_default as default_value,\n        EXISTS(\n          SELECT 1 FROM information_schema.key_column_usage kcu\n          JOIN information_schema.table_constraints tc\n            ON kcu.constraint_name = tc.constraint_name\n          WHERE kcu.table_schema = c.table_schema\n            AND kcu.table_name = c.table_name\n            AND kcu.column_name = c.column_name\n            AND tc.constraint_type = 'PRIMARY KEY'\n        ) as is_primary_key,\n        EXISTS(\n          SELECT 1 FROM information_schema.key_column_usage kcu\n          JOIN information_schema.table_constraints tc\n            ON kcu.constraint_name = tc.constraint_name\n          WHERE kcu.table_schema = c.table_schema\n            AND kcu.table_name = c.table_name\n            AND kcu.column_name = c.column_name\n            AND tc.constraint_type = 'FOREIGN KEY'\n        ) as is_foreign_key,\n        pgd.description as comment\n      FROM information_schema.columns c\n      LEFT JOIN pg_catalog.pg_statio_all_tables st\n        ON c.table_schema = st.schemaname AND c.table_name = st.relname\n      LEFT JOIN pg_catalog.pg_description pgd\n        ON pgd.objoid = st.relid AND pgd.objsubid = c.ordinal_position\n      WHERE c.table_schema = $1 AND c.table_name = $2\n      ORDER BY c.ordinal_position;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    dataType: row.data_type,\n                    maxLength: row.max_length,\n                    precision: row.precision,\n                    scale: row.scale,\n                    nullable: row.nullable,\n                    defaultValue: row.default_value,\n                    isPrimaryKey: row.is_primary_key,\n                    isForeignKey: row.is_foreign_key,\n                    comment: row.comment\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async getForeignKeys(connectionId, schema, table) {\n        const query = `\n      SELECT\n        tc.constraint_name as name,\n        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns,\n        ccu.table_name as referenced_table,\n        array_agg(ccu.column_name ORDER BY kcu.ordinal_position) as referenced_columns,\n        rc.update_rule as on_update,\n        rc.delete_rule as on_delete\n      FROM information_schema.table_constraints tc\n      JOIN information_schema.key_column_usage kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      JOIN information_schema.referential_constraints rc\n        ON tc.constraint_name = rc.constraint_name\n        AND tc.table_schema = rc.constraint_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n        AND tc.table_schema = $1\n        AND tc.table_name = $2\n      GROUP BY tc.constraint_name, ccu.table_name, rc.update_rule, rc.delete_rule;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    columns: row.columns,\n                    referencedTable: row.referenced_table,\n                    referencedColumns: row.referenced_columns,\n                    onUpdate: row.on_update,\n                    onDelete: row.on_delete\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    mapDataType(oid) {\n        // PostgreSQL type OID mapping\n        const typeMap = {\n            16: \"boolean\",\n            17: \"bytea\",\n            20: \"bigint\",\n            21: \"smallint\",\n            23: \"integer\",\n            25: \"text\",\n            114: \"json\",\n            142: \"xml\",\n            700: \"real\",\n            701: \"double precision\",\n            1043: \"varchar\",\n            1082: \"date\",\n            1083: \"time\",\n            1114: \"timestamp\",\n            1184: \"timestamptz\",\n            1186: \"interval\",\n            1700: \"numeric\",\n            2950: \"uuid\",\n            3802: \"jsonb\"\n        };\n        return typeMap[oid] || \"unknown\";\n    }\n    constructor(...args){\n        super(...args);\n        this.pools = new Map();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL3Bvc3RncmVzcWwvUG9zdGdyZVNRTEFkYXB0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQW1CVTtBQUNVO0FBU3RFOzs7Q0FHQyxHQUNNLE1BQU1JLDBCQUEwQkgsaUVBQWFBO0lBR2hELE1BQU1JLFFBQVFDLE1BQXdCLEVBQTZCO1FBQy9ELE1BQU1DLGVBQWVELE9BQU9FLEVBQUUsSUFBSSxJQUFJLENBQUNDLG9CQUFvQixDQUFDO1FBRTVELElBQUk7WUFDQSxNQUFNQyxhQUF5QjtnQkFDM0JDLE1BQU1MLE9BQU9LLElBQUk7Z0JBQ2pCQyxNQUFNTixPQUFPTSxJQUFJO2dCQUNqQkMsVUFBVVAsT0FBT08sUUFBUTtnQkFDekJDLE1BQU1SLE9BQU9TLFFBQVE7Z0JBQ3JCQyxVQUFVVixPQUFPVSxRQUFRO2dCQUN6QkMsS0FBS1gsT0FBT1csR0FBRyxHQUFHO29CQUFFQyxvQkFBb0I7Z0JBQU0sSUFBSTtnQkFDbERDLEtBQUtiLE9BQU9jLFdBQVcsSUFBSTtnQkFDM0JDLG1CQUFtQjtnQkFDbkJDLHlCQUF5QmhCLE9BQU9pQixpQkFBaUIsSUFBSTtnQkFDckRDLGlCQUFpQjtZQUNyQjtZQUVBLE1BQU1DLE9BQU8sSUFBSXpCLG9DQUFJQSxDQUFDVTtZQUV0QixzQkFBc0I7WUFDdEIsTUFBTWdCLFNBQVMsTUFBTUQsS0FBS3BCLE9BQU87WUFDakMsSUFBSTtnQkFDQSxNQUFNc0IsU0FBUyxNQUFNRCxPQUFPRSxLQUFLLENBQUM7Z0JBQ2xDLE1BQU1DLFVBQVVGLE9BQU9HLElBQUksQ0FBQyxFQUFFLEVBQUVELFdBQVc7Z0JBRTNDLGtCQUFrQjtnQkFDbEIsSUFBSSxDQUFDRSxLQUFLLENBQUNDLEdBQUcsQ0FBQ3pCLGNBQWM7b0JBQ3pCa0I7b0JBQ0FuQjtvQkFDQTJCLFdBQVcsSUFBSUM7b0JBQ2ZDLFVBQVUsSUFBSUQ7Z0JBQ2xCO2dCQUVBLE9BQU87b0JBQ0gz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QUNKLFNBQVU7WUFDTm5HLE9BQU9XLE9BQU87UUFDbEI7SUFDSjtJQUVRMEIsWUFBWStELEdBQVcsRUFBVTtRQUNyQyw4QkFBOEI7UUFDOUIsTUFBTUMsVUFBa0M7WUFDcEMsSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtRQUNWO1FBRUEsT0FBT0EsT0FBTyxDQUFDRCxJQUFJLElBQUk7SUFDM0I7OzthQXhkUS9GLFFBQXlDLElBQUlpRzs7QUF5ZHpEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvYWRhcHRlcnMvcG9zdGdyZXNxbC9Qb3N0Z3JlU1FMQWRhcHRlci50cz80NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvb2wsIFBvb2xDbGllbnQsIFBvb2xDb25maWcgfSBmcm9tICdwZyc7XG5pbXBvcnQgdHlwZSB7XG4gICAgQ29ubmVjdGlvbkNvbmZpZyxcbiAgICBDb25uZWN0aW9uUmVzdWx0LFxuICAgIFRlc3RSZXN1bHQsXG4gICAgUXVlcnlSZXF1ZXN0LFxuICAgIFF1ZXJ5UmVzdWx0LFxuICAgIFF1ZXJ5RmllbGQsXG4gICAgRXhwbGFpblJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBDb2x1bW4sXG4gICAgSW5kZXgsXG4gICAgRm9yZWlnbktleSxcbiAgICBEYXRhYmFzZUluZm8sXG4gICAgQ29ubmVjdGlvbkVycm9yLFxuICAgIFF1ZXJ5RXhlY3V0aW9uRXJyb3IsXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB7IEJhc2VEQkFkYXB0ZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9USU1FT1VULCBERUZBVUxUX01BWF9ST1dTIH0gZnJvbSAnQGJvc2RiL2NvcmUnO1xuXG5pbnRlcmZhY2UgQ29ubmVjdGlvblBvb2xJbmZvIHtcbiAgICBwb29sOiBQb29sO1xuICAgIGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgbGFzdFVzZWQ6IERhdGU7XG59XG5cbi8qKlxuICogUG9zdGdyZVNRTCBkYXRhYmFzZSBhZGFwdGVyXG4gKiBJbXBsZW1lbnRzIGZ1bGwgUG9zdGdyZVNRTCBzdXBwb3J0IHdpdGggY29ubmVjdGlvbiBwb29saW5nIGFuZCBzZWN1cml0eVxuICovXG5leHBvcnQgY2xhc3MgUG9zdGdyZVNRTEFkYXB0ZXIgZXh0ZW5kcyBCYXNlREJBZGFwdGVyIHtcbiAgICBwcml2YXRlIHBvb2xzOiBNYXA8c3RyaW5nLCBDb25uZWN0aW9uUG9vbEluZm8+ID0gbmV3IE1hcCgpO1xuXG4gICAgYXN5bmMgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gY29uZmlnLmlkIHx8IHRoaXMuZ2VuZXJhdGVDb25uZWN0aW9uSWQoJ3BnJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2xDb25maWc6IFBvb2xDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICAgICAgICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBzc2w6IGNvbmZpZy5zc2wgPyB7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1heDogY29uZmlnLm1heFBvb2xTaXplIHx8IDEwLFxuICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiAzMDAwMCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dE1pbGxpczogY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0IHx8IDUwMDAsXG4gICAgICAgICAgICAgICAgYWxsb3dFeGl0T25JZGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBuZXcgUG9vbChwb29sQ29uZmlnKTtcblxuICAgICAgICAgICAgLy8gVGVzdCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcG9vbC5jb25uZWN0KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeSgnU0VMRUNUIHZlcnNpb24oKSBhcyB2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHJlc3VsdC5yb3dzWzBdPy52ZXJzaW9uIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHBvb2wgaW5mb1xuICAgICAgICAgICAgICAgIHRoaXMucG9vbHMuc2V0KGNvbm5lY3Rpb25JZCwge1xuICAgICAgICAgICAgICAgICAgICBwb29sLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVzZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCB0byBQb3N0Z3JlU1FMOiAke2Vycm9yLm1lc3NhZ2V9YCkgYXMgQ29ubmVjdGlvbkVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBwb29sSW5mbyA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgcG9vbEluZm8ucG9vbC5lbmQoKTtcbiAgICAgICAgdGhpcy5wb29scy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBQb29sKHtcbiAgICAgICAgICAgICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgICAgICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICAgICAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHNzbDogY29uZmlnLnNzbCA/IHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9IDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5xdWVyeSgnU0VMRUNUIDEnKTtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKCk7XG4gICAgICAgICAgICBhd2FpdCBwb29sLmVuZCgpO1xuXG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3ksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgcG9vbEluZm8gPSB0aGlzLnBvb2xzLmdldChyZXF1ZXN0LmNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7cmVxdWVzdC5jb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb29sSW5mby5sYXN0VXNlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBjbGllbnQ6IFBvb2xDbGllbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xpZW50ID0gYXdhaXQgcG9vbEluZm8ucG9vbC5jb25uZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBxdWVyeSB0aW1lb3V0XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0IHx8IERFRkFVTFRfUVVFUllfVElNRU9VVDtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5xdWVyeShgU0VUIHN0YXRlbWVudF90aW1lb3V0ID0gJHt0aW1lb3V0fWApO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQucXVlcnkocmVxdWVzdC5xdWVyeSk7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgcm93IGxpbWl0IChoYW5kbGUgcXVlcmllcyB0aGF0IGRvbid0IHJldHVybiByb3dzKVxuICAgICAgICAgICAgY29uc3QgbWF4Um93cyA9IHJlcXVlc3QubWF4Um93cyB8fCBERUZBVUxUX01BWF9ST1dTO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IHJlc3VsdC5yb3dzID8gcmVzdWx0LnJvd3Muc2xpY2UoMCwgbWF4Um93cykgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXN1bHQucm93cyA/IHJlc3VsdC5yb3dzLmxlbmd0aCA+IG1heFJvd3MgOiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gTWFwIGZpZWxkcyAoaGFuZGxlIHF1ZXJpZXMgdGhhdCBkb24ndCByZXR1cm4gZmllbGRzKVxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBRdWVyeUZpZWxkW10gPSByZXN1bHQuZmllbGRzID8gcmVzdWx0LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRoaXMubWFwRGF0YVR5cGUoZmllbGQuZGF0YVR5cGVJRCksXG4gICAgICAgICAgICAgICAgdGFibGVJRDogZmllbGQudGFibGVJRCxcbiAgICAgICAgICAgICAgICBjb2x1bW5JRDogZmllbGQuY29sdW1uSUQsXG4gICAgICAgICAgICB9KSkgOiBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICByb3dDb3VudDogcmVzdWx0LnJvd0NvdW50IHx8IDAsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVGltZSxcbiAgICAgICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdWVyeSBleGVjdXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCkgYXMgUXVlcnlFeGVjdXRpb25FcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUIFxuICAgICAgICBzY2hlbWFfbmFtZSBhcyBuYW1lLFxuICAgICAgICBzY2hlbWFfb3duZXIgYXMgb3duZXIsXG4gICAgICAgIChTRUxFQ1QgQ09VTlQoKikgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFxuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gcy5zY2hlbWFfbmFtZSkgYXMgdGFibGVfY291bnRcbiAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhIHNcbiAgICAgIFdIRVJFIHNjaGVtYV9uYW1lIE5PVCBJTiAoJ3BnX2NhdGFsb2cnLCAnaW5mb3JtYXRpb25fc2NoZW1hJywgJ3BnX3RvYXN0JylcbiAgICAgIE9SREVSIEJZIHNjaGVtYV9uYW1lO1xuICAgIGA7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlUXVlcnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBtYXhSb3dzOiAxMDAwLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnJvd3MubWFwKChyb3cpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgIG93bmVyOiByb3cub3duZXIsXG4gICAgICAgICAgICB0YWJsZUNvdW50OiBwYXJzZUludChyb3cudGFibGVfY291bnQpIHx8IDAsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBsaXN0VGFibGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWE6IHN0cmluZyA9ICdwdWJsaWMnKTogUHJvbWlzZTxUYWJsZVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUIFxuICAgICAgICB0YWJsZV9zY2hlbWEgYXMgc2NoZW1hLFxuICAgICAgICB0YWJsZV9uYW1lIGFzIG5hbWUsXG4gICAgICAgIHRhYmxlX3R5cGUgYXMgdHlwZSxcbiAgICAgICAgKFNFTEVDVCByZWx0dXBsZXM6OmJpZ2ludCBcbiAgICAgICAgIEZST00gcGdfY2xhc3MgXG4gICAgICAgICBXSEVSRSBvaWQgPSAocXVvdGVfaWRlbnQodGFibGVfc2NoZW1hKSB8fCAnLicgfHwgcXVvdGVfaWRlbnQodGFibGVfbmFtZSkpOjpyZWdjbGFzc1xuICAgICAgICApIGFzIHJvd19jb3VudCxcbiAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfdG90YWxfcmVsYXRpb25fc2l6ZShcbiAgICAgICAgICAocXVvdGVfaWRlbnQodGFibGVfc2NoZW1hKSB8fCAnLicgfHwgcXVvdGVfaWRlbnQodGFibGVfbmFtZSkpOjpyZWdjbGFzc1xuICAgICAgICApKSBhcyBzaXplXG4gICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXNcbiAgICAgIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICQxXG4gICAgICBPUkRFUiBCWSB0YWJsZV9uYW1lO1xuICAgIGA7XG5cbiAgICAgICAgY29uc3QgcG9vbEluZm8gPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2xJbmZvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gbm90IGZvdW5kOiAke2Nvbm5lY3Rpb25JZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHBvb2xJbmZvLnBvb2wuY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHF1ZXJ5LCBbc2NoZW1hXSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucm93cy5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHJvdy5zY2hlbWEsXG4gICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogcm93LnR5cGUgPT09ICdCQVNFIFRBQkxFJyA/ICd0YWJsZScgOiAndmlldycsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvdy5yb3dfY291bnQsXG4gICAgICAgICAgICAgICAgc2l6ZTogcm93LnNpemUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVzY3JpYmVUYWJsZShcbiAgICAgICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXG4gICAgICAgIHNjaGVtYTogc3RyaW5nLFxuICAgICAgICB0YWJsZTogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBhd2FpdCB0aGlzLmdldENvbHVtbnMoY29ubmVjdGlvbklkLCBzY2hlbWEsIHRhYmxlKTtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQsIHNjaGVtYSwgdGFibGUpO1xuICAgICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleXMoY29ubmVjdGlvbklkLCBzY2hlbWEsIHRhYmxlKTtcblxuICAgICAgICAvLyBHZXQgcHJpbWFyeSBrZXlzXG4gICAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gY29sdW1ucy5maWx0ZXIoKGNvbCkgPT4gY29sLmlzUHJpbWFyeUtleSkubWFwKChjb2wpID0+IGNvbC5uYW1lKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgcHJpbWFyeUtleXMsXG4gICAgICAgICAgICBmb3JlaWduS2V5cyxcbiAgICAgICAgICAgIGluZGV4ZXMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBTRUxFQ1RcbiAgICAgICAgaS5yZWxuYW1lIGFzIG5hbWUsXG4gICAgICAgIGFycmF5X2FnZyhhLmF0dG5hbWUgT1JERVIgQlkgYS5hdHRudW0pIGFzIGNvbHVtbnMsXG4gICAgICAgIGl4LmluZGlzdW5pcXVlIGFzIHVuaXF1ZSxcbiAgICAgICAgaXguaW5kaXNwcmltYXJ5IGFzIHByaW1hcnksXG4gICAgICAgIGFtLmFtbmFtZSBhcyB0eXBlXG4gICAgICBGUk9NIHBnX2NsYXNzIHRcbiAgICAgIEpPSU4gcGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSB0LnJlbG5hbWVzcGFjZVxuICAgICAgSk9JTiBwZ19pbmRleCBpeCBPTiB0Lm9pZCA9IGl4LmluZHJlbGlkXG4gICAgICBKT0lOIHBnX2NsYXNzIGkgT04gaS5vaWQgPSBpeC5pbmRleHJlbGlkXG4gICAgICBKT0lOIHBnX2FtIGFtIE9OIGkucmVsYW0gPSBhbS5vaWRcbiAgICAgIEpPSU4gcGdfYXR0cmlidXRlIGEgT04gYS5hdHRyZWxpZCA9IHQub2lkIEFORCBhLmF0dG51bSA9IEFOWShpeC5pbmRrZXkpXG4gICAgICBXSEVSRSBuLm5zcG5hbWUgPSAkMSBBTkQgdC5yZWxuYW1lID0gJDJcbiAgICAgIEdST1VQIEJZIGkucmVsbmFtZSwgaXguaW5kaXN1bmlxdWUsIGl4LmluZGlzcHJpbWFyeSwgYW0uYW1uYW1lXG4gICAgICBPUkRFUiBCWSBpLnJlbG5hbWU7XG4gICAgYDtcblxuICAgICAgICBjb25zdCBwb29sSW5mbyA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcG9vbEluZm8ucG9vbC5jb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQucXVlcnkocXVlcnksIFtzY2hlbWEsIHRhYmxlXSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucm93cy5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiByb3cuY29sdW1ucyxcbiAgICAgICAgICAgICAgICB1bmlxdWU6IHJvdy51bmlxdWUsXG4gICAgICAgICAgICAgICAgcHJpbWFyeTogcm93LnByaW1hcnksXG4gICAgICAgICAgICAgICAgdHlwZTogcm93LnR5cGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhwbGFpblF1ZXJ5KGNvbm5lY3Rpb25JZDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxFeHBsYWluUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGV4cGxhaW5RdWVyeSA9IGBFWFBMQUlOIChBTkFMWVpFLCBCVUZGRVJTLCBGT1JNQVQgSlNPTikgJHtxdWVyeX1gO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVF1ZXJ5KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIHF1ZXJ5OiBleHBsYWluUXVlcnksXG4gICAgICAgICAgICBtYXhSb3dzOiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBwbGFuID0gcmVzdWx0LnJvd3NbMF0/LlsnUVVFUlkgUExBTiddO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbGFuLFxuICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogcGxhbj8uWzBdPy5bJ0V4ZWN1dGlvbiBUaW1lJ10sXG4gICAgICAgICAgICB0b3RhbENvc3Q6IHBsYW4/LlswXT8uWydQbGFuJ10/LlsnVG90YWwgQ29zdCddLFxuICAgICAgICAgICAgcGxhblRleHQ6IEpTT04uc3RyaW5naWZ5KHBsYW4sIG51bGwsIDIpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVRdWVyeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBxdWVyeTogJ1NFTEVDVCB2ZXJzaW9uKCkgYXMgdmVyc2lvbicsXG4gICAgICAgICAgICBtYXhSb3dzOiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnJvd3NbMF0/LnZlcnNpb24gfHwgJ1Vua25vd24nO1xuICAgIH1cblxuICAgIGFzeW5jIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIHZlcnNpb24oKSBhcyB2ZXJzaW9uLFxuICAgICAgICBjdXJyZW50X2RhdGFiYXNlKCkgYXMgY3VycmVudF9kYXRhYmFzZSxcbiAgICAgICAgY3VycmVudF91c2VyIGFzIGN1cnJlbnRfdXNlcixcbiAgICAgICAgcGdfZW5jb2RpbmdfdG9fY2hhcihlbmNvZGluZykgYXMgZW5jb2RpbmdcbiAgICAgIEZST00gcGdfZGF0YWJhc2VcbiAgICAgIFdIRVJFIGRhdG5hbWUgPSBjdXJyZW50X2RhdGFiYXNlKCk7XG4gICAgYDtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVRdWVyeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1heFJvd3M6IDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IHJlc3VsdC5yb3dzWzBdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiByb3c/LnZlcnNpb24gfHwgJ1Vua25vd24nLFxuICAgICAgICAgICAgY3VycmVudERhdGFiYXNlOiByb3c/LmN1cnJlbnRfZGF0YWJhc2UsXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogcm93Py5jdXJyZW50X3VzZXIsXG4gICAgICAgICAgICBlbmNvZGluZzogcm93Py5lbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kc1xuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDb2x1bW5zKFxuICAgICAgICBjb25uZWN0aW9uSWQ6IHN0cmluZyxcbiAgICAgICAgc2NoZW1hOiBzdHJpbmcsXG4gICAgICAgIHRhYmxlOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPENvbHVtbltdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIGMuY29sdW1uX25hbWUgYXMgbmFtZSxcbiAgICAgICAgYy5kYXRhX3R5cGUgYXMgZGF0YV90eXBlLFxuICAgICAgICBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCBhcyBtYXhfbGVuZ3RoLFxuICAgICAgICBjLm51bWVyaWNfcHJlY2lzaW9uIGFzIHByZWNpc2lvbixcbiAgICAgICAgYy5udW1lcmljX3NjYWxlIGFzIHNjYWxlLFxuICAgICAgICBjLmlzX251bGxhYmxlID0gJ1lFUycgYXMgbnVsbGFibGUsXG4gICAgICAgIGMuY29sdW1uX2RlZmF1bHQgYXMgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgRVhJU1RTKFxuICAgICAgICAgIFNFTEVDVCAxIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmtleV9jb2x1bW5fdXNhZ2Uga2N1XG4gICAgICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVfY29uc3RyYWludHMgdGNcbiAgICAgICAgICAgIE9OIGtjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWVcbiAgICAgICAgICBXSEVSRSBrY3UudGFibGVfc2NoZW1hID0gYy50YWJsZV9zY2hlbWFcbiAgICAgICAgICAgIEFORCBrY3UudGFibGVfbmFtZSA9IGMudGFibGVfbmFtZVxuICAgICAgICAgICAgQU5EIGtjdS5jb2x1bW5fbmFtZSA9IGMuY29sdW1uX25hbWVcbiAgICAgICAgICAgIEFORCB0Yy5jb25zdHJhaW50X3R5cGUgPSAnUFJJTUFSWSBLRVknXG4gICAgICAgICkgYXMgaXNfcHJpbWFyeV9rZXksXG4gICAgICAgIEVYSVNUUyhcbiAgICAgICAgICBTRUxFQ1QgMSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5rZXlfY29sdW1uX3VzYWdlIGtjdVxuICAgICAgICAgIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlX2NvbnN0cmFpbnRzIHRjXG4gICAgICAgICAgICBPTiBrY3UuY29uc3RyYWludF9uYW1lID0gdGMuY29uc3RyYWludF9uYW1lXG4gICAgICAgICAgV0hFUkUga2N1LnRhYmxlX3NjaGVtYSA9IGMudGFibGVfc2NoZW1hXG4gICAgICAgICAgICBBTkQga2N1LnRhYmxlX25hbWUgPSBjLnRhYmxlX25hbWVcbiAgICAgICAgICAgIEFORCBrY3UuY29sdW1uX25hbWUgPSBjLmNvbHVtbl9uYW1lXG4gICAgICAgICAgICBBTkQgdGMuY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJ1xuICAgICAgICApIGFzIGlzX2ZvcmVpZ25fa2V5LFxuICAgICAgICBwZ2QuZGVzY3JpcHRpb24gYXMgY29tbWVudFxuICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyBjXG4gICAgICBMRUZUIEpPSU4gcGdfY2F0YWxvZy5wZ19zdGF0aW9fYWxsX3RhYmxlcyBzdFxuICAgICAgICBPTiBjLnRhYmxlX3NjaGVtYSA9IHN0LnNjaGVtYW5hbWUgQU5EIGMudGFibGVfbmFtZSA9IHN0LnJlbG5hbWVcbiAgICAgIExFRlQgSk9JTiBwZ19jYXRhbG9nLnBnX2Rlc2NyaXB0aW9uIHBnZFxuICAgICAgICBPTiBwZ2Qub2Jqb2lkID0gc3QucmVsaWQgQU5EIHBnZC5vYmpzdWJpZCA9IGMub3JkaW5hbF9wb3NpdGlvblxuICAgICAgV0hFUkUgYy50YWJsZV9zY2hlbWEgPSAkMSBBTkQgYy50YWJsZV9uYW1lID0gJDJcbiAgICAgIE9SREVSIEJZIGMub3JkaW5hbF9wb3NpdGlvbjtcbiAgICBgO1xuXG4gICAgICAgIGNvbnN0IHBvb2xJbmZvID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sSW5mby5wb29sLmNvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeShxdWVyeSwgW3NjaGVtYSwgdGFibGVdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiByb3cuZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aDogcm93Lm1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiByb3cucHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiByb3cuc2NhbGUsXG4gICAgICAgICAgICAgICAgbnVsbGFibGU6IHJvdy5udWxsYWJsZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHJvdy5kZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogcm93LmlzX3ByaW1hcnlfa2V5LFxuICAgICAgICAgICAgICAgIGlzRm9yZWlnbktleTogcm93LmlzX2ZvcmVpZ25fa2V5LFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHJvdy5jb21tZW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Rm9yZWlnbktleXMoXG4gICAgICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxuICAgICAgICBzY2hlbWE6IHN0cmluZyxcbiAgICAgICAgdGFibGU6IHN0cmluZ1xuICAgICk6IFByb21pc2U8Rm9yZWlnbktleVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIHRjLmNvbnN0cmFpbnRfbmFtZSBhcyBuYW1lLFxuICAgICAgICBhcnJheV9hZ2coa2N1LmNvbHVtbl9uYW1lIE9SREVSIEJZIGtjdS5vcmRpbmFsX3Bvc2l0aW9uKSBhcyBjb2x1bW5zLFxuICAgICAgICBjY3UudGFibGVfbmFtZSBhcyByZWZlcmVuY2VkX3RhYmxlLFxuICAgICAgICBhcnJheV9hZ2coY2N1LmNvbHVtbl9uYW1lIE9SREVSIEJZIGtjdS5vcmRpbmFsX3Bvc2l0aW9uKSBhcyByZWZlcmVuY2VkX2NvbHVtbnMsXG4gICAgICAgIHJjLnVwZGF0ZV9ydWxlIGFzIG9uX3VwZGF0ZSxcbiAgICAgICAgcmMuZGVsZXRlX3J1bGUgYXMgb25fZGVsZXRlXG4gICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZV9jb25zdHJhaW50cyB0Y1xuICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEua2V5X2NvbHVtbl91c2FnZSBrY3VcbiAgICAgICAgT04gdGMuY29uc3RyYWludF9uYW1lID0ga2N1LmNvbnN0cmFpbnRfbmFtZVxuICAgICAgICBBTkQgdGMudGFibGVfc2NoZW1hID0ga2N1LnRhYmxlX3NjaGVtYVxuICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuY29uc3RyYWludF9jb2x1bW5fdXNhZ2UgY2N1XG4gICAgICAgIE9OIGNjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWVcbiAgICAgICAgQU5EIGNjdS50YWJsZV9zY2hlbWEgPSB0Yy50YWJsZV9zY2hlbWFcbiAgICAgIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLnJlZmVyZW50aWFsX2NvbnN0cmFpbnRzIHJjXG4gICAgICAgIE9OIHRjLmNvbnN0cmFpbnRfbmFtZSA9IHJjLmNvbnN0cmFpbnRfbmFtZVxuICAgICAgICBBTkQgdGMudGFibGVfc2NoZW1hID0gcmMuY29uc3RyYWludF9zY2hlbWFcbiAgICAgIFdIRVJFIHRjLmNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWSdcbiAgICAgICAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICQxXG4gICAgICAgIEFORCB0Yy50YWJsZV9uYW1lID0gJDJcbiAgICAgIEdST1VQIEJZIHRjLmNvbnN0cmFpbnRfbmFtZSwgY2N1LnRhYmxlX25hbWUsIHJjLnVwZGF0ZV9ydWxlLCByYy5kZWxldGVfcnVsZTtcbiAgICBgO1xuXG4gICAgICAgIGNvbnN0IHBvb2xJbmZvID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sSW5mby5wb29sLmNvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeShxdWVyeSwgW3NjaGVtYSwgdGFibGVdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHJvdy5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRUYWJsZTogcm93LnJlZmVyZW5jZWRfdGFibGUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlZENvbHVtbnM6IHJvdy5yZWZlcmVuY2VkX2NvbHVtbnMsXG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IHJvdy5vbl91cGRhdGUsXG4gICAgICAgICAgICAgICAgb25EZWxldGU6IHJvdy5vbl9kZWxldGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXBEYXRhVHlwZShvaWQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIC8vIFBvc3RncmVTUUwgdHlwZSBPSUQgbWFwcGluZ1xuICAgICAgICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgMTY6ICdib29sZWFuJyxcbiAgICAgICAgICAgIDE3OiAnYnl0ZWEnLFxuICAgICAgICAgICAgMjA6ICdiaWdpbnQnLFxuICAgICAgICAgICAgMjE6ICdzbWFsbGludCcsXG4gICAgICAgICAgICAyMzogJ2ludGVnZXInLFxuICAgICAgICAgICAgMjU6ICd0ZXh0JyxcbiAgICAgICAgICAgIDExNDogJ2pzb24nLFxuICAgICAgICAgICAgMTQyOiAneG1sJyxcbiAgICAgICAgICAgIDcwMDogJ3JlYWwnLFxuICAgICAgICAgICAgNzAxOiAnZG91YmxlIHByZWNpc2lvbicsXG4gICAgICAgICAgICAxMDQzOiAndmFyY2hhcicsXG4gICAgICAgICAgICAxMDgyOiAnZGF0ZScsXG4gICAgICAgICAgICAxMDgzOiAndGltZScsXG4gICAgICAgICAgICAxMTE0OiAndGltZXN0YW1wJyxcbiAgICAgICAgICAgIDExODQ6ICd0aW1lc3RhbXB0eicsXG4gICAgICAgICAgICAxMTg2OiAnaW50ZXJ2YWwnLFxuICAgICAgICAgICAgMTcwMDogJ251bWVyaWMnLFxuICAgICAgICAgICAgMjk1MDogJ3V1aWQnLFxuICAgICAgICAgICAgMzgwMjogJ2pzb25iJyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHlwZU1hcFtvaWRdIHx8ICd1bmtub3duJztcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiUG9vbCIsIkJhc2VEQkFkYXB0ZXIiLCJERUZBVUxUX1FVRVJZX1RJTUVPVVQiLCJERUZBVUxUX01BWF9ST1dTIiwiUG9zdGdyZVNRTEFkYXB0ZXIiLCJjb25uZWN0IiwiY29uZmlnIiwiY29ubmVjdGlvbklkIiwiaWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInBvb2xDb25maWciLCJob3N0IiwicG9ydCIsImRhdGFiYXNlIiwidXNlciIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzc2wiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJtYXgiLCJtYXhQb29sU2l6ZSIsImlkbGVUaW1lb3V0TWlsbGlzIiwiY29ubmVjdGlvblRpbWVvdXRNaWxsaXMiLCJjb25uZWN0aW9uVGltZW91dCIsImFsbG93RXhpdE9uSWRsZSIsInBvb2wiLCJjbGllbnQiLCJyZXN1bHQiLCJxdWVyeSIsInZlcnNpb24iLCJyb3dzIiwicG9vbHMiLCJzZXQiLCJjcmVhdGVkQXQiLCJEYXRlIiwibGFzdFVzZWQiLCJzdWNjZXNzIiwicmVsZWFzZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZGlzY29ubmVjdCIsInBvb2xJbmZvIiwiZ2V0IiwiZW5kIiwiZGVsZXRlIiwidGVzdENvbm5lY3Rpb24iLCJzdGFydFRpbWUiLCJub3ciLCJsYXRlbmN5IiwiZXhlY3V0ZVF1ZXJ5IiwicmVxdWVzdCIsInRpbWVvdXQiLCJleGVjdXRpb25UaW1lIiwibWF4Um93cyIsInNsaWNlIiwiaGFzTW9yZSIsImxlbmd0aCIsImZpZWxkcyIsIm1hcCIsImZpZWxkIiwibmFtZSIsImRhdGFUeXBlIiwibWFwRGF0YVR5cGUiLCJkYXRhVHlwZUlEIiwidGFibGVJRCIsImNvbHVtbklEIiwicm93Q291bnQiLCJsaXN0U2NoZW1hcyIsInJvdyIsIm93bmVyIiwidGFibGVDb3VudCIsInBhcnNlSW50IiwidGFibGVfY291bnQiLCJsaXN0VGFibGVzIiwic2NoZW1hIiwidHlwZSIsInJvd19jb3VudCIsInNpemUiLCJkZXNjcmliZVRhYmxlIiwidGFibGUiLCJjb2x1bW5zIiwiZ2V0Q29sdW1ucyIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwiZm9yZWlnbktleXMiLCJnZXRGb3JlaWduS2V5cyIsInByaW1hcnlLZXlzIiwiZmlsdGVyIiwiY29sIiwiaXNQcmltYXJ5S2V5IiwidW5pcXVlIiwicHJpbWFyeSIsImV4cGxhaW5RdWVyeSIsInBsYW4iLCJ0b3RhbENvc3QiLCJwbGFuVGV4dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRWZXJzaW9uIiwiZ2V0RGF0YWJhc2VJbmZvIiwiY3VycmVudERhdGFiYXNlIiwiY3VycmVudF9kYXRhYmFzZSIsImN1cnJlbnRVc2VyIiwiY3VycmVudF91c2VyIiwiZW5jb2RpbmciLCJkYXRhX3R5cGUiLCJtYXhMZW5ndGgiLCJtYXhfbGVuZ3RoIiwicHJlY2lzaW9uIiwic2NhbGUiLCJudWxsYWJsZSIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRfdmFsdWUiLCJpc19wcmltYXJ5X2tleSIsImlzRm9yZWlnbktleSIsImlzX2ZvcmVpZ25fa2V5IiwiY29tbWVudCIsInJlZmVyZW5jZWRUYWJsZSIsInJlZmVyZW5jZWRfdGFibGUiLCJyZWZlcmVuY2VkQ29sdW1ucyIsInJlZmVyZW5jZWRfY29sdW1ucyIsIm9uVXBkYXRlIiwib25fdXBkYXRlIiwib25EZWxldGUiLCJvbl9kZWxldGUiLCJvaWQiLCJ0eXBlTWFwIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts":
/*!*********************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedisAdapter: () => (/* binding */ RedisAdapter)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"(rsc)/../../node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"RedisAdapter\");\n/**\n * Redis Database Adapter\n * Redis is a key-value store, not a traditional SQL database\n * Query format: JSON with Redis commands\n * Example: {\"command\": \"GET\", \"args\": [\"key\"]}\n */ class RedisAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"redis\");\n        try {\n            const client = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n                host: config.host,\n                port: config.port || 6379,\n                password: config.password,\n                db: parseInt(config.database || \"0\"),\n                connectTimeout: config.connectionTimeout || 10000\n            });\n            // Test connection\n            await client.ping();\n            this.clients.set(connectionId, client);\n            logger.info(`Connected to Redis: ${config.host}:${config.port}`);\n            return {\n                connectionId,\n                success: true,\n                version: await client.info(\"server\").then((info)=>{\n                    const match = info.match(/redis_version:([^\\r\\n]+)/);\n                    return match ? match[1] : \"unknown\";\n                })\n            };\n        } catch (error) {\n            logger.error(`Redis connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (client) {\n            await client.quit();\n            this.clients.delete(connectionId);\n            logger.info(`Disconnected from Redis: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const client = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n                host: config.host,\n                port: config.port || 6379,\n                password: config.password,\n                db: parseInt(config.database || \"0\"),\n                connectTimeout: 5000\n            });\n            await client.ping();\n            await client.quit();\n            return {\n                success: true,\n                message: \"Redis connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`Redis test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Redis has databases 0-15 by default\n            const dbCount = 16;\n            const schemas = [];\n            for(let i = 0; i < dbCount; i++){\n                // Switch to database\n                await client.select(i);\n                const keyCount = await client.dbsize();\n                schemas.push({\n                    name: `db${i}`,\n                    tableCount: keyCount\n                });\n            }\n            // Return to original database\n            const originalDb = parseInt(client.options.db?.toString() || \"0\", 10) || 0;\n            await client.select(originalDb);\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list Redis databases: ${error.message}`, error);\n            throw new Error(`Failed to list databases: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Get all keys (limited to 1000 for performance)\n            const keys = await client.keys(\"*\");\n            const limitedKeys = keys.slice(0, 1000);\n            const tables = await Promise.all(limitedKeys.map(async (key)=>{\n                const type = await client.type(key);\n                return {\n                    schema: schemaName || \"db0\",\n                    name: key,\n                    type: type,\n                    rowCount: type === \"list\" ? await client.llen(key) : type === \"set\" ? await client.scard(key) : type === \"zset\" ? await client.zcard(key) : type === \"hash\" ? await client.hlen(key) : 1\n                };\n            }));\n            return tables;\n        } catch (error) {\n            logger.error(`Failed to list Redis keys: ${error.message}`, error);\n            throw new Error(`Failed to list keys: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const type = await client.type(tableName);\n            const ttl = await client.ttl(tableName);\n            const columns = [\n                {\n                    name: \"key\",\n                    dataType: \"string\",\n                    nullable: false,\n                    isPrimaryKey: true,\n                    isForeignKey: false\n                },\n                {\n                    name: \"type\",\n                    dataType: type,\n                    nullable: false,\n                    isPrimaryKey: false,\n                    isForeignKey: false\n                },\n                {\n                    name: \"ttl\",\n                    dataType: \"integer\",\n                    nullable: true,\n                    defaultValue: ttl.toString(),\n                    isPrimaryKey: false,\n                    isForeignKey: false\n                }\n            ];\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys: [\n                    \"key\"\n                ],\n                foreignKeys: [],\n                indexes: [],\n                rowCount: 1\n            };\n        } catch (error) {\n            logger.error(`Failed to describe Redis key: ${error.message}`, error);\n            throw new Error(`Failed to describe key: ${error.message}`);\n        }\n    }\n    async getIndexes(_connectionId, _schemaName, _tableName) {\n        // Redis doesn't have traditional indexes\n        return [];\n    }\n    async executeQuery(request) {\n        const client = this.clients.get(request.connectionId);\n        if (!client) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            // Parse Redis command (JSON format)\n            // Example: {\"command\": \"GET\", \"args\": [\"mykey\"]}\n            // Or: {\"command\": \"KEYS\", \"args\": [\"*\"]}\n            const queryObj = JSON.parse(request.query);\n            if (!queryObj.command) {\n                throw new Error('Query must have \"command\" field. Example: {\"command\": \"GET\", \"args\": [\"mykey\"]}');\n            }\n            const command = queryObj.command.toUpperCase();\n            const args = queryObj.args || [];\n            // Execute Redis command\n            const result = await client[command.toLowerCase()](...args);\n            // Format result for display\n            let rows = [];\n            let fields = [];\n            if (Array.isArray(result)) {\n                rows = result.map((value, index)=>({\n                        index,\n                        value\n                    }));\n                fields = [\n                    {\n                        name: \"index\"\n                    },\n                    {\n                        name: \"value\"\n                    }\n                ];\n            } else if (typeof result === \"object\" && result !== null) {\n                rows = [\n                    result\n                ];\n                fields = Object.keys(result).map((key)=>({\n                        name: key\n                    }));\n            } else {\n                rows = [\n                    {\n                        result\n                    }\n                ];\n                fields = [\n                    {\n                        name: \"result\"\n                    }\n                ];\n            }\n            const executionTime = Date.now() - startTime;\n            return {\n                rows,\n                fields,\n                rowCount: rows.length,\n                executionTime,\n                hasMore: false\n            };\n        } catch (error) {\n            logger.error(`Redis command execution failed: ${error.message}`, error);\n            throw new Error(`Command execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(_connectionId, _query) {\n        // Redis doesn't have EXPLAIN functionality\n        return {\n            plan: {\n                message: \"Redis does not support query plans\"\n            },\n            planText: \"Redis is a key-value store and does not have SQL-style query plans.\"\n        };\n    }\n    async getVersion(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const info = await client.info(\"server\");\n            const match = info.match(/redis_version:([^\\r\\n]+)/);\n            return match ? match[1] : \"unknown\";\n        } catch (error) {\n            logger.error(`Failed to get Redis version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const info = await client.info();\n            const serverInfo = await client.info(\"server\");\n            const versionMatch = serverInfo.match(/redis_version:([^\\r\\n]+)/);\n            const uptimeMatch = info.match(/uptime_in_seconds:(\\d+)/);\n            return {\n                version: versionMatch ? versionMatch[1] : \"unknown\",\n                serverVersion: versionMatch ? versionMatch[1] : \"unknown\",\n                uptime: uptimeMatch ? parseInt(uptimeMatch[1]) : 0,\n                currentDatabase: `db${client.options.db || 0}`\n            };\n        } catch (error) {\n            logger.error(`Failed to get Redis database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.clients = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL3JlZGlzL1JlZGlzQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QjtBQUNnQztBQWV0QjtBQUV0QyxNQUFNRyxTQUFTLElBQUlELGdEQUFNQSxDQUFDO0FBRTFCOzs7OztDQUtDLEdBQ00sTUFBTUUscUJBQXFCSCxpRUFBYUE7SUFHM0MsTUFBTUksUUFBUUMsTUFBd0IsRUFBNkI7UUFDL0QsTUFBTUMsZUFBZSxJQUFJLENBQUNDLG9CQUFvQixDQUFDO1FBRS9DLElBQUk7WUFDQSxNQUFNQyxTQUFTLElBQUlULGdEQUFLQSxDQUFDO2dCQUNyQlUsTUFBTUosT0FBT0ksSUFBSTtnQkFDakJDLE1BQU1MLE9BQU9LLElBQUksSUFBSTtnQkFDckJDLFVBQVVOLE9BQU9NLFFBQVE7Z0JBQ3pCQyxJQUFJQyxTQUFTUixPQUFPUyxRQUFRLElBQUk7Z0JBQ2hDQyxnQkFBZ0JWLE9BQU9XLGlCQUFpQixJQUFJO1lBQ2hEO1lBRUEsa0JBQWtCO1lBQ2xCLE1BQU1SLE9BQU9TLElBQUk7WUFFakIsSUFBSSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ2IsY0FBY0U7WUFFL0JOLE9BQU9rQixJQUFJLENBQUMsQ0FBQyxvQkFBb0IsRUFBRWYsT0FBT0ksSUFBSSxDQUFDLENBQUMsRUFBRUosT0FBT0ssSUFBSSxDQUFDLENBQUM7WUFFL0QsT0FBTztnQkFDSEo7Z0JBQ0FlLFNBQVM7Z0JBQ1RDLFNBQVMsTUFBTWQsT0FBT1ksSUFBSSxDQUFDLFVBQVVHLElBQUksQ0FBQ0gsQ0FBQUE7b0JBQ3RDLE1BQU1JLFFBQVFKLEtBQUtJLEtBQUssQ0FBQztvQkFDekIsT0FBT0EsUUFBUUEsS0FBSyxDQUFDLEVBQUUsR0FBRztnQkFDOUI7WUFDSjtRQUNKLEVBQUUsT0FBT0MsT0FBWTtZQUNqQnZCLE9BQU91QixLQUFLLENBQUMsQ0FBQyx5QkFBeUIsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENB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QyxNQUFNMkYsZUFBZUQsV0FBV3RGLEtBQUssQ0FBQztZQUN0QyxNQUFNd0YsY0FBYzVGLEtBQUtJLEtBQUssQ0FBQztZQUUvQixPQUFPO2dCQUNIRixTQUFTeUYsZUFBZUEsWUFBWSxDQUFDLEVBQUUsR0FBRztnQkFDMUNFLGVBQWVGLGVBQWVBLFlBQVksQ0FBQyxFQUFFLEdBQUc7Z0JBQ2hERyxRQUFRRixjQUFjbkcsU0FBU21HLFdBQVcsQ0FBQyxFQUFFLElBQUk7Z0JBQ2pERyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUzRyxPQUFPd0MsT0FBTyxDQUFDcEMsRUFBRSxJQUFJLEVBQUUsQ0FBQztZQUNsRDtRQUNKLEVBQUUsT0FBT2EsT0FBWTtZQUNqQnZCLE9BQU91QixLQUFLLENBQUMsQ0FBQyxtQ0FBbUMsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENBQUMsRUFBRUQ7WUFDcEUsTUFBTSxJQUFJWSxNQUFNLENBQUMsNkJBQTZCLEVBQUVaLE1BQU1DLE9BQU8sQ0FBQyxDQUFDO1FBQ25FO0lBQ0o7OzthQXpTUVIsVUFBOEIsSUFBSWtHOztBQTBTOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3BhY2thZ2VzL2RiLWFkYXB0ZXJzL3NyYy9hZGFwdGVycy9yZWRpcy9SZWRpc0FkYXB0ZXIudHM/M2U5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XG5pbXBvcnQgeyBCYXNlREJBZGFwdGVyIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgU2NoZW1hLFxuICAgIFRhYmxlLFxuICAgIFRhYmxlTWV0YWRhdGEsXG4gICAgQ29sdW1uLFxuICAgIEluZGV4LFxuICAgIERhdGFiYXNlSW5mbyxcbiAgICBFeHBsYWluUmVzdWx0LFxufSBmcm9tICdAYm9zZGIvY29yZSc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAYm9zZGIvdXRpbHMnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdSZWRpc0FkYXB0ZXInKTtcblxuLyoqXG4gKiBSZWRpcyBEYXRhYmFzZSBBZGFwdGVyXG4gKiBSZWRpcyBpcyBhIGtleS12YWx1ZSBzdG9yZSwgbm90IGEgdHJhZGl0aW9uYWwgU1FMIGRhdGFiYXNlXG4gKiBRdWVyeSBmb3JtYXQ6IEpTT04gd2l0aCBSZWRpcyBjb21tYW5kc1xuICogRXhhbXBsZToge1wiY29tbWFuZFwiOiBcIkdFVFwiLCBcImFyZ3NcIjogW1wia2V5XCJdfVxuICovXG5leHBvcnQgY2xhc3MgUmVkaXNBZGFwdGVyIGV4dGVuZHMgQmFzZURCQWRhcHRlciB7XG4gICAgcHJpdmF0ZSBjbGllbnRzOiBNYXA8c3RyaW5nLCBSZWRpcz4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdyZWRpcycpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgUmVkaXMoe1xuICAgICAgICAgICAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0IHx8IDYzNzksXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBkYjogcGFyc2VJbnQoY29uZmlnLmRhdGFiYXNlIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgY29ubmVjdFRpbWVvdXQ6IGNvbmZpZy5jb25uZWN0aW9uVGltZW91dCB8fCAxMDAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUZXN0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5waW5nKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xpZW50cy5zZXQoY29ubmVjdGlvbklkLCBjbGllbnQpO1xuXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgQ29ubmVjdGVkIHRvIFJlZGlzOiAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0fWApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGF3YWl0IGNsaWVudC5pbmZvKCdzZXJ2ZXInKS50aGVuKGluZm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGluZm8ubWF0Y2goL3JlZGlzX3ZlcnNpb246KFteXFxyXFxuXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJ3Vua25vd24nO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWRpcyBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiAnJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnF1aXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBEaXNjb25uZWN0ZWQgZnJvbSBSZWRpczogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRpcyh7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgNjM3OSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIGRiOiBwYXJzZUludChjb25maWcuZGF0YWJhc2UgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucGluZygpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnF1aXQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWRpcyBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlZGlzIHRlc3QgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxpc3RTY2hlbWFzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxTY2hlbWFbXT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlZGlzIGhhcyBkYXRhYmFzZXMgMC0xNSBieSBkZWZhdWx0XG4gICAgICAgICAgICBjb25zdCBkYkNvdW50ID0gMTY7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFzOiBTY2hlbWFbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRiQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB0byBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5zZWxlY3QoaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5Q291bnQgPSBhd2FpdCBjbGllbnQuZGJzaXplKCk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgZGIke2l9YCxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDb3VudDoga2V5Q291bnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0byBvcmlnaW5hbCBkYXRhYmFzZVxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEYiA9IHBhcnNlSW50KGNsaWVudC5vcHRpb25zLmRiPy50b1N0cmluZygpIHx8ICcwJywgMTApIHx8IDA7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuc2VsZWN0KG9yaWdpbmFsRGIpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBSZWRpcyBkYXRhYmFzZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IGRhdGFiYXNlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZT86IHN0cmluZyk6IFByb21pc2U8VGFibGVbXT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwga2V5cyAobGltaXRlZCB0byAxMDAwIGZvciBwZXJmb3JtYW5jZSlcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBjbGllbnQua2V5cygnKicpO1xuICAgICAgICAgICAgY29uc3QgbGltaXRlZEtleXMgPSBrZXlzLnNsaWNlKDAsIDEwMDApO1xuXG4gICAgICAgICAgICBjb25zdCB0YWJsZXM6IFRhYmxlW10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBsaW1pdGVkS2V5cy5tYXAoYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gYXdhaXQgY2xpZW50LnR5cGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hTmFtZSB8fCAnZGIwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgYXMgYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQ6IHR5cGUgPT09ICdsaXN0JyA/IGF3YWl0IGNsaWVudC5sbGVuKGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnID8gYXdhaXQgY2xpZW50LnNjYXJkKGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnenNldCcgPyBhd2FpdCBjbGllbnQuemNhcmQoa2V5KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnaGFzaCcgPyBhd2FpdCBjbGllbnQuaGxlbihrZXkpIDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBSZWRpcyBrZXlzOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBrZXlzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZXNjcmliZVRhYmxlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWFOYW1lOiBzdHJpbmcsIHRhYmxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGF3YWl0IGNsaWVudC50eXBlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0dGwgPSBhd2FpdCBjbGllbnQudHRsKHRhYmxlTmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2tleScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yZWlnbktleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3JlaWduS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3R0bCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHR0bC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcmVpZ25LZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5czogWydrZXknXSxcbiAgICAgICAgICAgICAgICBmb3JlaWduS2V5czogW10sXG4gICAgICAgICAgICAgICAgaW5kZXhlczogW10sXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSBSZWRpcyBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEluZGV4ZXMoX2Nvbm5lY3Rpb25JZDogc3RyaW5nLCBfc2NoZW1hTmFtZTogc3RyaW5nLCBfdGFibGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgLy8gUmVkaXMgZG9lc24ndCBoYXZlIHRyYWRpdGlvbmFsIGluZGV4ZXNcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGFzeW5jIGV4ZWN1dGVRdWVyeShyZXF1ZXN0OiBRdWVyeVJlcXVlc3QpOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQocmVxdWVzdC5jb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7cmVxdWVzdC5jb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUGFyc2UgUmVkaXMgY29tbWFuZCAoSlNPTiBmb3JtYXQpXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiB7XCJjb21tYW5kXCI6IFwiR0VUXCIsIFwiYXJnc1wiOiBbXCJteWtleVwiXX1cbiAgICAgICAgICAgIC8vIE9yOiB7XCJjb21tYW5kXCI6IFwiS0VZU1wiLCBcImFyZ3NcIjogW1wiKlwiXX1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5T2JqID0gSlNPTi5wYXJzZShyZXF1ZXN0LnF1ZXJ5KTtcblxuICAgICAgICAgICAgaWYgKCFxdWVyeU9iai5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBtdXN0IGhhdmUgXCJjb21tYW5kXCIgZmllbGQuIEV4YW1wbGU6IHtcImNvbW1hbmRcIjogXCJHRVRcIiwgXCJhcmdzXCI6IFtcIm15a2V5XCJdfScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gcXVlcnlPYmouY29tbWFuZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHF1ZXJ5T2JqLmFyZ3MgfHwgW107XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgUmVkaXMgY29tbWFuZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGNsaWVudCBhcyBhbnkpW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0oLi4uYXJncyk7XG5cbiAgICAgICAgICAgIC8vIEZvcm1hdCByZXN1bHQgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgIGxldCByb3dzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgbGV0IGZpZWxkczogYW55W10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSByZXN1bHQubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7IGluZGV4LCB2YWx1ZSB9KSk7XG4gICAgICAgICAgICAgICAgZmllbGRzID0gW3sgbmFtZTogJ2luZGV4JyB9LCB7IG5hbWU6ICd2YWx1ZScgfV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBbcmVzdWx0XTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZXN1bHQpLm1hcChrZXkgPT4gKHsgbmFtZToga2V5IH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IFt7IHJlc3VsdCB9XTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBbeyBuYW1lOiAncmVzdWx0JyB9XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICAgICAgaGFzTW9yZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlZGlzIGNvbW1hbmQgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tbWFuZCBleGVjdXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBleHBsYWluUXVlcnkoX2Nvbm5lY3Rpb25JZDogc3RyaW5nLCBfcXVlcnk6IHN0cmluZyk6IFByb21pc2U8RXhwbGFpblJlc3VsdD4ge1xuICAgICAgICAvLyBSZWRpcyBkb2Vzbid0IGhhdmUgRVhQTEFJTiBmdW5jdGlvbmFsaXR5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbGFuOiB7IG1lc3NhZ2U6ICdSZWRpcyBkb2VzIG5vdCBzdXBwb3J0IHF1ZXJ5IHBsYW5zJyB9LFxuICAgICAgICAgICAgcGxhblRleHQ6ICdSZWRpcyBpcyBhIGtleS12YWx1ZSBzdG9yZSBhbmQgZG9lcyBub3QgaGF2ZSBTUUwtc3R5bGUgcXVlcnkgcGxhbnMuJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRWZXJzaW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgY2xpZW50LmluZm8oJ3NlcnZlcicpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBpbmZvLm1hdGNoKC9yZWRpc192ZXJzaW9uOihbXlxcclxcbl0rKS8pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAndW5rbm93bic7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBSZWRpcyB2ZXJzaW9uOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IGNsaWVudC5pbmZvKCk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgY2xpZW50LmluZm8oJ3NlcnZlcicpO1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID0gc2VydmVySW5mby5tYXRjaCgvcmVkaXNfdmVyc2lvbjooW15cXHJcXG5dKykvKTtcbiAgICAgICAgICAgIGNvbnN0IHVwdGltZU1hdGNoID0gaW5mby5tYXRjaCgvdXB0aW1lX2luX3NlY29uZHM6KFxcZCspLyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk1hdGNoID8gdmVyc2lvbk1hdGNoWzFdIDogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgIHNlcnZlclZlcnNpb246IHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXSA6ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICB1cHRpbWU6IHVwdGltZU1hdGNoID8gcGFyc2VJbnQodXB0aW1lTWF0Y2hbMV0pIDogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YWJhc2U6IGBkYiR7Y2xpZW50Lm9wdGlvbnMuZGIgfHwgMH1gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IFJlZGlzIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlJlZGlzIiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIlJlZGlzQWRhcHRlciIsImNvbm5lY3QiLCJjb25maWciLCJjb25uZWN0aW9uSWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsImNsaWVudCIsImhvc3QiLCJwb3J0IiwicGFzc3dvcmQiLCJkYiIsInBhcnNlSW50IiwiZGF0YWJhc2UiLCJjb25uZWN0VGltZW91dCIsImNvbm5lY3Rpb25UaW1lb3V0IiwicGluZyIsImNsaWVudHMiLCJzZXQiLCJpbmZvIiwic3VjY2VzcyIsInZlcnNpb24iLCJ0aGVuIiwibWF0Y2giLCJlcnJvciIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0IiwiZ2V0IiwicXVpdCIsImRlbGV0ZSIsInRlc3RDb25uZWN0aW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImxhdGVuY3kiLCJsaXN0U2NoZW1hcyIsIkVycm9yIiwiZGJDb3VudCIsInNjaGVtYXMiLCJpIiwic2VsZWN0Iiwia2V5Q291bnQiLCJkYnNpemUiLCJwdXNoIiwibmFtZSIsInRhYmxlQ291bnQiLCJvcmlnaW5hbERiIiwib3B0aW9ucyIsInRvU3RyaW5nIiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJrZXlzIiwibGltaXRlZEtleXMiLCJzbGljZSIsInRhYmxlcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJrZXkiLCJ0eXBlIiwic2NoZW1hIiwicm93Q291bnQiLCJsbGVuIiwic2NhcmQiLCJ6Y2FyZCIsImhsZW4iLCJkZXNjcmliZVRhYmxlIiwidGFibGVOYW1lIiwidHRsIiwiY29sdW1ucyIsImRhdGFUeXBlIiwibnVsbGFibGUiLCJpc1ByaW1hcnlLZXkiLCJpc0ZvcmVpZ25LZXkiLCJkZWZhdWx0VmFsdWUiLCJwcmltYXJ5S2V5cyIsImZvcmVpZ25LZXlzIiwiaW5kZXhlcyIsImdldEluZGV4ZXMiLCJfY29ubmVjdGlvbklkIiwiX3NjaGVtYU5hbWUiLCJfdGFibGVOYW1lIiwiZXhlY3V0ZVF1ZXJ5IiwicmVxdWVzdCIsInF1ZXJ5T2JqIiwiSlNPTiIsInBhcnNlIiwicXVlcnkiLCJjb21tYW5kIiwidG9VcHBlckNhc2UiLCJhcmdzIiwicmVzdWx0IiwidG9Mb3dlckNhc2UiLCJyb3dzIiwiZmllbGRzIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsdWUiLCJpbmRleCIsIk9iamVjdCIsImV4ZWN1dGlvblRpbWUiLCJsZW5ndGgiLCJoYXNNb3JlIiwiZXhwbGFpblF1ZXJ5IiwiX3F1ZXJ5IiwicGxhbiIsInBsYW5UZXh0IiwiZ2V0VmVyc2lvbiIsImdldERhdGFiYXNlSW5mbyIsInNlcnZlckluZm8iLCJ2ZXJzaW9uTWF0Y2giLCJ1cHRpbWVNYXRjaCIsInNlcnZlclZlcnNpb24iLCJ1cHRpbWUiLCJjdXJyZW50RGF0YWJhc2UiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/index.ts":
/*!***********************************************!*\
  !*** ../../packages/db-adapters/src/index.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterFactory: () => (/* reexport safe */ _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__.AdapterFactory),\n/* harmony export */   BaseDBAdapter: () => (/* reexport safe */ _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_0__.BaseDBAdapter),\n/* harmony export */   PostgreSQLAdapter: () => (/* reexport safe */ _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__.PostgreSQLAdapter)\n/* harmony export */ });\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/postgresql/PostgreSQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\");\n/* harmony import */ var _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AdapterFactory */ \"(rsc)/../../packages/db-adapters/src/AdapterFactory.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__, _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__]);\n([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__, _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QztBQUNnQjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2luZGV4LnRzPzVmMDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9hZGFwdGVycy9wb3N0Z3Jlc3FsL1Bvc3RncmVTUUxBZGFwdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vQWRhcHRlckZhY3RvcnknO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts":
/*!***************************************************************!*\
  !*** ../../packages/db-adapters/src/interfaces/IDBAdapter.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDBAdapter: () => (/* binding */ BaseDBAdapter)\n/* harmony export */ });\n/**\n * Base adapter class with common functionality\n */ class BaseDBAdapter {\n    /**\n     * Generate a unique connection ID\n     */ generateConnectionId(prefix) {\n        return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Get connection from map\n     */ getConnection(connectionId) {\n        const connection = this.connectionMap.get(connectionId);\n        if (!connection) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        return connection;\n    }\n    /**\n     * Check if connection exists\n     */ hasConnection(connectionId) {\n        return this.connectionMap.has(connectionId);\n    }\n    constructor(){\n        this.connectionMap = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2ludGVyZmFjZXMvSURCQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBc0dBOztDQUVDLEdBQ00sTUFBZUE7SUFtQmxCOztLQUVDLEdBQ0QscUJBQStCRSxNQUFjLEVBQVU7UUFDbkQsT0FBTyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxFQUFFQyxLQUFLQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDL0U7SUFFQTs7S0FFQyxHQUNELGNBQTJCRSxZQUFvQixFQUFLO1FBQ2hELE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0g7UUFDMUMsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsTUFBTSxJQUFJRyxNQUFNLENBQUMsc0JBQXNCLEVBQUVKLGFBQWEsQ0FBQztRQUMzRDtRQUNBLE9BQU9DO0lBQ1g7SUFFQTs7S0FFQyxHQUNELGNBQXdCRCxZQUFvQixFQUFXO1FBQ25ELE9BQU8sSUFBSSxDQUFDRSxhQUFhLENBQUNJLEdBQUcsQ0FBQ047SUFDbEM7O2FBekNVRSxnQkFBa0MsSUFBSUs7O0FBMENwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2ludGVyZmFjZXMvSURCQWRhcHRlci50cz8yZGQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgRXhwbGFpblJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBJbmRleCxcbiAgICBEYXRhYmFzZUluZm8sXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcblxuLyoqXG4gKiBDb3JlIGRhdGFiYXNlIGFkYXB0ZXIgaW50ZXJmYWNlXG4gKiBBbGwgZGF0YWJhc2Utc3BlY2lmaWMgYWRhcHRlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJREJBZGFwdGVyIHtcbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSBjb25maWcgQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgQ29ubmVjdGlvbiByZXN1bHQgd2l0aCBjb25uZWN0aW9uIElEXG4gICAgICovXG4gICAgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYSBkYXRhYmFzZSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEIHRvIGNsb3NlXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGRhdGFiYXNlIGNvbm5lY3Rpb24gd2l0aG91dCBlc3RhYmxpc2hpbmcgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbm5lY3Rpb24gY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIFRlc3QgcmVzdWx0IHdpdGggc3VjY2VzcyBzdGF0dXNcbiAgICAgKi9cbiAgICB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgc2NoZW1hcyBpbiB0aGUgZGF0YWJhc2VcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBzY2hlbWFzXG4gICAgICovXG4gICAgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPjtcblxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHRhYmxlcyBpbiBhIHNjaGVtYVxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgQ29ubmVjdGlvbiBJRFxuICAgICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIG5hbWUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBwdWJsaWMvZGVmYXVsdCBzY2hlbWEpXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdGFibGVzXG4gICAgICovXG4gICAgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hPzogc3RyaW5nKTogUHJvbWlzZTxUYWJsZVtdPjtcblxuICAgIC8qKlxuICAgICAqIEdldCBkZXRhaWxlZCBtZXRhZGF0YSBhYm91dCBhIHRhYmxlXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEXG4gICAgICogQHBhcmFtIHNjaGVtYSBTY2hlbWEgbmFtZVxuICAgICAqIEBwYXJhbSB0YWJsZSBUYWJsZSBuYW1lXG4gICAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIGNvbHVtbnMsIGtleXMsIGFuZCBpbmRleGVzXG4gICAgICovXG4gICAgZGVzY3JpYmVUYWJsZShjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlTWV0YWRhdGE+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4ZXMgZm9yIGEgdGFibGVcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0gc2NoZW1hIFNjaGVtYSBuYW1lXG4gICAgICogQHBhcmFtIHRhYmxlIFRhYmxlIG5hbWVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBpbmRleGVzXG4gICAgICovXG4gICAgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHF1ZXJ5IGFnYWluc3QgdGhlIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIHJlcXVlc3QgUXVlcnkgcmVxdWVzdCB3aXRoIHF1ZXJ5IHN0cmluZyBhbmQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFF1ZXJ5IHJlc3VsdCB3aXRoIHJvd3MgYW5kIG1ldGFkYXRhXG4gICAgICovXG4gICAgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXJ5IGV4ZWN1dGlvbiBwbGFuIChmb3Igc3VwcG9ydGVkIGRhdGFiYXNlcylcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMgUXVlcnkgZXhlY3V0aW9uIHBsYW5cbiAgICAgKi9cbiAgICBleHBsYWluUXVlcnkoY29ubmVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEV4cGxhaW5SZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFiYXNlIHZlcnNpb25cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcmV0dXJucyBEYXRhYmFzZSB2ZXJzaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2UgaW5mb3JtYXRpb24gYW5kIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEXG4gICAgICogQHJldHVybnMgRGF0YWJhc2UgaW5mb1xuICAgICAqL1xuICAgIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPjtcbn1cblxuLyoqXG4gKiBCYXNlIGFkYXB0ZXIgY2xhc3Mgd2l0aCBjb21tb24gZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZURCQWRhcHRlciBpbXBsZW1lbnRzIElEQkFkYXB0ZXIge1xuICAgIHByb3RlY3RlZCBjb25uZWN0aW9uTWFwOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xuXG4gICAgYWJzdHJhY3QgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+O1xuICAgIGFic3RyYWN0IGRpc2Nvbm5lY3QoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICAgIGFic3RyYWN0IHRlc3RDb25uZWN0aW9uKGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8VGVzdFJlc3VsdD47XG4gICAgYWJzdHJhY3QgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPjtcbiAgICBhYnN0cmFjdCBsaXN0VGFibGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWE/OiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlW10+O1xuICAgIGFic3RyYWN0IGRlc2NyaWJlVGFibGUoXG4gICAgICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxuICAgICAgICBzY2hlbWE6IHN0cmluZyxcbiAgICAgICAgdGFibGU6IHN0cmluZ1xuICAgICk6IFByb21pc2U8VGFibGVNZXRhZGF0YT47XG4gICAgYWJzdHJhY3QgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+O1xuICAgIGFic3RyYWN0IGV4ZWN1dGVRdWVyeShyZXF1ZXN0OiBRdWVyeVJlcXVlc3QpOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PjtcbiAgICBhYnN0cmFjdCBleHBsYWluUXVlcnkoY29ubmVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEV4cGxhaW5SZXN1bHQ+O1xuICAgIGFic3RyYWN0IGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG4gICAgYWJzdHJhY3QgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB1bmlxdWUgY29ubmVjdGlvbiBJRFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZW5lcmF0ZUNvbm5lY3Rpb25JZChwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29ubmVjdGlvbiBmcm9tIG1hcFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb25uZWN0aW9uPFQ+KGNvbm5lY3Rpb25JZDogc3RyaW5nKTogVCB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25NYXAuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gYXMgVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb25uZWN0aW9uIGV4aXN0c1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBoYXNDb25uZWN0aW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYXAuaGFzKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkJhc2VEQkFkYXB0ZXIiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInByZWZpeCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJnZXRDb25uZWN0aW9uIiwiY29ubmVjdGlvbklkIiwiY29ubmVjdGlvbiIsImNvbm5lY3Rpb25NYXAiLCJnZXQiLCJFcnJvciIsImhhc0Nvbm5lY3Rpb24iLCJoYXMiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\n");

/***/ })

};
;