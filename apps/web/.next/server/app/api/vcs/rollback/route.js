/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/vcs/rollback/route";
exports.ids = ["app/api/vcs/rollback/route"];
exports.modules = {

/***/ "dockerode":
/*!****************************!*\
  !*** external "dockerode" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("dockerode");

/***/ }),

/***/ "mysql2/promise":
/*!*********************************!*\
  !*** external "mysql2/promise" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("mysql2/promise");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "timers/promises":
/*!**********************************!*\
  !*** external "timers/promises" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers/promises");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "pg":
/*!*********************!*\
  !*** external "pg" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = import("pg");;

/***/ }),

/***/ "?135f":
/*!***********************************************!*\
  !*** @aws-sdk/credential-providers (ignored) ***!
  \***********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1681":
/*!**********************************!*\
  !*** @mongodb-js/zstd (ignored) ***!
  \**********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?937c":
/*!******************************!*\
  !*** gcp-metadata (ignored) ***!
  \******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?452d":
/*!**************************!*\
  !*** kerberos (ignored) ***!
  \**************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e1e1":
/*!*******************************************!*\
  !*** mongodb-client-encryption (ignored) ***!
  \*******************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?dae9":
/*!************************!*\
  !*** snappy (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4793":
/*!***********************!*\
  !*** socks (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Frollback%2Froute&page=%2Fapi%2Fvcs%2Frollback%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Frollback%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Frollback%2Froute&page=%2Fapi%2Fvcs%2Frollback%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Frollback%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_rollback_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/vcs/rollback/route.ts */ \"(rsc)/./src/app/api/vcs/rollback/route.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([C_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_rollback_route_ts__WEBPACK_IMPORTED_MODULE_3__]);\nC_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_rollback_route_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/vcs/rollback/route\",\n        pathname: \"/api/vcs/rollback\",\n        filename: \"route\",\n        bundlePath: \"app/api/vcs/rollback/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\Arush Gupta\\\\Downloads\\\\BosDB-Browser\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\vcs\\\\rollback\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_rollback_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/vcs/rollback/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ2Y3MlMkZyb2xsYmFjayUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGdmNzJTJGcm9sbGJhY2slMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZ2Y3MlMkZyb2xsYmFjayUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNBcnVzaCUyMEd1cHRhJTVDRG93bmxvYWRzJTVDQm9zREItQnJvd3NlciU1Q2FwcHMlNUN3ZWIlNUNzcmMlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q0FydXNoJTIwR3VwdGElNUNEb3dubG9hZHMlNUNCb3NEQi1Ccm93c2VyJTVDYXBwcyU1Q3dlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD1zdGFuZGFsb25lJnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ21EO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZILHFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8/OTExNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxBcnVzaCBHdXB0YVxcXFxEb3dubG9hZHNcXFxcQm9zREItQnJvd3NlclxcXFxhcHBzXFxcXHdlYlxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFx2Y3NcXFxccm9sbGJhY2tcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS92Y3Mvcm9sbGJhY2svcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS92Y3Mvcm9sbGJhY2tcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL3Zjcy9yb2xsYmFjay9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIkM6XFxcXFVzZXJzXFxcXEFydXNoIEd1cHRhXFxcXERvd25sb2Fkc1xcXFxCb3NEQi1Ccm93c2VyXFxcXGFwcHNcXFxcd2ViXFxcXHNyY1xcXFxhcHBcXFxcYXBpXFxcXHZjc1xcXFxyb2xsYmFja1xcXFxyb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvdmNzL3JvbGxiYWNrL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Frollback%2Froute&page=%2Fapi%2Fvcs%2Frollback%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Frollback%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/vcs/rollback/route.ts":
/*!*******************************************!*\
  !*** ./src/app/api/vcs/rollback/route.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bosdb/version-control */ \"(rsc)/../../packages/version-control/dist/index.js\");\n/* harmony import */ var _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_vcs_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/vcs-helper */ \"(rsc)/./src/lib/vcs-helper.ts\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/store */ \"(rsc)/./src/lib/store.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n/* harmony import */ var _lib_db_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/lib/db-utils */ \"(rsc)/./src/lib/db-utils.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_db_utils__WEBPACK_IMPORTED_MODULE_7__]);\n_lib_db_utils__WEBPACK_IMPORTED_MODULE_7__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_6__.Logger(\"RollbackAPI\");\n// POST /api/vcs/rollback - Rollback to a specific commit\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { connectionId, commitId, targetRevision, author, isRevert } = body;\n        if (!connectionId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Connection ID required\"\n            }, {\n                status: 400\n            });\n        }\n        // Get connection info\n        const connectionInfo = await (0,_lib_store__WEBPACK_IMPORTED_MODULE_5__.getConnection)(connectionId);\n        if (!connectionInfo) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: `Connection not found: ${connectionId}`\n            }, {\n                status: 404\n            });\n        }\n        // Initialize VCS\n        const vcsPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), \".bosdb-vcs\", connectionId);\n        await fs__WEBPACK_IMPORTED_MODULE_3__.promises.mkdir(vcsPath, {\n            recursive: true\n        });\n        const storage = new _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.FileStorage(vcsPath);\n        await storage.initialize();\n        const vc = (0,_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.createVersionControl)(connectionId, storage);\n        // Ensure initialized and state is loaded\n        await vc.initialize();\n        await vc.loadHEAD();\n        // Get all commits\n        const logResult = await vc.log({\n            maxCount: 1000\n        });\n        if (!logResult.success || !logResult.data || logResult.data.length === 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"No commits to rollback to\"\n            }, {\n                status: 404\n            });\n        }\n        const commits = logResult.data;\n        // Find target commit\n        let targetCommit;\n        let commitsToUndo = [];\n        if (isRevert && commitId) {\n            // Revert a single specific commit\n            targetCommit = commits.find((c)=>c.id === commitId);\n            if (targetCommit) {\n                commitsToUndo = [\n                    targetCommit\n                ];\n            }\n        } else if (targetRevision !== undefined) {\n            // Rollback by revision number (e.g., -2 for 2nd previous)\n            const targetIndex = Math.abs(targetRevision);\n            targetCommit = commits[targetIndex];\n            // Collect all commits between HEAD and target (exclusive of target's state)\n            commitsToUndo = commits.slice(0, targetIndex);\n        } else if (commitId) {\n            // Rollback by commit ID\n            const targetIndex = commits.findIndex((c)=>c.id === commitId);\n            if (targetIndex !== -1) {\n                targetCommit = commits[targetIndex];\n                commitsToUndo = commits.slice(0, targetIndex);\n            }\n        }\n        if (!targetCommit) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Target commit not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Check if already reverted\n        const isAlreadyReverted = commits.some((c)=>c.message.includes(`Revert:`) && c.message.includes(targetCommit.id.substring(0, 8)));\n        if (isRevert && isAlreadyReverted) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: `Commit ${targetCommit.id.substring(0, 8)} has already been reverted.`\n            }, {\n                status: 400\n            });\n        }\n        // --- PHYSICAL ROLLBACK ---\n        // Generate inverse SQL for all changes being undone\n        const undoSQLs = [];\n        // Rollback commits in reverse order (Log is already HEAD first, so it depends on how we slice)\n        // If commitsToUndo is HEAD to target, we should follow it.\n        // But for a SINGLE REVERT, we just need that commit's changes in REVERSE.\n        for (const commit of commitsToUndo){\n            // Un-apply changes in REVERSE order within the commit\n            const reversedChanges = [\n                ...commit.changes\n            ].reverse();\n            for (const change of reversedChanges){\n                if (change.status === \"REVERTED\") continue; // Skip already reverted\n                const sql = change.rollbackSQL || (0,_lib_vcs_helper__WEBPACK_IMPORTED_MODULE_4__.generateRollbackSQL)(change.query, change.metadata);\n                if (sql && sql !== \"MANUAL\") {\n                    undoSQLs.push(sql);\n                }\n            }\n        }\n        logger.info(`Rollback initiated for ${connectionId}. ${undoSQLs.length} undo operations found.`);\n        // Execute SQL on database if there are changes to undo\n        if (undoSQLs.length > 0) {\n            // Get adapter instance using shared helper\n            const { adapter, adapterConnectionId } = await (0,_lib_db_utils__WEBPACK_IMPORTED_MODULE_7__.getConnectedAdapter)(connectionId);\n            // Execute each undo SQL\n            for (const sql of undoSQLs){\n                try {\n                    // Skip execution for comments or hints\n                    logger.info(`Executing undo SQL: ${sql}`);\n                    await adapter.executeQuery({\n                        connectionId: adapterConnectionId,\n                        query: sql,\n                        timeout: 30000\n                    });\n                } catch (sqlError) {\n                    logger.error(`Failed to execute undo SQL: ${sql}`, sqlError);\n                // We continue for now, but ideally we should handle partial failures\n                }\n            }\n        }\n        // --- VCS SNAPSHOT UPDATE ---\n        // Use provided author or default to system\n        const rollbackAuthor = author || {\n            name: \"System\",\n            email: \"system@bosdb.com\"\n        };\n        // Create a new commit that reflects the rollback/revert\n        const revertMessage = isRevert ? `Revert: ${targetCommit.message} (${targetCommit.id.substring(0, 8)})` : `Rollback to: ${targetCommit.message} (${targetCommit.id.substring(0, 8)})`;\n        const revertCommit = await vc.commit(revertMessage, {\n            ...rollbackAuthor,\n            timestamp: new Date()\n        }, commitsToUndo.flatMap((c)=>c.changes).map((change)=>({\n                ...change,\n                operation: \"ROLLBACK\",\n                description: `Undone: ${change.description}`\n            })), targetCommit.snapshot || {\n            schema: {\n                tables: {}\n            },\n            data: {\n                tables: {}\n            },\n            timestamp: new Date()\n        });\n        if (!revertCommit.success) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create revert commit\"\n            }, {\n                status: 500\n            });\n        }\n        // Clear pending changes as they're now invalid after rollback\n        const pendingPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(vcsPath, \"pending.json\");\n        await fs__WEBPACK_IMPORTED_MODULE_3__.promises.writeFile(pendingPath, JSON.stringify({\n            changes: []\n        }));\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: isRevert ? `Reverted commit ${targetCommit.id.substring(0, 8)}` : `Rolled back to revision ${targetRevision || \"unknown\"}`,\n            targetCommit,\n            revertCommit: revertCommit.data,\n            performedBy: rollbackAuthor\n        });\n    } catch (error) {\n        logger.error(\"Rollback error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: String(error)\n        }, {\n            status: 500\n        });\n    }\n}\n// GET /api/vcs/rollback/diff?connectionId=xxx&fromRevision=0&toRevision=-1\n// Compare two revisions\nasync function GET(request) {\n    const searchParams = request.nextUrl.searchParams;\n    const connectionId = searchParams.get(\"connectionId\");\n    const fromRev = parseInt(searchParams.get(\"fromRevision\") || \"0\");\n    const toRev = parseInt(searchParams.get(\"toRevision\") || \"-1\");\n    if (!connectionId) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Connection ID required\"\n        }, {\n            status: 400\n        });\n    }\n    try {\n        const vcsPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), \".bosdb-vcs\", connectionId);\n        await fs__WEBPACK_IMPORTED_MODULE_3__.promises.mkdir(vcsPath, {\n            recursive: true\n        });\n        const storage = new _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.FileStorage(vcsPath);\n        await storage.initialize();\n        const vc = (0,_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.createVersionControl)(connectionId, storage);\n        // Ensure initialized and state is loaded\n        await vc.initialize();\n        await vc.loadHEAD();\n        // Get commits\n        const logResult = await vc.log({\n            maxCount: 1000\n        });\n        if (!logResult.success || !logResult.data || logResult.data.length === 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"No commits to compare\",\n                from: {\n                    revision: fromRev,\n                    commit: null,\n                    changes: []\n                },\n                to: {\n                    revision: toRev,\n                    commit: null,\n                    changes: []\n                },\n                changesSummary: {\n                    added: [],\n                    modified: [],\n                    removed: []\n                }\n            });\n        }\n        const commits = logResult.data;\n        const fromIndex = Math.abs(fromRev);\n        const toIndex = Math.abs(toRev);\n        const fromCommit = commits[fromIndex];\n        const toCommit = commits[toIndex];\n        if (!fromCommit && !toCommit) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Revisions not found - not enough commits in history\",\n                from: {\n                    revision: fromRev,\n                    commit: null,\n                    changes: []\n                },\n                to: {\n                    revision: toRev,\n                    commit: null,\n                    changes: []\n                },\n                changesSummary: {\n                    added: [],\n                    modified: [],\n                    removed: []\n                }\n            });\n        }\n        // Calculate differences\n        const differences = {\n            from: {\n                revision: fromRev,\n                commit: fromCommit || null,\n                changes: fromCommit?.changes || []\n            },\n            to: {\n                revision: toRev,\n                commit: toCommit || null,\n                changes: toCommit?.changes || []\n            },\n            changesSummary: {\n                added: [],\n                modified: [],\n                removed: []\n            }\n        };\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(differences);\n    } catch (error) {\n        logger.error(\"Diff error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: String(error)\n        }, {\n            status: 500\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T3dFLE9BQU94RTtRQUFPLEdBQUc7WUFBRUMsUUFBUTtRQUFJO0lBQ3JFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4vc3JjL2FwcC9hcGkvdmNzL3JvbGxiYWNrL3JvdXRlLnRzPzNlNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgY3JlYXRlVmVyc2lvbkNvbnRyb2wsIEZpbGVTdG9yYWdlIH0gZnJvbSAnQGJvc2RiL3ZlcnNpb24tY29udHJvbCc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgZ2VuZXJhdGVSb2xsYmFja1NRTCB9IGZyb20gJ0AvbGliL3Zjcy1oZWxwZXInO1xyXG5pbXBvcnQgeyBjb25uZWN0aW9ucywgYWRhcHRlckluc3RhbmNlcywgZ2V0Q29ubmVjdGlvbiB9IGZyb20gJ0AvbGliL3N0b3JlJztcclxuaW1wb3J0IHsgQWRhcHRlckZhY3RvcnkgfSBmcm9tICdAYm9zZGIvZGItYWRhcHRlcnMnO1xyXG5pbXBvcnQgeyBkZWNyeXB0Q3JlZGVudGlhbHMgfSBmcm9tICdAYm9zZGIvc2VjdXJpdHknO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAYm9zZGIvdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRDb25uZWN0ZWRBZGFwdGVyIH0gZnJvbSAnQC9saWIvZGItdXRpbHMnO1xyXG5cclxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignUm9sbGJhY2tBUEknKTtcclxuXHJcbi8vIFBPU1QgL2FwaS92Y3Mvcm9sbGJhY2sgLSBSb2xsYmFjayB0byBhIHNwZWNpZmljIGNvbW1pdFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uSWQsIGNvbW1pdElkLCB0YXJnZXRSZXZpc2lvbiwgYXV0aG9yLCBpc1JldmVydCB9ID0gYm9keTtcclxuXHJcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdDb25uZWN0aW9uIElEIHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGNvbm5lY3Rpb24gaW5mb1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25JbmZvID0gYXdhaXQgZ2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xyXG4gICAgICAgIGlmICghY29ubmVjdGlvbkluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCB9LCB7IHN0YXR1czogNDA0IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBWQ1NcclxuICAgICAgICBjb25zdCB2Y3NQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuYm9zZGItdmNzJywgY29ubmVjdGlvbklkKTtcclxuICAgICAgICBhd2FpdCBmcy5ta2Rpcih2Y3NQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IG5ldyBGaWxlU3RvcmFnZSh2Y3NQYXRoKTtcclxuICAgICAgICBhd2FpdCBzdG9yYWdlLmluaXRpYWxpemUoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmMgPSBjcmVhdGVWZXJzaW9uQ29udHJvbChjb25uZWN0aW9uSWQsIHN0b3JhZ2UpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbGl6ZWQgYW5kIHN0YXRlIGlzIGxvYWRlZFxyXG4gICAgICAgIGF3YWl0IHZjLmluaXRpYWxpemUoKTtcclxuICAgICAgICBhd2FpdCAodmMgYXMgYW55KS5sb2FkSEVBRCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgYWxsIGNvbW1pdHNcclxuICAgICAgICBjb25zdCBsb2dSZXN1bHQgPSBhd2FpdCB2Yy5sb2coeyBtYXhDb3VudDogMTAwMCB9KTtcclxuICAgICAgICBpZiAoIWxvZ1Jlc3VsdC5zdWNjZXNzIHx8ICFsb2dSZXN1bHQuZGF0YSB8fCBsb2dSZXN1bHQuZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdObyBjb21taXRzIHRvIHJvbGxiYWNrIHRvJyB9LCB7IHN0YXR1czogNDA0IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29tbWl0cyA9IGxvZ1Jlc3VsdC5kYXRhO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRhcmdldCBjb21taXRcclxuICAgICAgICBsZXQgdGFyZ2V0Q29tbWl0O1xyXG4gICAgICAgIGxldCBjb21taXRzVG9VbmRvOiBhbnlbXSA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoaXNSZXZlcnQgJiYgY29tbWl0SWQpIHtcclxuICAgICAgICAgICAgLy8gUmV2ZXJ0IGEgc2luZ2xlIHNwZWNpZmljIGNvbW1pdFxyXG4gICAgICAgICAgICB0YXJnZXRDb21taXQgPSBjb21taXRzLmZpbmQoKGM6IGFueSkgPT4gYy5pZCA9PT0gY29tbWl0SWQpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Q29tbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBjb21taXRzVG9VbmRvID0gW3RhcmdldENvbW1pdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFJldmlzaW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gUm9sbGJhY2sgYnkgcmV2aXNpb24gbnVtYmVyIChlLmcuLCAtMiBmb3IgMm5kIHByZXZpb3VzKVxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IE1hdGguYWJzKHRhcmdldFJldmlzaW9uKTtcclxuICAgICAgICAgICAgdGFyZ2V0Q29tbWl0ID0gY29tbWl0c1t0YXJnZXRJbmRleF07XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgYWxsIGNvbW1pdHMgYmV0d2VlbiBIRUFEIGFuZCB0YXJnZXQgKGV4Y2x1c2l2ZSBvZiB0YXJnZXQncyBzdGF0ZSlcclxuICAgICAgICAgICAgY29tbWl0c1RvVW5kbyA9IGNvbW1pdHMuc2xpY2UoMCwgdGFyZ2V0SW5kZXgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWl0SWQpIHtcclxuICAgICAgICAgICAgLy8gUm9sbGJhY2sgYnkgY29tbWl0IElEXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gY29tbWl0cy5maW5kSW5kZXgoKGM6IGFueSkgPT4gYy5pZCA9PT0gY29tbWl0SWQpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRDb21taXQgPSBjb21taXRzW3RhcmdldEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbW1pdHNUb1VuZG8gPSBjb21taXRzLnNsaWNlKDAsIHRhcmdldEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0YXJnZXRDb21taXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdUYXJnZXQgY29tbWl0IG5vdCBmb3VuZCcgfSwgeyBzdGF0dXM6IDQwNCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcmV2ZXJ0ZWRcclxuICAgICAgICBjb25zdCBpc0FscmVhZHlSZXZlcnRlZCA9IGNvbW1pdHMuc29tZSgoYzogYW55KSA9PlxyXG4gICAgICAgICAgICBjLm1lc3NhZ2UuaW5jbHVkZXMoYFJldmVydDpgKSAmJiBjLm1lc3NhZ2UuaW5jbHVkZXModGFyZ2V0Q29tbWl0LmlkLnN1YnN0cmluZygwLCA4KSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoaXNSZXZlcnQgJiYgaXNBbHJlYWR5UmV2ZXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IGBDb21taXQgJHt0YXJnZXRDb21taXQuaWQuc3Vic3RyaW5nKDAsIDgpfSBoYXMgYWxyZWFkeSBiZWVuIHJldmVydGVkLmAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLSBQSFlTSUNBTCBST0xMQkFDSyAtLS1cclxuICAgICAgICAvLyBHZW5lcmF0ZSBpbnZlcnNlIFNRTCBmb3IgYWxsIGNoYW5nZXMgYmVpbmcgdW5kb25lXHJcbiAgICAgICAgY29uc3QgdW5kb1NRTHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgLy8gUm9sbGJhY2sgY29tbWl0cyBpbiByZXZlcnNlIG9yZGVyIChMb2cgaXMgYWxyZWFkeSBIRUFEIGZpcnN0LCBzbyBpdCBkZXBlbmRzIG9uIGhvdyB3ZSBzbGljZSlcclxuICAgICAgICAvLyBJZiBjb21taXRzVG9VbmRvIGlzIEhFQUQgdG8gdGFyZ2V0LCB3ZSBzaG91bGQgZm9sbG93IGl0LlxyXG4gICAgICAgIC8vIEJ1dCBmb3IgYSBTSU5HTEUgUkVWRVJULCB3ZSBqdXN0IG5lZWQgdGhhdCBjb21taXQncyBjaGFuZ2VzIGluIFJFVkVSU0UuXHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY29tbWl0IG9mIGNvbW1pdHNUb1VuZG8pIHtcclxuICAgICAgICAgICAgLy8gVW4tYXBwbHkgY2hhbmdlcyBpbiBSRVZFUlNFIG9yZGVyIHdpdGhpbiB0aGUgY29tbWl0XHJcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkQ2hhbmdlcyA9IFsuLi5jb21taXQuY2hhbmdlc10ucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiByZXZlcnNlZENoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3RhdHVzID09PSAnUkVWRVJURUQnKSBjb250aW51ZTsgLy8gU2tpcCBhbHJlYWR5IHJldmVydGVkXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3FsID0gY2hhbmdlLnJvbGxiYWNrU1FMIHx8IGdlbmVyYXRlUm9sbGJhY2tTUUwoY2hhbmdlLnF1ZXJ5LCBjaGFuZ2UubWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNxbCAmJiBzcWwgIT09ICdNQU5VQUwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kb1NRTHMucHVzaChzcWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb2dnZXIuaW5mbyhgUm9sbGJhY2sgaW5pdGlhdGVkIGZvciAke2Nvbm5lY3Rpb25JZH0uICR7dW5kb1NRTHMubGVuZ3RofSB1bmRvIG9wZXJhdGlvbnMgZm91bmQuYCk7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgU1FMIG9uIGRhdGFiYXNlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHVuZG9cclxuICAgICAgICBpZiAodW5kb1NRTHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgYWRhcHRlciBpbnN0YW5jZSB1c2luZyBzaGFyZWQgaGVscGVyXHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRhcHRlciwgYWRhcHRlckNvbm5lY3Rpb25JZCB9ID0gYXdhaXQgZ2V0Q29ubmVjdGVkQWRhcHRlcihjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBlYWNoIHVuZG8gU1FMXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3FsIG9mIHVuZG9TUUxzKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW9uIGZvciBjb21tZW50cyBvciBoaW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBFeGVjdXRpbmcgdW5kbyBTUUw6ICR7c3FsfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuZXhlY3V0ZVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBhZGFwdGVyQ29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3FsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHNxbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSB1bmRvIFNRTDogJHtzcWx9YCwgc3FsRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvbnRpbnVlIGZvciBub3csIGJ1dCBpZGVhbGx5IHdlIHNob3VsZCBoYW5kbGUgcGFydGlhbCBmYWlsdXJlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gVkNTIFNOQVBTSE9UIFVQREFURSAtLS1cclxuICAgICAgICAvLyBVc2UgcHJvdmlkZWQgYXV0aG9yIG9yIGRlZmF1bHQgdG8gc3lzdGVtXHJcbiAgICAgICAgY29uc3Qgcm9sbGJhY2tBdXRob3IgPSBhdXRob3IgfHwge1xyXG4gICAgICAgICAgICBuYW1lOiAnU3lzdGVtJyxcclxuICAgICAgICAgICAgZW1haWw6ICdzeXN0ZW1AYm9zZGIuY29tJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb21taXQgdGhhdCByZWZsZWN0cyB0aGUgcm9sbGJhY2svcmV2ZXJ0XHJcbiAgICAgICAgY29uc3QgcmV2ZXJ0TWVzc2FnZSA9IGlzUmV2ZXJ0XHJcbiAgICAgICAgICAgID8gYFJldmVydDogJHt0YXJnZXRDb21taXQubWVzc2FnZX0gKCR7dGFyZ2V0Q29tbWl0LmlkLnN1YnN0cmluZygwLCA4KX0pYFxyXG4gICAgICAgICAgICA6IGBSb2xsYmFjayB0bzogJHt0YXJnZXRDb21taXQubWVzc2FnZX0gKCR7dGFyZ2V0Q29tbWl0LmlkLnN1YnN0cmluZygwLCA4KX0pYDtcclxuXHJcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29tbWl0ID0gYXdhaXQgdmMuY29tbWl0KFxyXG4gICAgICAgICAgICByZXZlcnRNZXNzYWdlLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAuLi5yb2xsYmFja0F1dGhvcixcclxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21taXRzVG9VbmRvLmZsYXRNYXAoYyA9PiBjLmNoYW5nZXMpLm1hcChjaGFuZ2UgPT4gKHtcclxuICAgICAgICAgICAgICAgIC4uLmNoYW5nZSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ1JPTExCQUNLJyBhcyBhbnksXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVuZG9uZTogJHtjaGFuZ2UuZGVzY3JpcHRpb259YFxyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICh0YXJnZXRDb21taXQgYXMgYW55KS5zbmFwc2hvdCB8fCB7IHNjaGVtYTogeyB0YWJsZXM6IHt9IH0sIGRhdGE6IHsgdGFibGVzOiB7fSB9LCB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICghcmV2ZXJ0Q29tbWl0LnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIHJldmVydCBjb21taXQnIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciBwZW5kaW5nIGNoYW5nZXMgYXMgdGhleSdyZSBub3cgaW52YWxpZCBhZnRlciByb2xsYmFja1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdQYXRoID0gcGF0aC5qb2luKHZjc1BhdGgsICdwZW5kaW5nLmpzb24nKTtcclxuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUocGVuZGluZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHsgY2hhbmdlczogW10gfSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBpc1JldmVydCA/IGBSZXZlcnRlZCBjb21taXQgJHt0YXJnZXRDb21taXQuaWQuc3Vic3RyaW5nKDAsIDgpfWAgOiBgUm9sbGVkIGJhY2sgdG8gcmV2aXNpb24gJHt0YXJnZXRSZXZpc2lvbiB8fCAndW5rbm93bid9YCxcclxuICAgICAgICAgICAgdGFyZ2V0Q29tbWl0LFxyXG4gICAgICAgICAgICByZXZlcnRDb21taXQ6IHJldmVydENvbW1pdC5kYXRhLFxyXG4gICAgICAgICAgICBwZXJmb3JtZWRCeTogcm9sbGJhY2tBdXRob3JcclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdSb2xsYmFjayBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IFN0cmluZyhlcnJvcikgfSwgeyBzdGF0dXM6IDUwMCB9KTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gR0VUIC9hcGkvdmNzL3JvbGxiYWNrL2RpZmY/Y29ubmVjdGlvbklkPXh4eCZmcm9tUmV2aXNpb249MCZ0b1JldmlzaW9uPS0xXHJcbi8vIENvbXBhcmUgdHdvIHJldmlzaW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSByZXF1ZXN0Lm5leHRVcmwuc2VhcmNoUGFyYW1zO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbklkID0gc2VhcmNoUGFyYW1zLmdldCgnY29ubmVjdGlvbklkJyk7XHJcbiAgICBjb25zdCBmcm9tUmV2ID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnZnJvbVJldmlzaW9uJykgfHwgJzAnKTtcclxuICAgIGNvbnN0IHRvUmV2ID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgndG9SZXZpc2lvbicpIHx8ICctMScpO1xyXG5cclxuICAgIGlmICghY29ubmVjdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdDb25uZWN0aW9uIElEIHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdmNzUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnLmJvc2RiLXZjcycsIGNvbm5lY3Rpb25JZCk7XHJcbiAgICAgICAgYXdhaXQgZnMubWtkaXIodmNzUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBuZXcgRmlsZVN0b3JhZ2UodmNzUGF0aCk7XHJcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZjID0gY3JlYXRlVmVyc2lvbkNvbnRyb2woY29ubmVjdGlvbklkLCBzdG9yYWdlKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGluaXRpYWxpemVkIGFuZCBzdGF0ZSBpcyBsb2FkZWRcclxuICAgICAgICBhd2FpdCB2Yy5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgYXdhaXQgKHZjIGFzIGFueSkubG9hZEhFQUQoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGNvbW1pdHNcclxuICAgICAgICBjb25zdCBsb2dSZXN1bHQgPSBhd2FpdCB2Yy5sb2coeyBtYXhDb3VudDogMTAwMCB9KTtcclxuICAgICAgICBpZiAoIWxvZ1Jlc3VsdC5zdWNjZXNzIHx8ICFsb2dSZXN1bHQuZGF0YSB8fCBsb2dSZXN1bHQuZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnTm8gY29tbWl0cyB0byBjb21wYXJlJyxcclxuICAgICAgICAgICAgICAgIGZyb206IHsgcmV2aXNpb246IGZyb21SZXYsIGNvbW1pdDogbnVsbCwgY2hhbmdlczogW10gfSxcclxuICAgICAgICAgICAgICAgIHRvOiB7IHJldmlzaW9uOiB0b1JldiwgY29tbWl0OiBudWxsLCBjaGFuZ2VzOiBbXSB9LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlc1N1bW1hcnk6IHsgYWRkZWQ6IFtdLCBtb2RpZmllZDogW10sIHJlbW92ZWQ6IFtdIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb21taXRzID0gbG9nUmVzdWx0LmRhdGE7XHJcblxyXG4gICAgICAgIGNvbnN0IGZyb21JbmRleCA9IE1hdGguYWJzKGZyb21SZXYpO1xyXG4gICAgICAgIGNvbnN0IHRvSW5kZXggPSBNYXRoLmFicyh0b1Jldik7XHJcblxyXG4gICAgICAgIGNvbnN0IGZyb21Db21taXQgPSBjb21taXRzW2Zyb21JbmRleF07XHJcbiAgICAgICAgY29uc3QgdG9Db21taXQgPSBjb21taXRzW3RvSW5kZXhdO1xyXG5cclxuICAgICAgICBpZiAoIWZyb21Db21taXQgJiYgIXRvQ29tbWl0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1JldmlzaW9ucyBub3QgZm91bmQgLSBub3QgZW5vdWdoIGNvbW1pdHMgaW4gaGlzdG9yeScsXHJcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHJldmlzaW9uOiBmcm9tUmV2LCBjb21taXQ6IG51bGwsIGNoYW5nZXM6IFtdIH0sXHJcbiAgICAgICAgICAgICAgICB0bzogeyByZXZpc2lvbjogdG9SZXYsIGNvbW1pdDogbnVsbCwgY2hhbmdlczogW10gfSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNTdW1tYXJ5OiB7IGFkZGVkOiBbXSwgbW9kaWZpZWQ6IFtdLCByZW1vdmVkOiBbXSB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZXMgPSB7XHJcbiAgICAgICAgICAgIGZyb206IHtcclxuICAgICAgICAgICAgICAgIHJldmlzaW9uOiBmcm9tUmV2LFxyXG4gICAgICAgICAgICAgICAgY29tbWl0OiBmcm9tQ29tbWl0IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBmcm9tQ29tbWl0Py5jaGFuZ2VzIHx8IFtdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvOiB7XHJcbiAgICAgICAgICAgICAgICByZXZpc2lvbjogdG9SZXYsXHJcbiAgICAgICAgICAgICAgICBjb21taXQ6IHRvQ29tbWl0IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiB0b0NvbW1pdD8uY2hhbmdlcyB8fCBbXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjaGFuZ2VzU3VtbWFyeToge1xyXG4gICAgICAgICAgICAgICAgYWRkZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZDogW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihkaWZmZXJlbmNlcyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcignRGlmZiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IFN0cmluZyhlcnJvcikgfSwgeyBzdGF0dXM6IDUwMCB9KTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiY3JlYXRlVmVyc2lvbkNvbnRyb2wiLCJGaWxlU3RvcmFnZSIsInBhdGgiLCJwcm9taXNlcyIsImZzIiwiZ2VuZXJhdGVSb2xsYmFja1NRTCIsImdldENvbm5lY3Rpb24iLCJMb2dnZXIiLCJnZXRDb25uZWN0ZWRBZGFwdGVyIiwibG9nZ2VyIiwiUE9TVCIsInJlcXVlc3QiLCJib2R5IiwianNvbiIsImNvbm5lY3Rpb25JZCIsImNvbW1pdElkIiwidGFyZ2V0UmV2aXNpb24iLCJhdXRob3IiLCJpc1JldmVydCIsImVycm9yIiwic3RhdHVzIiwiY29ubmVjdGlvbkluZm8iLCJ2Y3NQYXRoIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJta2RpciIsInJlY3Vyc2l2ZSIsInN0b3JhZ2UiLCJpbml0aWFsaXplIiwidmMiLCJsb2FkSEVBRCIsImxvZ1Jlc3VsdCIsImxvZyIsIm1heENvdW50Iiwic3VjY2VzcyIsImRhdGEiLCJsZW5ndGgiLCJjb21taXRzIiwidGFyZ2V0Q29tbWl0IiwiY29tbWl0c1RvVW5kbyIsImZpbmQiLCJjIiwiaWQiLCJ1bmRlZmluZWQiLCJ0YXJnZXRJbmRleCIsIk1hdGgiLCJhYnMiLCJzbGljZSIsImZpbmRJbmRleCIsImlzQWxyZWFkeVJldmVydGVkIiwic29tZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsInN1YnN0cmluZyIsInVuZG9TUUxzIiwiY29tbWl0IiwicmV2ZXJzZWRDaGFuZ2VzIiwiY2hhbmdlcyIsInJldmVyc2UiLCJjaGFuZ2UiLCJzcWwiLCJyb2xsYmFja1NRTCIsInF1ZXJ5IiwibWV0YWRhdGEiLCJwdXNoIiwiaW5mbyIsImFkYXB0ZXIiLCJhZGFwdGVyQ29ubmVjdGlvbklkIiwiZXhlY3V0ZVF1ZXJ5IiwidGltZW91dCIsInNxbEVycm9yIiwicm9sbGJhY2tBdXRob3IiLCJuYW1lIiwiZW1haWwiLCJyZXZlcnRNZXNzYWdlIiwicmV2ZXJ0Q29tbWl0IiwidGltZXN0YW1wIiwiRGF0ZSIsImZsYXRNYXAiLCJtYXAiLCJvcGVyYXRpb24iLCJkZXNjcmlwdGlvbiIsInNuYXBzaG90Iiwic2NoZW1hIiwidGFibGVzIiwicGVuZGluZ1BhdGgiLCJ3cml0ZUZpbGUiLCJKU09OIiwic3RyaW5naWZ5IiwicGVyZm9ybWVkQnkiLCJTdHJpbmciLCJHRVQiLCJzZWFyY2hQYXJhbXMiLCJuZXh0VXJsIiwiZ2V0IiwiZnJvbVJldiIsInBhcnNlSW50IiwidG9SZXYiLCJmcm9tIiwicmV2aXNpb24iLCJ0byIsImNoYW5nZXNTdW1tYXJ5IiwiYWRkZWQiLCJtb2RpZmllZCIsInJlbW92ZWQiLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwiZnJvbUNvbW1pdCIsInRvQ29tbWl0IiwiZGlmZmVyZW5jZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/vcs/rollback/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/db-utils.ts":
/*!*****************************!*\
  !*** ./src/lib/db-utils.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getConnectedAdapter: () => (/* binding */ getConnectedAdapter)\n/* harmony export */ });\n/* harmony import */ var _bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bosdb/db-adapters */ \"(rsc)/../../packages/db-adapters/src/index.ts\");\n/* harmony import */ var _bosdb_security__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bosdb/security */ \"(rsc)/../../packages/security/src/index.ts\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/store */ \"(rsc)/./src/lib/store.ts\");\n/* harmony import */ var _docker_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./docker-manager */ \"(rsc)/./src/lib/docker-manager.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__]);\n_bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\nasync function getConnectedAdapter(connectionId) {\n    const connectionInfo = await (0,_lib_store__WEBPACK_IMPORTED_MODULE_2__.getConnection)(connectionId);\n    if (!connectionInfo) {\n        throw new Error(`Connection not found: ${connectionId}`);\n    }\n    // Auto-awake and update activity for ALL Docker-managed databases\n    // This applies to any connection where the host is local (as set during provisioning)\n    if (connectionInfo.host === \"localhost\" || connectionInfo.host === \"127.0.0.1\" || connectionInfo.host === \"host.docker.internal\" || connectionInfo.host?.includes(\"bosdb-provisioned\")) {\n        try {\n            await (0,_docker_manager__WEBPACK_IMPORTED_MODULE_3__.ensureDatabaseStarted)(connectionInfo.port);\n            await (0,_docker_manager__WEBPACK_IMPORTED_MODULE_3__.updateDatabaseActivity)(connectionInfo.port);\n        } catch (error) {\n            console.error(`[db-utils] Failed to handle auto-sleep logic for ${connectionId}:`, error);\n        }\n    }\n    let adapterEntry = _lib_store__WEBPACK_IMPORTED_MODULE_2__.adapterInstances.get(connectionId);\n    if (!adapterEntry) {\n        const adapter = _bosdb_db_adapters__WEBPACK_IMPORTED_MODULE_0__.AdapterFactory.create(connectionInfo.type);\n        const credentials = (0,_bosdb_security__WEBPACK_IMPORTED_MODULE_1__.decryptCredentials)(connectionInfo.credentials);\n        const connectResult = await adapter.connect({\n            id: connectionId,\n            name: connectionInfo.name,\n            host: connectionInfo.host,\n            port: connectionInfo.port,\n            database: connectionInfo.database,\n            username: credentials.username,\n            password: credentials.password,\n            ssl: connectionInfo.ssl,\n            readOnly: connectionInfo.readOnly\n        });\n        if (!connectResult.success) {\n            throw new Error(\"Failed to connect to database\");\n        }\n        adapterEntry = {\n            adapter,\n            adapterConnectionId: connectResult.connectionId\n        };\n        _lib_store__WEBPACK_IMPORTED_MODULE_2__.adapterInstances.set(connectionId, adapterEntry);\n    }\n    return {\n        adapter: adapterEntry.adapter,\n        adapterConnectionId: adapterEntry.adapterConnectionId\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2RiLXV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ0M7QUFDc0I7QUFDTTtBQUUxRSxlQUFlTSxvQkFBb0JDLFlBQW9CO0lBQzFELE1BQU1DLGlCQUFpQixNQUFNTCx5REFBYUEsQ0FBQ0k7SUFDM0MsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDakIsTUFBTSxJQUFJQyxNQUFNLENBQUMsc0JBQXNCLEVBQUVGLGFBQWEsQ0FBQztJQUMzRDtJQUVBLGtFQUFrRTtJQUNsRSxzRkFBc0Y7SUFDdEYsSUFBSUMsZUFBZUUsSUFBSSxLQUFLLGVBQWVGLGVBQWVFLElBQUksS0FBSyxlQUFlRixlQUFlRSxJQUFJLEtBQUssMEJBQTBCRixlQUFlRSxJQUFJLEVBQUVDLFNBQVMsc0JBQXNCO1FBQ3BMLElBQUk7WUFDQSxNQUFNUCxzRUFBcUJBLENBQUNJLGVBQWVJLElBQUk7WUFDL0MsTUFBTVAsdUVBQXNCQSxDQUFDRyxlQUFlSSxJQUFJO1FBQ3BELEVBQUUsT0FBT0MsT0FBTztZQUNaQyxRQUFRRCxLQUFLLENBQUMsQ0FBQyxpREFBaUQsRUFBRU4sYUFBYSxDQUFDLENBQUMsRUFBRU07UUFDdkY7SUFDSjtJQUVBLElBQUlFLGVBQWViLHdEQUFnQkEsQ0FBQ2MsR0FBRyxDQUFDVDtJQUV4QyxJQUFJLENBQUNRLGNBQWM7UUFDZixNQUFNRSxVQUFVakIsOERBQWNBLENBQUNrQixNQUFNLENBQUNWLGVBQWVXLElBQUk7UUFDekQsTUFBTUMsY0FBY25CLG1FQUFrQkEsQ0FBQ08sZUFBZVksV0FBVztRQUVqRSxNQUFNQyxnQkFBZ0IsTUFBTUosUUFBUUssT0FBTyxDQUFDO1lBQ3hDQyxJQUFJaEI7WUFDSmlCLE1BQU1oQixlQUFlZ0IsSUFBSTtZQUN6QmQsTUFBTUYsZUFBZUUsSUFBSTtZQUN6QkUsTUFBTUosZUFBZUksSUFBSTtZQUN6QmEsVUFBVWpCLGVBQWVpQixRQUFRO1lBQ2pDQyxVQUFVTixZQUFZTSxRQUFRO1lBQzlCQyxVQUFVUCxZQUFZTyxRQUFRO1lBQzlCQyxLQUFLcEIsZUFBZW9CLEdBQUc7WUFDdkJDLFVBQVVyQixlQUFlcUIsUUFBUTtRQUNyQztRQUVBLElBQUksQ0FBQ1IsY0FBY1MsT0FBTyxFQUFFO1lBQ3hCLE1BQU0sSUFBSXJCLE1BQU07UUFDcEI7UUFFQU0sZUFBZTtZQUNYRTtZQUNBYyxxQkFBcUJWLGNBQWNkLFlBQVk7UUFDbkQ7UUFFQUwsd0RBQWdCQSxDQUFDOEIsR0FBRyxDQUFDekIsY0FBY1E7SUFDdkM7SUFFQSxPQUFPO1FBQ0hFLFNBQVNGLGFBQWFFLE9BQU87UUFDN0JjLHFCQUFxQmhCLGFBQWFnQixtQkFBbUI7SUFDekQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi9zcmMvbGliL2RiLXV0aWxzLnRzPzIzMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWRhcHRlckZhY3RvcnkgfSBmcm9tICdAYm9zZGIvZGItYWRhcHRlcnMnO1xyXG5pbXBvcnQgeyBkZWNyeXB0Q3JlZGVudGlhbHMgfSBmcm9tICdAYm9zZGIvc2VjdXJpdHknO1xyXG5pbXBvcnQgeyBjb25uZWN0aW9ucywgYWRhcHRlckluc3RhbmNlcywgZ2V0Q29ubmVjdGlvbiB9IGZyb20gJ0AvbGliL3N0b3JlJztcclxuaW1wb3J0IHsgZW5zdXJlRGF0YWJhc2VTdGFydGVkLCB1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IH0gZnJvbSAnLi9kb2NrZXItbWFuYWdlcic7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkQWRhcHRlcihjb25uZWN0aW9uSWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkluZm8gPSBhd2FpdCBnZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XHJcbiAgICBpZiAoIWNvbm5lY3Rpb25JbmZvKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXV0by1hd2FrZSBhbmQgdXBkYXRlIGFjdGl2aXR5IGZvciBBTEwgRG9ja2VyLW1hbmFnZWQgZGF0YWJhc2VzXHJcbiAgICAvLyBUaGlzIGFwcGxpZXMgdG8gYW55IGNvbm5lY3Rpb24gd2hlcmUgdGhlIGhvc3QgaXMgbG9jYWwgKGFzIHNldCBkdXJpbmcgcHJvdmlzaW9uaW5nKVxyXG4gICAgaWYgKGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICdsb2NhbGhvc3QnIHx8IGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICcxMjcuMC4wLjEnIHx8IGNvbm5lY3Rpb25JbmZvLmhvc3QgPT09ICdob3N0LmRvY2tlci5pbnRlcm5hbCcgfHwgY29ubmVjdGlvbkluZm8uaG9zdD8uaW5jbHVkZXMoJ2Jvc2RiLXByb3Zpc2lvbmVkJykpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBlbnN1cmVEYXRhYmFzZVN0YXJ0ZWQoY29ubmVjdGlvbkluZm8ucG9ydCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURhdGFiYXNlQWN0aXZpdHkoY29ubmVjdGlvbkluZm8ucG9ydCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2RiLXV0aWxzXSBGYWlsZWQgdG8gaGFuZGxlIGF1dG8tc2xlZXAgbG9naWMgZm9yICR7Y29ubmVjdGlvbklkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBhZGFwdGVyRW50cnkgPSBhZGFwdGVySW5zdGFuY2VzLmdldChjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgIGlmICghYWRhcHRlckVudHJ5KSB7XHJcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IEFkYXB0ZXJGYWN0b3J5LmNyZWF0ZShjb25uZWN0aW9uSW5mby50eXBlKTtcclxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IGRlY3J5cHRDcmVkZW50aWFscyhjb25uZWN0aW9uSW5mby5jcmVkZW50aWFscyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3RSZXN1bHQgPSBhd2FpdCBhZGFwdGVyLmNvbm5lY3Qoe1xyXG4gICAgICAgICAgICBpZDogY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICBuYW1lOiBjb25uZWN0aW9uSW5mby5uYW1lLFxyXG4gICAgICAgICAgICBob3N0OiBjb25uZWN0aW9uSW5mby5ob3N0LFxyXG4gICAgICAgICAgICBwb3J0OiBjb25uZWN0aW9uSW5mby5wb3J0LFxyXG4gICAgICAgICAgICBkYXRhYmFzZTogY29ubmVjdGlvbkluZm8uZGF0YWJhc2UsXHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiBjcmVkZW50aWFscy51c2VybmFtZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxyXG4gICAgICAgICAgICBzc2w6IGNvbm5lY3Rpb25JbmZvLnNzbCxcclxuICAgICAgICAgICAgcmVhZE9ubHk6IGNvbm5lY3Rpb25JbmZvLnJlYWRPbmx5LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIWNvbm5lY3RSZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIGRhdGFiYXNlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGFwdGVyRW50cnkgPSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXIsXHJcbiAgICAgICAgICAgIGFkYXB0ZXJDb25uZWN0aW9uSWQ6IGNvbm5lY3RSZXN1bHQuY29ubmVjdGlvbklkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYWRhcHRlckluc3RhbmNlcy5zZXQoY29ubmVjdGlvbklkLCBhZGFwdGVyRW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWRhcHRlcjogYWRhcHRlckVudHJ5LmFkYXB0ZXIsXHJcbiAgICAgICAgYWRhcHRlckNvbm5lY3Rpb25JZDogYWRhcHRlckVudHJ5LmFkYXB0ZXJDb25uZWN0aW9uSWRcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbIkFkYXB0ZXJGYWN0b3J5IiwiZGVjcnlwdENyZWRlbnRpYWxzIiwiYWRhcHRlckluc3RhbmNlcyIsImdldENvbm5lY3Rpb24iLCJlbnN1cmVEYXRhYmFzZVN0YXJ0ZWQiLCJ1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IiwiZ2V0Q29ubmVjdGVkQWRhcHRlciIsImNvbm5lY3Rpb25JZCIsImNvbm5lY3Rpb25JbmZvIiwiRXJyb3IiLCJob3N0IiwiaW5jbHVkZXMiLCJwb3J0IiwiZXJyb3IiLCJjb25zb2xlIiwiYWRhcHRlckVudHJ5IiwiZ2V0IiwiYWRhcHRlciIsImNyZWF0ZSIsInR5cGUiLCJjcmVkZW50aWFscyIsImNvbm5lY3RSZXN1bHQiLCJjb25uZWN0IiwiaWQiLCJuYW1lIiwiZGF0YWJhc2UiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic3NsIiwicmVhZE9ubHkiLCJzdWNjZXNzIiwiYWRhcHRlckNvbm5lY3Rpb25JZCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db-utils.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/docker-manager.ts":
/*!***********************************!*\
  !*** ./src/lib/docker-manager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDockerAvailable: () => (/* binding */ checkDockerAvailable),\n/* harmony export */   ensureDatabaseStarted: () => (/* binding */ ensureDatabaseStarted),\n/* harmony export */   loadDockerDatabases: () => (/* binding */ loadDockerDatabases),\n/* harmony export */   pullAndStartDatabase: () => (/* binding */ pullAndStartDatabase),\n/* harmony export */   removeDatabase: () => (/* binding */ removeDatabase),\n/* harmony export */   startDatabase: () => (/* binding */ startDatabase),\n/* harmony export */   startIdleTimeoutCheck: () => (/* binding */ startIdleTimeoutCheck),\n/* harmony export */   stopDatabase: () => (/* binding */ stopDatabase),\n/* harmony export */   syncDatabaseStatus: () => (/* binding */ syncDatabaseStatus),\n/* harmony export */   updateDatabaseActivity: () => (/* binding */ updateDatabaseActivity)\n/* harmony export */ });\n/* harmony import */ var dockerode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dockerode */ \"dockerode\");\n/* harmony import */ var dockerode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dockerode__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst docker = new (dockerode__WEBPACK_IMPORTED_MODULE_0___default())();\n// Storage path for database configurations\nconst STORAGE_DIR = path__WEBPACK_IMPORTED_MODULE_2__.join(process.cwd(), \"data\", \"docker-databases\");\n// Ensure storage directory exists\nif (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(STORAGE_DIR)) {\n    fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(STORAGE_DIR, {\n        recursive: true\n    });\n}\n// Port ranges for different database types\nconst PORT_RANGES = {\n    postgres: 5432,\n    mysql: 3306,\n    mariadb: 3306,\n    mongodb: 27017,\n    redis: 6379,\n    mssql: 1433,\n    oracle: 1521,\n    cassandra: 9042,\n    neo4j: 7687,\n    elasticsearch: 9200,\n    clickhouse: 8123,\n    influxdb: 8086,\n    firebird: 3050,\n    cubrid: 33000,\n    couchbase: 8091,\n    orientdb: 2424,\n    rabbitmq: 5672,\n    minio: 9000\n};\n// Default docker images for database types\nconst DOCKER_IMAGES = {\n    postgres: \"postgres:16-alpine\",\n    mysql: \"mysql:8.0\",\n    mariadb: \"mariadb:11\",\n    mongodb: \"mongo:7\",\n    redis: \"redis:7-alpine\",\n    mssql: \"mcr.microsoft.com/mssql/server:2022-latest\",\n    cassandra: \"cassandra:5\",\n    neo4j: \"neo4j:5\",\n    elasticsearch: \"elasticsearch:8.11.0\",\n    opensearch: \"opensearchproject/opensearch:2.11.0\",\n    clickhouse: \"clickhouse/clickhouse-server:latest\",\n    influxdb: \"influxdb:2.7-alpine\",\n    timescaledb: \"timescale/timescaledb:latest-pg16\",\n    cockroachdb: \"cockroachdb/cockroach:latest\",\n    yugabyte: \"yugabytedb/yugabyte:latest\",\n    tidb: \"pingcap/tidb:latest\",\n    scylladb: \"scylladb/scylla:latest\",\n    ferretdb: \"ghcr.io/ferretdb/ferretdb:latest\",\n    couchdb: \"couchdb:3\",\n    solr: \"solr:9\",\n    memcached: \"memcached:1.6-alpine\",\n    rabbitmq: \"rabbitmq:3-management-alpine\",\n    minio: \"minio/minio:latest\",\n    surrealdb: \"surrealdb/surrealdb:latest\",\n    oracle: \"gvenzl/oracle-free:latest\",\n    firebird: \"jacobalberty/firebird:latest\",\n    cubrid: \"cubrid/cubrid:latest\",\n    h2: \"oscarfonts/h2:latest\",\n    couchbase: \"couchbase:latest\",\n    orientdb: \"orientdb:3.2\",\n    prometheus: \"prom/prometheus:latest\"\n};\n/**\r\n * Check if Docker is available and running\r\n */ async function checkDockerAvailable() {\n    try {\n        await docker.ping();\n        return true;\n    } catch (error) {\n        console.error(\"[Docker] Docker is not available:\", error);\n        return false;\n    }\n}\n/**\r\n * Find an available port starting from the default port\r\n */ async function findAvailablePort(startPort) {\n    const usedPorts = await getUsedPorts();\n    let port = startPort;\n    while(usedPorts.has(port)){\n        port++;\n    }\n    return port;\n}\n/**\r\n * Get all currently used ports\r\n */ async function getUsedPorts() {\n    const databases = getAllDockerDatabases();\n    return new Set(databases.map((db)=>db.port));\n}\n/**\r\n * Get storage file path for organization\r\n */ function getStorageFilePath(organizationId) {\n    return path__WEBPACK_IMPORTED_MODULE_2__.join(STORAGE_DIR, `${organizationId}.json`);\n}\n/**\r\n * Load databases for a specific organization\r\n */ function loadDockerDatabases(organizationId) {\n    const filePath = getStorageFilePath(organizationId);\n    if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(filePath)) {\n        return [];\n    }\n    try {\n        const data = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filePath, \"utf-8\");\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(`[Docker] Failed to load databases for org ${organizationId}:`, error);\n        return [];\n    }\n}\n/**\r\n * Get all databases across all organizations\r\n */ function getAllDockerDatabases() {\n    const databases = [];\n    if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(STORAGE_DIR)) {\n        return databases;\n    }\n    const files = fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync(STORAGE_DIR);\n    for (const file of files){\n        if (file.endsWith(\".json\")) {\n            try {\n                const data = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(path__WEBPACK_IMPORTED_MODULE_2__.join(STORAGE_DIR, file), \"utf-8\");\n                const orgDatabases = JSON.parse(data);\n                databases.push(...orgDatabases);\n            } catch (error) {\n                console.error(`[Docker] Failed to load ${file}:`, error);\n            }\n        }\n    }\n    return databases;\n}\n/**\r\n * Save databases for a specific organization\r\n */ function saveDockerDatabases(organizationId, databases) {\n    const filePath = getStorageFilePath(organizationId);\n    fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(filePath, JSON.stringify(databases, null, 2));\n}\n/**\r\n * Generate database credentials\r\n */ function generateCredentials(type, name) {\n    const username = type === \"postgres\" || type === \"timescaledb\" ? \"postgres\" : type === \"mysql\" || type === \"mariadb\" ? \"root\" : type === \"mongodb\" ? \"admin\" : type === \"mssql\" ? \"sa\" : \"admin\";\n    const password = `${name}_${Math.random().toString(36).substring(2, 10)}`;\n    const database = type === \"mongodb\" ? \"admin\" : name.toLowerCase().replace(/[^a-z0-9]/g, \"_\");\n    return {\n        username,\n        password,\n        database\n    };\n}\n/**\r\n * Get environment variables for database container\r\n */ function getEnvironmentVariables(type, credentials) {\n    const { username, password, database } = credentials;\n    switch(type){\n        case \"postgres\":\n        case \"timescaledb\":\n            return [\n                `POSTGRES_USER=${username}`,\n                `POSTGRES_PASSWORD=${password}`,\n                `POSTGRES_DB=${database}`\n            ];\n        case \"mysql\":\n        case \"mariadb\":\n            return [\n                `MYSQL_ROOT_PASSWORD=${password}`,\n                `MYSQL_DATABASE=${database}`\n            ];\n        case \"mongodb\":\n            return [\n                `MONGO_INITDB_ROOT_USERNAME=${username}`,\n                `MONGO_INITDB_ROOT_PASSWORD=${password}`\n            ];\n        case \"redis\":\n            return [\n                `REDIS_PASSWORD=${password}`\n            ];\n        case \"mssql\":\n            return [\n                \"ACCEPT_EULA=Y\",\n                `MSSQL_SA_PASSWORD=${password}`\n            ];\n        case \"neo4j\":\n            return [\n                `NEO4J_AUTH=${username}/${password}`\n            ];\n        case \"elasticsearch\":\n            return [\n                \"discovery.type=single-node\",\n                `ELASTIC_PASSWORD=${password}`,\n                \"xpack.security.enabled=false\"\n            ];\n        case \"opensearch\":\n            return [\n                \"discovery.type=single-node\",\n                `OPENSEARCH_INITIAL_ADMIN_PASSWORD=${password}`,\n                \"plugins.security.disabled=true\"\n            ];\n        case \"influxdb\":\n            return [\n                `DOCKER_INFLUXDB_INIT_USERNAME=${username}`,\n                `DOCKER_INFLUXDB_INIT_PASSWORD=${password}`,\n                `DOCKER_INFLUXDB_INIT_ORG=bosdb`,\n                `DOCKER_INFLUXDB_INIT_BUCKET=${database}`,\n                \"DOCKER_INFLUXDB_INIT_MODE=setup\"\n            ];\n        case \"rabbitmq\":\n            return [\n                `RABBITMQ_DEFAULT_USER=${username}`,\n                `RABBITMQ_DEFAULT_PASS=${password}`\n            ];\n        case \"minio\":\n            return [\n                `MINIO_ROOT_USER=${username}`,\n                `MINIO_ROOT_PASSWORD=${password}`\n            ];\n        case \"oracle\":\n            return [\n                `ORACLE_PASSWORD=${password}`,\n                `ORACLE_DATABASE=${database}`\n            ];\n        case \"firebird\":\n            return [\n                `ISC_PASSWORD=${password}`\n            ];\n        case \"couchbase\":\n            return [\n                `COUCHBASE_ADMINISTRATOR_USERNAME=${username}`,\n                `COUCHBASE_ADMINISTRATOR_PASSWORD=${password}`\n            ];\n        case \"orientdb\":\n            return [\n                `ORIENTDB_ROOT_PASSWORD=${password}`\n            ];\n        default:\n            return [];\n    }\n}\n/**\r\n * Pull Docker image and start database container\r\n */ async function pullAndStartDatabase(type, name, organizationId, autoStart = true, signal) {\n    const image = DOCKER_IMAGES[type];\n    if (!image) {\n        throw new Error(`Unsupported database type: ${type}`);\n    }\n    if (signal?.aborted) {\n        throw new Error(\"Provisioning cancelled\");\n    }\n    console.log(`[Docker] Checking if image ${image} exists localy...`);\n    const images = await docker.listImages();\n    const imageExists = images.some((img)=>img.RepoTags?.includes(image));\n    if (!imageExists) {\n        console.log(`[Docker] Pulling image ${image}...`);\n        // Pull the image\n        await new Promise((resolve, reject)=>{\n            let pullStream;\n            const abortHandler = ()=>{\n                if (pullStream && pullStream.destroy) {\n                    pullStream.destroy();\n                }\n                reject(new Error(\"Provisioning cancelled\"));\n            };\n            if (signal) {\n                signal.addEventListener(\"abort\", abortHandler);\n            }\n            docker.pull(image, (err, stream)=>{\n                if (err) {\n                    if (signal) signal.removeEventListener(\"abort\", abortHandler);\n                    reject(err);\n                    return;\n                }\n                pullStream = stream;\n                docker.modem.followProgress(stream, (err)=>{\n                    if (signal) signal.removeEventListener(\"abort\", abortHandler);\n                    if (err) {\n                        if (signal?.aborted) reject(new Error(\"Provisioning cancelled\"));\n                        else reject(err);\n                    } else resolve();\n                });\n            });\n        });\n        if (signal?.aborted) {\n            throw new Error(\"Provisioning cancelled\");\n        }\n        console.log(`[Docker] Image ${image} pulled successfully`);\n    } else {\n        console.log(`[Docker] Image ${image} already exists, skipping pull`);\n    }\n    // Generate database ID and credentials\n    const id = `${type}_${name}_${Date.now()}`.toLowerCase().replace(/[^a-z0-9_]/g, \"_\");\n    const credentials = generateCredentials(type, name);\n    const defaultPort = PORT_RANGES[type] || 5432;\n    const port = await findAvailablePort(defaultPort);\n    // Create container configuration\n    const env = getEnvironmentVariables(type, credentials);\n    const containerName = `bosdb_${id}`;\n    const createOptions = {\n        Image: image,\n        name: containerName,\n        Env: env,\n        HostConfig: {\n            PortBindings: {\n                [`${defaultPort}/tcp`]: [\n                    {\n                        HostPort: String(port)\n                    }\n                ]\n            },\n            RestartPolicy: autoStart ? {\n                Name: \"unless-stopped\"\n            } : {\n                Name: \"no\"\n            }\n        },\n        Labels: {\n            \"bosdb.managed\": \"true\",\n            \"bosdb.type\": type,\n            \"bosdb.organization\": organizationId\n        }\n    };\n    // Special configurations for specific databases\n    if (type === \"minio\") {\n        createOptions.Cmd = [\n            \"server\",\n            \"/data\",\n            \"--console-address\",\n            \":9001\"\n        ];\n        createOptions.HostConfig.PortBindings[\"9001/tcp\"] = [\n            {\n                HostPort: String(port + 1)\n            }\n        ];\n    } else if (type === \"neo4j\") {\n        createOptions.HostConfig.PortBindings[\"7474/tcp\"] = [\n            {\n                HostPort: String(port + 1)\n            }\n        ];\n    } else if (type === \"cockroachdb\") {\n        createOptions.Cmd = [\n            \"start-single-node\",\n            \"--insecure\"\n        ];\n        createOptions.HostConfig.PortBindings[\"26257/tcp\"] = [\n            {\n                HostPort: String(port)\n            }\n        ];\n        createOptions.HostConfig.PortBindings[\"8080/tcp\"] = [\n            {\n                HostPort: String(port + 100)\n            }\n        ];\n    }\n    console.log(`[Docker] Creating container ${containerName}...`);\n    // Create and start container\n    const container = await docker.createContainer(createOptions);\n    const containerId = container.id;\n    if (autoStart) {\n        console.log(`[Docker] Starting container ${containerName}...`);\n        await container.start();\n    }\n    // Create database record\n    const database = {\n        id,\n        type,\n        name,\n        port,\n        username: credentials.username,\n        password: credentials.password,\n        database: credentials.database,\n        status: autoStart ? \"running\" : \"stopped\",\n        autoStart,\n        createdAt: new Date().toISOString(),\n        lastUsedAt: new Date().toISOString(),\n        organizationId,\n        containerId\n    };\n    // Save to storage\n    const databases = loadDockerDatabases(organizationId);\n    databases.push(database);\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} created successfully`);\n    return database;\n}\n/**\r\n * Start a stopped database\r\n */ async function startDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (!database.containerId) {\n        throw new Error(`Container ID not found for database ${id}`);\n    }\n    const container = docker.getContainer(database.containerId);\n    await container.start();\n    // Update status and activity\n    database.status = \"running\";\n    database.lastUsedAt = new Date().toISOString();\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} started`);\n}\n/**\r\n * Stop a running database\r\n */ async function stopDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (!database.containerId) {\n        throw new Error(`Container ID not found for database ${id}`);\n    }\n    const container = docker.getContainer(database.containerId);\n    await container.stop();\n    // Update status\n    database.status = \"stopped\";\n    saveDockerDatabases(organizationId, databases);\n    console.log(`[Docker] Database ${id} stopped`);\n}\n/**\r\n * Remove a database and its container\r\n */ async function removeDatabase(id, organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    const database = databases.find((db)=>db.id === id);\n    if (!database) {\n        throw new Error(`Database ${id} not found`);\n    }\n    if (database.containerId) {\n        try {\n            const container = docker.getContainer(database.containerId);\n            // Stop if running\n            try {\n                await container.stop();\n            } catch (error) {\n            // Container might already be stopped\n            }\n            // Remove container\n            await container.remove();\n        } catch (error) {\n            console.error(`[Docker] Failed to remove container for ${id}:`, error);\n        }\n    }\n    // Remove from storage\n    const updatedDatabases = databases.filter((db)=>db.id !== id);\n    saveDockerDatabases(organizationId, updatedDatabases);\n    console.log(`[Docker] Database ${id} removed`);\n}\n/**\r\n * Sync database status with actual Docker containers\r\n */ async function syncDatabaseStatus(organizationId) {\n    const databases = loadDockerDatabases(organizationId);\n    let updated = false;\n    for (const database of databases){\n        if (database.containerId) {\n            try {\n                const container = docker.getContainer(database.containerId);\n                const info = await container.inspect();\n                const newStatus = info.State.Running ? \"running\" : \"stopped\";\n                if (database.status !== newStatus) {\n                    database.status = newStatus;\n                    updated = true;\n                }\n            } catch (error) {\n                console.error(`[Docker] Failed to get status for ${database.id}:`, error);\n                database.status = \"error\";\n                updated = true;\n            }\n        }\n    }\n    if (updated) {\n        saveDockerDatabases(organizationId, databases);\n    }\n}\n/**\r\n * Update the last used timestamp for a database by its port\r\n */ async function updateDatabaseActivity(port) {\n    const databases = getAllDockerDatabases();\n    const db = databases.find((d)=>d.port === port);\n    if (db) {\n        db.lastUsedAt = new Date().toISOString();\n        // We need to find which org it belongs to for saving\n        const orgDatabases = loadDockerDatabases(db.organizationId);\n        const orgDb = orgDatabases.find((d)=>d.id === db.id);\n        if (orgDb) {\n            orgDb.lastUsedAt = db.lastUsedAt;\n            saveDockerDatabases(db.organizationId, orgDatabases);\n        }\n    }\n}\n/**\r\n * Ensure a database is started if it's currently stopped\r\n */ async function ensureDatabaseStarted(port) {\n    const databases = getAllDockerDatabases();\n    const db = databases.find((d)=>d.port === port);\n    if (db && db.status === \"stopped\" && db.containerId) {\n        console.log(`[Docker] Auto-awakening database ${db.id} on port ${db.port}...`);\n        await startDatabase(db.id, db.organizationId);\n        // Wait a bit for the DB to be ready\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n    }\n}\n/**\r\n * Background check for idle databases to stop them (Auto-Sleep)\r\n */ let idleCheckInterval = null;\nconst IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes\nfunction startIdleTimeoutCheck() {\n    if (idleCheckInterval) return;\n    console.log(\"[Docker] Starting background idle timeout check (10 min)...\");\n    idleCheckInterval = setInterval(async ()=>{\n        const databases = getAllDockerDatabases();\n        const now = Date.now();\n        for (const db of databases){\n            if (db.status === \"running\" && db.lastUsedAt && db.containerId) {\n                const lastUsed = new Date(db.lastUsedAt).getTime();\n                if (now - lastUsed > IDLE_TIMEOUT_MS) {\n                    console.log(`[Docker] Database ${db.id} on port ${db.port} is idle for >10m. Sleeping...`);\n                    try {\n                        await stopDatabase(db.id, db.organizationId);\n                    } catch (error) {\n                        console.error(`[Docker] Failed to auto-sleep database ${db.id}:`, error);\n                    }\n                }\n            } else if (db.status === \"running\" && !db.lastUsedAt) {\n                // Initialize lastUsedAt if missing so it can eventually sleep\n                db.lastUsedAt = new Date().toISOString();\n                const orgDatabases = loadDockerDatabases(db.organizationId);\n                const orgDb = orgDatabases.find((d)=>d.id === db.id);\n                if (orgDb) {\n                    orgDb.lastUsedAt = db.lastUsedAt;\n                    saveDockerDatabases(db.organizationId, orgDatabases);\n                }\n            }\n        }\n    }, 60000); // Check every minute\n}\n// Start the check automatically\nif (true) {\n    startIdleTimeoutCheck();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdOLElBQUksQ0FBQyw4QkFBOEIsQ0FBQztvQkFDekYsSUFBSTt3QkFDQSxNQUFNNkYsYUFBYXZGLEdBQUcyRCxFQUFFLEVBQUUzRCxHQUFHRSxjQUFjO29CQUMvQyxFQUFFLE9BQU9kLE9BQU87d0JBQ1pDLFFBQVFELEtBQUssQ0FBQyxDQUFDLHVDQUF1QyxFQUFFWSxHQUFHMkQsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFdkU7b0JBQ3RFO2dCQUNKO1lBQ0osT0FBTyxJQUFJWSxHQUFHZ0YsTUFBTSxLQUFLLGFBQWEsQ0FBQ2hGLEdBQUdtRixVQUFVLEVBQUU7Z0JBQ2xELDhEQUE4RDtnQkFDOURuRixHQUFHbUYsVUFBVSxHQUFHLElBQUl2QixPQUFPc0IsV0FBVztnQkFDdEMsTUFBTXJFLGVBQWVWLG9CQUFvQkgsR0FBR0UsY0FBYztnQkFDMUQsTUFBTW9HLFFBQVF6RixhQUFhd0UsSUFBSSxDQUFDZ0IsQ0FBQUEsSUFBS0EsRUFBRTFDLEVBQUUsS0FBSzNELEdBQUcyRCxFQUFFO2dCQUNuRCxJQUFJMkMsT0FBTztvQkFDUEEsTUFBTW5CLFVBQVUsR0FBR25GLEdBQUdtRixVQUFVO29CQUNoQ3BFLG9CQUFvQmYsR0FBR0UsY0FBYyxFQUFFVztnQkFDM0M7WUFDSjtRQUNKO0lBQ0osR0FBRyxRQUFRLHFCQUFxQjtBQUNwQztBQUVBLGdDQUFnQztBQUNoQyxJQUFJLElBQWtCLEVBQWE7SUFDL0I4RjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uL3NyYy9saWIvZG9ja2VyLW1hbmFnZXIudHM/OTk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9ja2VyIGZyb20gJ2RvY2tlcm9kZSc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgRGF0YWJhc2VUeXBlIH0gZnJvbSAnQC9jb25zdGFudHMvZGF0YWJhc2UtdHlwZXMnO1xyXG5cclxuY29uc3QgZG9ja2VyID0gbmV3IERvY2tlcigpO1xyXG5cclxuLy8gU3RvcmFnZSBwYXRoIGZvciBkYXRhYmFzZSBjb25maWd1cmF0aW9uc1xyXG5jb25zdCBTVE9SQUdFX0RJUiA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGF0YScsICdkb2NrZXItZGF0YWJhc2VzJyk7XHJcblxyXG4vLyBFbnN1cmUgc3RvcmFnZSBkaXJlY3RvcnkgZXhpc3RzXHJcbmlmICghZnMuZXhpc3RzU3luYyhTVE9SQUdFX0RJUikpIHtcclxuICAgIGZzLm1rZGlyU3luYyhTVE9SQUdFX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyRGF0YWJhc2Uge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHR5cGU6IERhdGFiYXNlVHlwZTtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHBvcnQ6IG51bWJlcjtcclxuICAgIHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgICBwYXNzd29yZDogc3RyaW5nO1xyXG4gICAgZGF0YWJhc2U6IHN0cmluZztcclxuICAgIHN0YXR1czogJ3J1bm5pbmcnIHwgJ3N0b3BwZWQnIHwgJ2Vycm9yJztcclxuICAgIGF1dG9TdGFydDogYm9vbGVhbjtcclxuICAgIGNyZWF0ZWRBdDogc3RyaW5nO1xyXG4gICAgbGFzdFVzZWRBdD86IHN0cmluZzsgLy8gVHJhY2sgbGFzdCBhY3Rpdml0eSBmb3IgYXV0by1zbGVlcFxyXG4gICAgb3JnYW5pemF0aW9uSWQ6IHN0cmluZztcclxuICAgIGNvbnRhaW5lcklkPzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBQb3J0IHJhbmdlcyBmb3IgZGlmZmVyZW50IGRhdGFiYXNlIHR5cGVzXHJcbmNvbnN0IFBPUlRfUkFOR0VTOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICAgcG9zdGdyZXM6IDU0MzIsXHJcbiAgICBteXNxbDogMzMwNixcclxuICAgIG1hcmlhZGI6IDMzMDYsXHJcbiAgICBtb25nb2RiOiAyNzAxNyxcclxuICAgIHJlZGlzOiA2Mzc5LFxyXG4gICAgbXNzcWw6IDE0MzMsXHJcbiAgICBvcmFjbGU6IDE1MjEsXHJcbiAgICBjYXNzYW5kcmE6IDkwNDIsXHJcbiAgICBuZW80ajogNzY4NyxcclxuICAgIGVsYXN0aWNzZWFyY2g6IDkyMDAsXHJcbiAgICBjbGlja2hvdXNlOiA4MTIzLFxyXG4gICAgaW5mbHV4ZGI6IDgwODYsXHJcbiAgICBmaXJlYmlyZDogMzA1MCxcclxuICAgIGN1YnJpZDogMzMwMDAsXHJcbiAgICBjb3VjaGJhc2U6IDgwOTEsXHJcbiAgICBvcmllbnRkYjogMjQyNCxcclxuICAgIHJhYmJpdG1xOiA1NjcyLFxyXG4gICAgbWluaW86IDkwMDBcclxufTtcclxuXHJcbi8vIERlZmF1bHQgZG9ja2VyIGltYWdlcyBmb3IgZGF0YWJhc2UgdHlwZXNcclxuY29uc3QgRE9DS0VSX0lNQUdFUzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgIHBvc3RncmVzOiAncG9zdGdyZXM6MTYtYWxwaW5lJyxcclxuICAgIG15c3FsOiAnbXlzcWw6OC4wJyxcclxuICAgIG1hcmlhZGI6ICdtYXJpYWRiOjExJyxcclxuICAgIG1vbmdvZGI6ICdtb25nbzo3JyxcclxuICAgIHJlZGlzOiAncmVkaXM6Ny1hbHBpbmUnLFxyXG4gICAgbXNzcWw6ICdtY3IubWljcm9zb2Z0LmNvbS9tc3NxbC9zZXJ2ZXI6MjAyMi1sYXRlc3QnLFxyXG4gICAgY2Fzc2FuZHJhOiAnY2Fzc2FuZHJhOjUnLFxyXG4gICAgbmVvNGo6ICduZW80ajo1JyxcclxuICAgIGVsYXN0aWNzZWFyY2g6ICdlbGFzdGljc2VhcmNoOjguMTEuMCcsXHJcbiAgICBvcGVuc2VhcmNoOiAnb3BlbnNlYXJjaHByb2plY3Qvb3BlbnNlYXJjaDoyLjExLjAnLFxyXG4gICAgY2xpY2tob3VzZTogJ2NsaWNraG91c2UvY2xpY2tob3VzZS1zZXJ2ZXI6bGF0ZXN0JyxcclxuICAgIGluZmx1eGRiOiAnaW5mbHV4ZGI6Mi43LWFscGluZScsXHJcbiAgICB0aW1lc2NhbGVkYjogJ3RpbWVzY2FsZS90aW1lc2NhbGVkYjpsYXRlc3QtcGcxNicsXHJcbiAgICBjb2Nrcm9hY2hkYjogJ2NvY2tyb2FjaGRiL2NvY2tyb2FjaDpsYXRlc3QnLFxyXG4gICAgeXVnYWJ5dGU6ICd5dWdhYnl0ZWRiL3l1Z2FieXRlOmxhdGVzdCcsXHJcbiAgICB0aWRiOiAncGluZ2NhcC90aWRiOmxhdGVzdCcsXHJcbiAgICBzY3lsbGFkYjogJ3NjeWxsYWRiL3NjeWxsYTpsYXRlc3QnLFxyXG4gICAgZmVycmV0ZGI6ICdnaGNyLmlvL2ZlcnJldGRiL2ZlcnJldGRiOmxhdGVzdCcsXHJcbiAgICBjb3VjaGRiOiAnY291Y2hkYjozJyxcclxuICAgIHNvbHI6ICdzb2xyOjknLFxyXG4gICAgbWVtY2FjaGVkOiAnbWVtY2FjaGVkOjEuNi1hbHBpbmUnLFxyXG4gICAgcmFiYml0bXE6ICdyYWJiaXRtcTozLW1hbmFnZW1lbnQtYWxwaW5lJyxcclxuICAgIG1pbmlvOiAnbWluaW8vbWluaW86bGF0ZXN0JyxcclxuICAgIHN1cnJlYWxkYjogJ3N1cnJlYWxkYi9zdXJyZWFsZGI6bGF0ZXN0JyxcclxuICAgIG9yYWNsZTogJ2d2ZW56bC9vcmFjbGUtZnJlZTpsYXRlc3QnLFxyXG4gICAgZmlyZWJpcmQ6ICdqYWNvYmFsYmVydHkvZmlyZWJpcmQ6bGF0ZXN0JyxcclxuICAgIGN1YnJpZDogJ2N1YnJpZC9jdWJyaWQ6bGF0ZXN0JyxcclxuICAgIGgyOiAnb3NjYXJmb250cy9oMjpsYXRlc3QnLFxyXG4gICAgY291Y2hiYXNlOiAnY291Y2hiYXNlOmxhdGVzdCcsXHJcbiAgICBvcmllbnRkYjogJ29yaWVudGRiOjMuMicsXHJcbiAgICBwcm9tZXRoZXVzOiAncHJvbS9wcm9tZXRoZXVzOmxhdGVzdCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBEb2NrZXIgaXMgYXZhaWxhYmxlIGFuZCBydW5uaW5nXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEb2NrZXJBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGRvY2tlci5waW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tEb2NrZXJdIERvY2tlciBpcyBub3QgYXZhaWxhYmxlOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuIGF2YWlsYWJsZSBwb3J0IHN0YXJ0aW5nIGZyb20gdGhlIGRlZmF1bHQgcG9ydFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmluZEF2YWlsYWJsZVBvcnQoc3RhcnRQb3J0OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgY29uc3QgdXNlZFBvcnRzID0gYXdhaXQgZ2V0VXNlZFBvcnRzKCk7XHJcbiAgICBsZXQgcG9ydCA9IHN0YXJ0UG9ydDtcclxuICAgIHdoaWxlICh1c2VkUG9ydHMuaGFzKHBvcnQpKSB7XHJcbiAgICAgICAgcG9ydCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvcnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIGN1cnJlbnRseSB1c2VkIHBvcnRzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VkUG9ydHMoKTogUHJvbWlzZTxTZXQ8bnVtYmVyPj4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk7XHJcbiAgICByZXR1cm4gbmV3IFNldChkYXRhYmFzZXMubWFwKGRiID0+IGRiLnBvcnQpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBzdG9yYWdlIGZpbGUgcGF0aCBmb3Igb3JnYW5pemF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdG9yYWdlRmlsZVBhdGgob3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gcGF0aC5qb2luKFNUT1JBR0VfRElSLCBgJHtvcmdhbml6YXRpb25JZH0uanNvbmApO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZCBkYXRhYmFzZXMgZm9yIGEgc3BlY2lmaWMgb3JnYW5pemF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZDogc3RyaW5nKTogRG9ja2VyRGF0YWJhc2VbXSB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGdldFN0b3JhZ2VGaWxlUGF0aChvcmdhbml6YXRpb25JZCk7XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0RvY2tlcl0gRmFpbGVkIHRvIGxvYWQgZGF0YWJhc2VzIGZvciBvcmcgJHtvcmdhbml6YXRpb25JZH06YCwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgZGF0YWJhc2VzIGFjcm9zcyBhbGwgb3JnYW5pemF0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk6IERvY2tlckRhdGFiYXNlW10ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzOiBEb2NrZXJEYXRhYmFzZVtdID0gW107XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoU1RPUkFHRV9ESVIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFiYXNlcztcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoU1RPUkFHRV9ESVIpO1xyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoJy5qc29uJykpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKFNUT1JBR0VfRElSLCBmaWxlKSwgJ3V0Zi04Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdEYXRhYmFzZXMgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZGF0YWJhc2VzLnB1c2goLi4ub3JnRGF0YWJhc2VzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBsb2FkICR7ZmlsZX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFiYXNlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNhdmUgZGF0YWJhc2VzIGZvciBhIHNwZWNpZmljIG9yZ2FuaXphdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZDogc3RyaW5nLCBkYXRhYmFzZXM6IERvY2tlckRhdGFiYXNlW10pOiB2b2lkIHtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gZ2V0U3RvcmFnZUZpbGVQYXRoKG9yZ2FuaXphdGlvbklkKTtcclxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGFiYXNlcywgbnVsbCwgMikpO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgZGF0YWJhc2UgY3JlZGVudGlhbHNcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ3JlZGVudGlhbHModHlwZTogRGF0YWJhc2VUeXBlLCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHVzZXJuYW1lID0gdHlwZSA9PT0gJ3Bvc3RncmVzJyB8fCB0eXBlID09PSAndGltZXNjYWxlZGInID8gJ3Bvc3RncmVzJyA6XHJcbiAgICAgICAgdHlwZSA9PT0gJ215c3FsJyB8fCB0eXBlID09PSAnbWFyaWFkYicgPyAncm9vdCcgOlxyXG4gICAgICAgICAgICB0eXBlID09PSAnbW9uZ29kYicgPyAnYWRtaW4nIDpcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09ICdtc3NxbCcgPyAnc2EnIDpcclxuICAgICAgICAgICAgICAgICAgICAnYWRtaW4nO1xyXG5cclxuICAgIGNvbnN0IHBhc3N3b3JkID0gYCR7bmFtZX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApfWA7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IHR5cGUgPT09ICdtb25nb2RiJyA/ICdhZG1pbicgOiBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICdfJyk7XHJcblxyXG4gICAgcmV0dXJuIHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBkYXRhYmFzZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGF0YWJhc2UgY29udGFpbmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyh0eXBlOiBEYXRhYmFzZVR5cGUsIGNyZWRlbnRpYWxzOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCwgZGF0YWJhc2UgfSA9IGNyZWRlbnRpYWxzO1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3Bvc3RncmVzJzpcclxuICAgICAgICBjYXNlICd0aW1lc2NhbGVkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgUE9TVEdSRVNfVVNFUj0ke3VzZXJuYW1lfWAsXHJcbiAgICAgICAgICAgICAgICBgUE9TVEdSRVNfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICAgICAgYFBPU1RHUkVTX0RCPSR7ZGF0YWJhc2V9YCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdteXNxbCc6XHJcbiAgICAgICAgY2FzZSAnbWFyaWFkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgTVlTUUxfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgICAgICBgTVlTUUxfREFUQUJBU0U9JHtkYXRhYmFzZX1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ21vbmdvZGInOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgYE1PTkdPX0lOSVREQl9ST09UX1VTRVJOQU1FPSR7dXNlcm5hbWV9YCxcclxuICAgICAgICAgICAgICAgIGBNT05HT19JTklUREJfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSAncmVkaXMnOlxyXG4gICAgICAgICAgICByZXR1cm4gW2BSRURJU19QQVNTV09SRD0ke3Bhc3N3b3JkfWBdO1xyXG4gICAgICAgIGNhc2UgJ21zc3FsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICdBQ0NFUFRfRVVMQT1ZJyxcclxuICAgICAgICAgICAgICAgIGBNU1NRTF9TQV9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSAnbmVvNGonOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgYE5FTzRKX0FVVEg9JHt1c2VybmFtZX0vJHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2VsYXN0aWNzZWFyY2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgJ2Rpc2NvdmVyeS50eXBlPXNpbmdsZS1ub2RlJyxcclxuICAgICAgICAgICAgICAgIGBFTEFTVElDX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgICd4cGFjay5zZWN1cml0eS5lbmFibGVkPWZhbHNlJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdvcGVuc2VhcmNoJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICdkaXNjb3ZlcnkudHlwZT1zaW5nbGUtbm9kZScsXHJcbiAgICAgICAgICAgICAgICBgT1BFTlNFQVJDSF9JTklUSUFMX0FETUlOX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgICdwbHVnaW5zLnNlY3VyaXR5LmRpc2FibGVkPXRydWUnLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2luZmx1eGRiJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBET0NLRVJfSU5GTFVYREJfSU5JVF9VU0VSTkFNRT0ke3VzZXJuYW1lfWAsXHJcbiAgICAgICAgICAgICAgICBgRE9DS0VSX0lORkxVWERCX0lOSVRfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICAgICAgYERPQ0tFUl9JTkZMVVhEQl9JTklUX09SRz1ib3NkYmAsXHJcbiAgICAgICAgICAgICAgICBgRE9DS0VSX0lORkxVWERCX0lOSVRfQlVDS0VUPSR7ZGF0YWJhc2V9YCxcclxuICAgICAgICAgICAgICAgICdET0NLRVJfSU5GTFVYREJfSU5JVF9NT0RFPXNldHVwJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdyYWJiaXRtcSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgUkFCQklUTVFfREVGQVVMVF9VU0VSPSR7dXNlcm5hbWV9YCxcclxuICAgICAgICAgICAgICAgIGBSQUJCSVRNUV9ERUZBVUxUX1BBU1M9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ21pbmlvJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBNSU5JT19ST09UX1VTRVI9JHt1c2VybmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgYE1JTklPX1JPT1RfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ29yYWNsZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgT1JBQ0xFX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgICAgIGBPUkFDTEVfREFUQUJBU0U9JHtkYXRhYmFzZX1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2ZpcmViaXJkJzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGBJU0NfUEFTU1dPUkQ9JHtwYXNzd29yZH1gLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGNhc2UgJ2NvdWNoYmFzZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgQ09VQ0hCQVNFX0FETUlOSVNUUkFUT1JfVVNFUk5BTUU9JHt1c2VybmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgYENPVUNIQkFTRV9BRE1JTklTVFJBVE9SX1BBU1NXT1JEPSR7cGFzc3dvcmR9YCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBjYXNlICdvcmllbnRkYic6XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBgT1JJRU5UREJfUk9PVF9QQVNTV09SRD0ke3Bhc3N3b3JkfWAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHVsbCBEb2NrZXIgaW1hZ2UgYW5kIHN0YXJ0IGRhdGFiYXNlIGNvbnRhaW5lclxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1bGxBbmRTdGFydERhdGFiYXNlKFxyXG4gICAgdHlwZTogRGF0YWJhc2VUeXBlLFxyXG4gICAgbmFtZTogc3RyaW5nLFxyXG4gICAgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyxcclxuICAgIGF1dG9TdGFydDogYm9vbGVhbiA9IHRydWUsXHJcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbFxyXG4pOiBQcm9taXNlPERvY2tlckRhdGFiYXNlPiB7XHJcbiAgICBjb25zdCBpbWFnZSA9IERPQ0tFUl9JTUFHRVNbdHlwZV07XHJcbiAgICBpZiAoIWltYWdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSB0eXBlOiAke3R5cGV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBDaGVja2luZyBpZiBpbWFnZSAke2ltYWdlfSBleGlzdHMgbG9jYWx5Li4uYCk7XHJcbiAgICBjb25zdCBpbWFnZXMgPSBhd2FpdCBkb2NrZXIubGlzdEltYWdlcygpO1xyXG4gICAgY29uc3QgaW1hZ2VFeGlzdHMgPSBpbWFnZXMuc29tZShpbWcgPT4gaW1nLlJlcG9UYWdzPy5pbmNsdWRlcyhpbWFnZSkpO1xyXG5cclxuICAgIGlmICghaW1hZ2VFeGlzdHMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gUHVsbGluZyBpbWFnZSAke2ltYWdlfS4uLmApO1xyXG5cclxuICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHB1bGxTdHJlYW06IGFueTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwdWxsU3RyZWFtICYmIHB1bGxTdHJlYW0uZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1bGxTdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaWduYWwpIHtcclxuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRvY2tlci5wdWxsKGltYWdlLCAoZXJyOiBhbnksIHN0cmVhbTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwdWxsU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgZG9ja2VyLm1vZGVtLmZvbGxvd1Byb2dyZXNzKHN0cmVhbSwgKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHJlamVjdChuZXcgRXJyb3IoJ1Byb3Zpc2lvbmluZyBjYW5jZWxsZWQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlzaW9uaW5nIGNhbmNlbGxlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEltYWdlICR7aW1hZ2V9IHB1bGxlZCBzdWNjZXNzZnVsbHlgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEltYWdlICR7aW1hZ2V9IGFscmVhZHkgZXhpc3RzLCBza2lwcGluZyBwdWxsYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgZGF0YWJhc2UgSUQgYW5kIGNyZWRlbnRpYWxzXHJcbiAgICBjb25zdCBpZCA9IGAke3R5cGV9XyR7bmFtZX1fJHtEYXRlLm5vdygpfWAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV9dL2csICdfJyk7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGdlbmVyYXRlQ3JlZGVudGlhbHModHlwZSwgbmFtZSk7XHJcbiAgICBjb25zdCBkZWZhdWx0UG9ydCA9IFBPUlRfUkFOR0VTW3R5cGVdIHx8IDU0MzI7XHJcbiAgICBjb25zdCBwb3J0ID0gYXdhaXQgZmluZEF2YWlsYWJsZVBvcnQoZGVmYXVsdFBvcnQpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBjb250YWluZXIgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgZW52ID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXModHlwZSwgY3JlZGVudGlhbHMpO1xyXG4gICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGBib3NkYl8ke2lkfWA7XHJcblxyXG4gICAgY29uc3QgY3JlYXRlT3B0aW9uczogYW55ID0ge1xyXG4gICAgICAgIEltYWdlOiBpbWFnZSxcclxuICAgICAgICBuYW1lOiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgIEVudjogZW52LFxyXG4gICAgICAgIEhvc3RDb25maWc6IHtcclxuICAgICAgICAgICAgUG9ydEJpbmRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBbYCR7ZGVmYXVsdFBvcnR9L3RjcGBdOiBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQpIH1dLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBSZXN0YXJ0UG9saWN5OiBhdXRvU3RhcnQgPyB7IE5hbWU6ICd1bmxlc3Mtc3RvcHBlZCcgfSA6IHsgTmFtZTogJ25vJyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTGFiZWxzOiB7XHJcbiAgICAgICAgICAgICdib3NkYi5tYW5hZ2VkJzogJ3RydWUnLFxyXG4gICAgICAgICAgICAnYm9zZGIudHlwZSc6IHR5cGUsXHJcbiAgICAgICAgICAgICdib3NkYi5vcmdhbml6YXRpb24nOiBvcmdhbml6YXRpb25JZCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTcGVjaWFsIGNvbmZpZ3VyYXRpb25zIGZvciBzcGVjaWZpYyBkYXRhYmFzZXNcclxuICAgIGlmICh0eXBlID09PSAnbWluaW8nKSB7XHJcbiAgICAgICAgY3JlYXRlT3B0aW9ucy5DbWQgPSBbJ3NlcnZlcicsICcvZGF0YScsICctLWNvbnNvbGUtYWRkcmVzcycsICc6OTAwMSddO1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzkwMDEvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxKSB9XTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25lbzRqJykge1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzc0NzQvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxKSB9XTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvY2tyb2FjaGRiJykge1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuQ21kID0gWydzdGFydC1zaW5nbGUtbm9kZScsICctLWluc2VjdXJlJ107XHJcbiAgICAgICAgY3JlYXRlT3B0aW9ucy5Ib3N0Q29uZmlnLlBvcnRCaW5kaW5nc1snMjYyNTcvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQpIH1dO1xyXG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuSG9zdENvbmZpZy5Qb3J0QmluZGluZ3NbJzgwODAvdGNwJ10gPSBbeyBIb3N0UG9ydDogU3RyaW5nKHBvcnQgKyAxMDApIH1dO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBDcmVhdGluZyBjb250YWluZXIgJHtjb250YWluZXJOYW1lfS4uLmApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgc3RhcnQgY29udGFpbmVyXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBhd2FpdCBkb2NrZXIuY3JlYXRlQ29udGFpbmVyKGNyZWF0ZU9wdGlvbnMpO1xyXG4gICAgY29uc3QgY29udGFpbmVySWQgPSBjb250YWluZXIuaWQ7XHJcblxyXG4gICAgaWYgKGF1dG9TdGFydCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBTdGFydGluZyBjb250YWluZXIgJHtjb250YWluZXJOYW1lfS4uLmApO1xyXG4gICAgICAgIGF3YWl0IGNvbnRhaW5lci5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBkYXRhYmFzZSByZWNvcmRcclxuICAgIGNvbnN0IGRhdGFiYXNlOiBEb2NrZXJEYXRhYmFzZSA9IHtcclxuICAgICAgICBpZCxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgcG9ydCxcclxuICAgICAgICB1c2VybmFtZTogY3JlZGVudGlhbHMudXNlcm5hbWUsXHJcbiAgICAgICAgcGFzc3dvcmQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxyXG4gICAgICAgIGRhdGFiYXNlOiBjcmVkZW50aWFscy5kYXRhYmFzZSxcclxuICAgICAgICBzdGF0dXM6IGF1dG9TdGFydCA/ICdydW5uaW5nJyA6ICdzdG9wcGVkJyxcclxuICAgICAgICBhdXRvU3RhcnQsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgbGFzdFVzZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBJbml0aWFsaXplIGFjdGl2aXR5XHJcbiAgICAgICAgb3JnYW5pemF0aW9uSWQsXHJcbiAgICAgICAgY29udGFpbmVySWQsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNhdmUgdG8gc3RvcmFnZVxyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBkYXRhYmFzZXMucHVzaChkYXRhYmFzZSk7XHJcbiAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCBkYXRhYmFzZXMpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBbRG9ja2VyXSBEYXRhYmFzZSAke2lkfSBjcmVhdGVkIHN1Y2Nlc3NmdWxseWApO1xyXG5cclxuICAgIHJldHVybiBkYXRhYmFzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0YXJ0IGEgc3RvcHBlZCBkYXRhYmFzZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0RGF0YWJhc2UoaWQ6IHN0cmluZywgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IGRhdGFiYXNlcy5maW5kKGRiID0+IGRiLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJHtpZH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZS5jb250YWluZXJJZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyIElEIG5vdCBmb3VuZCBmb3IgZGF0YWJhc2UgJHtpZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgIGF3YWl0IGNvbnRhaW5lci5zdGFydCgpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgYW5kIGFjdGl2aXR5XHJcbiAgICBkYXRhYmFzZS5zdGF0dXMgPSAncnVubmluZyc7XHJcbiAgICBkYXRhYmFzZS5sYXN0VXNlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCwgZGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gc3RhcnRlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogU3RvcCBhIHJ1bm5pbmcgZGF0YWJhc2VcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9wRGF0YWJhc2UoaWQ6IHN0cmluZywgb3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZSA9IGRhdGFiYXNlcy5maW5kKGRiID0+IGRiLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJHtpZH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFkYXRhYmFzZS5jb250YWluZXJJZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyIElEIG5vdCBmb3VuZCBmb3IgZGF0YWJhc2UgJHtpZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgIGF3YWl0IGNvbnRhaW5lci5zdG9wKCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHN0YXR1c1xyXG4gICAgZGF0YWJhc2Uuc3RhdHVzID0gJ3N0b3BwZWQnO1xyXG4gICAgc2F2ZURvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCwgZGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gc3RvcHBlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgZGF0YWJhc2UgYW5kIGl0cyBjb250YWluZXJcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVEYXRhYmFzZShpZDogc3RyaW5nLCBvcmdhbml6YXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBkYXRhYmFzZXMgPSBsb2FkRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkKTtcclxuICAgIGNvbnN0IGRhdGFiYXNlID0gZGF0YWJhc2VzLmZpbmQoZGIgPT4gZGIuaWQgPT09IGlkKTtcclxuXHJcbiAgICBpZiAoIWRhdGFiYXNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSAke2lkfSBub3QgZm91bmRgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YWJhc2UuY29udGFpbmVySWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgICAgICAgICAgLy8gU3RvcCBpZiBydW5uaW5nXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb250YWluZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIG1pZ2h0IGFscmVhZHkgYmUgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb250YWluZXJcclxuICAgICAgICAgICAgYXdhaXQgY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byByZW1vdmUgY29udGFpbmVyIGZvciAke2lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBmcm9tIHN0b3JhZ2VcclxuICAgIGNvbnN0IHVwZGF0ZWREYXRhYmFzZXMgPSBkYXRhYmFzZXMuZmlsdGVyKGRiID0+IGRiLmlkICE9PSBpZCk7XHJcbiAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCB1cGRhdGVkRGF0YWJhc2VzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgW0RvY2tlcl0gRGF0YWJhc2UgJHtpZH0gcmVtb3ZlZGApO1xyXG59XHJcblxyXG4vKipcclxuICogU3luYyBkYXRhYmFzZSBzdGF0dXMgd2l0aCBhY3R1YWwgRG9ja2VyIGNvbnRhaW5lcnNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jRGF0YWJhc2VTdGF0dXMob3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhvcmdhbml6YXRpb25JZCk7XHJcbiAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAoY29uc3QgZGF0YWJhc2Ugb2YgZGF0YWJhc2VzKSB7XHJcbiAgICAgICAgaWYgKGRhdGFiYXNlLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2NrZXIuZ2V0Q29udGFpbmVyKGRhdGFiYXNlLmNvbnRhaW5lcklkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBjb250YWluZXIuaW5zcGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gaW5mby5TdGF0ZS5SdW5uaW5nID8gJ3J1bm5pbmcnIDogJ3N0b3BwZWQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhYmFzZS5zdGF0dXMgIT09IG5ld1N0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlLnN0YXR1cyA9IG5ld1N0YXR1cztcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBnZXQgc3RhdHVzIGZvciAke2RhdGFiYXNlLmlkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBkYXRhYmFzZS5zdGF0dXMgPSAnZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwZGF0ZWQpIHtcclxuICAgICAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKG9yZ2FuaXphdGlvbklkLCBkYXRhYmFzZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBsYXN0IHVzZWQgdGltZXN0YW1wIGZvciBhIGRhdGFiYXNlIGJ5IGl0cyBwb3J0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGF0YWJhc2VBY3Rpdml0eShwb3J0OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGRhdGFiYXNlcyA9IGdldEFsbERvY2tlckRhdGFiYXNlcygpO1xyXG4gICAgY29uc3QgZGIgPSBkYXRhYmFzZXMuZmluZChkID0+IGQucG9ydCA9PT0gcG9ydCk7XHJcblxyXG4gICAgaWYgKGRiKSB7XHJcbiAgICAgICAgZGIubGFzdFVzZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgd2hpY2ggb3JnIGl0IGJlbG9uZ3MgdG8gZm9yIHNhdmluZ1xyXG4gICAgICAgIGNvbnN0IG9yZ0RhdGFiYXNlcyA9IGxvYWREb2NrZXJEYXRhYmFzZXMoZGIub3JnYW5pemF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IG9yZ0RiID0gb3JnRGF0YWJhc2VzLmZpbmQoZCA9PiBkLmlkID09PSBkYi5pZCk7XHJcbiAgICAgICAgaWYgKG9yZ0RiKSB7XHJcbiAgICAgICAgICAgIG9yZ0RiLmxhc3RVc2VkQXQgPSBkYi5sYXN0VXNlZEF0O1xyXG4gICAgICAgICAgICBzYXZlRG9ja2VyRGF0YWJhc2VzKGRiLm9yZ2FuaXphdGlvbklkLCBvcmdEYXRhYmFzZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSBhIGRhdGFiYXNlIGlzIHN0YXJ0ZWQgaWYgaXQncyBjdXJyZW50bHkgc3RvcHBlZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZURhdGFiYXNlU3RhcnRlZChwb3J0OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGRhdGFiYXNlcyA9IGdldEFsbERvY2tlckRhdGFiYXNlcygpO1xyXG4gICAgY29uc3QgZGIgPSBkYXRhYmFzZXMuZmluZChkID0+IGQucG9ydCA9PT0gcG9ydCk7XHJcblxyXG4gICAgaWYgKGRiICYmIGRiLnN0YXR1cyA9PT0gJ3N0b3BwZWQnICYmIGRiLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIEF1dG8tYXdha2VuaW5nIGRhdGFiYXNlICR7ZGIuaWR9IG9uIHBvcnQgJHtkYi5wb3J0fS4uLmApO1xyXG4gICAgICAgIGF3YWl0IHN0YXJ0RGF0YWJhc2UoZGIuaWQsIGRiLm9yZ2FuaXphdGlvbklkKTtcclxuICAgICAgICAvLyBXYWl0IGEgYml0IGZvciB0aGUgREIgdG8gYmUgcmVhZHlcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQmFja2dyb3VuZCBjaGVjayBmb3IgaWRsZSBkYXRhYmFzZXMgdG8gc3RvcCB0aGVtIChBdXRvLVNsZWVwKVxyXG4gKi9cclxubGV0IGlkbGVDaGVja0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG5jb25zdCBJRExFX1RJTUVPVVRfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SWRsZVRpbWVvdXRDaGVjaygpIHtcclxuICAgIGlmIChpZGxlQ2hlY2tJbnRlcnZhbCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdbRG9ja2VyXSBTdGFydGluZyBiYWNrZ3JvdW5kIGlkbGUgdGltZW91dCBjaGVjayAoMTAgbWluKS4uLicpO1xyXG4gICAgaWRsZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YWJhc2VzID0gZ2V0QWxsRG9ja2VyRGF0YWJhc2VzKCk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBkYiBvZiBkYXRhYmFzZXMpIHtcclxuICAgICAgICAgICAgaWYgKGRiLnN0YXR1cyA9PT0gJ3J1bm5pbmcnICYmIGRiLmxhc3RVc2VkQXQgJiYgZGIuY29udGFpbmVySWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RVc2VkID0gbmV3IERhdGUoZGIubGFzdFVzZWRBdCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RVc2VkID4gSURMRV9USU1FT1VUX01TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtEb2NrZXJdIERhdGFiYXNlICR7ZGIuaWR9IG9uIHBvcnQgJHtkYi5wb3J0fSBpcyBpZGxlIGZvciA+MTBtLiBTbGVlcGluZy4uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0b3BEYXRhYmFzZShkYi5pZCwgZGIub3JnYW5pemF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtEb2NrZXJdIEZhaWxlZCB0byBhdXRvLXNsZWVwIGRhdGFiYXNlICR7ZGIuaWR9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGIuc3RhdHVzID09PSAncnVubmluZycgJiYgIWRiLmxhc3RVc2VkQXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgbGFzdFVzZWRBdCBpZiBtaXNzaW5nIHNvIGl0IGNhbiBldmVudHVhbGx5IHNsZWVwXHJcbiAgICAgICAgICAgICAgICBkYi5sYXN0VXNlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnRGF0YWJhc2VzID0gbG9hZERvY2tlckRhdGFiYXNlcyhkYi5vcmdhbml6YXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdEYiA9IG9yZ0RhdGFiYXNlcy5maW5kKGQgPT4gZC5pZCA9PT0gZGIuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yZ0RiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JnRGIubGFzdFVzZWRBdCA9IGRiLmxhc3RVc2VkQXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZURvY2tlckRhdGFiYXNlcyhkYi5vcmdhbml6YXRpb25JZCwgb3JnRGF0YWJhc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIDYwMDAwKTsgLy8gQ2hlY2sgZXZlcnkgbWludXRlXHJcbn1cclxuXHJcbi8vIFN0YXJ0IHRoZSBjaGVjayBhdXRvbWF0aWNhbGx5XHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgc3RhcnRJZGxlVGltZW91dENoZWNrKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkRvY2tlciIsImZzIiwicGF0aCIsImRvY2tlciIsIlNUT1JBR0VfRElSIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiUE9SVF9SQU5HRVMiLCJwb3N0Z3JlcyIsIm15c3FsIiwibWFyaWFkYiIsIm1vbmdvZGIiLCJyZWRpcyIsIm1zc3FsIiwib3JhY2xlIiwiY2Fzc2FuZHJhIiwibmVvNGoiLCJlbGFzdGljc2VhcmNoIiwiY2xpY2tob3VzZSIsImluZmx1eGRiIiwiZmlyZWJpcmQiLCJjdWJyaWQiLCJjb3VjaGJhc2UiLCJvcmllbnRkYiIsInJhYmJpdG1xIiwibWluaW8iLCJET0NLRVJfSU1BR0VTIiwib3BlbnNlYXJjaCIsInRpbWVzY2FsZWRiIiwiY29ja3JvYWNoZGIiLCJ5dWdhYnl0ZSIsInRpZGIiLCJzY3lsbGFkYiIsImZlcnJldGRiIiwiY291Y2hkYiIsInNvbHIiLCJtZW1jYWNoZWQiLCJzdXJyZWFsZGIiLCJoMiIsInByb21ldGhldXMiLCJjaGVja0RvY2tlckF2YWlsYWJsZSIsInBpbmciLCJlcnJvciIsImNvbnNvbGUiLCJmaW5kQXZhaWxhYmxlUG9ydCIsInN0YXJ0UG9ydCIsInVzZWRQb3J0cyIsImdldFVzZWRQb3J0cyIsInBvcnQiLCJoYXMiLCJkYXRhYmFzZXMiLCJnZXRBbGxEb2NrZXJEYXRhYmFzZXMiLCJTZXQiLCJtYXAiLCJkYiIsImdldFN0b3JhZ2VGaWxlUGF0aCIsIm9yZ2FuaXphdGlvbklkIiwibG9hZERvY2tlckRhdGFiYXNlcyIsImZpbGVQYXRoIiwiZGF0YSIsInJlYWRGaWxlU3luYyIsIkpTT04iLCJwYXJzZSIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWxlIiwiZW5kc1dpdGgiLCJvcmdEYXRhYmFzZXMiLCJwdXNoIiwic2F2ZURvY2tlckRhdGFiYXNlcyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJnZW5lcmF0ZUNyZWRlbnRpYWxzIiwidHlwZSIsIm5hbWUiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZGF0YWJhc2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImNyZWRlbnRpYWxzIiwicHVsbEFuZFN0YXJ0RGF0YWJhc2UiLCJhdXRvU3RhcnQiLCJzaWduYWwiLCJpbWFnZSIsIkVycm9yIiwiYWJvcnRlZCIsImxvZyIsImltYWdlcyIsImxpc3RJbWFnZXMiLCJpbWFnZUV4aXN0cyIsInNvbWUiLCJpbWciLCJSZXBvVGFncyIsImluY2x1ZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwdWxsU3RyZWFtIiwiYWJvcnRIYW5kbGVyIiwiZGVzdHJveSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdWxsIiwiZXJyIiwic3RyZWFtIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vZGVtIiwiZm9sbG93UHJvZ3Jlc3MiLCJpZCIsIkRhdGUiLCJub3ciLCJkZWZhdWx0UG9ydCIsImVudiIsImNvbnRhaW5lck5hbWUiLCJjcmVhdGVPcHRpb25zIiwiSW1hZ2UiLCJFbnYiLCJIb3N0Q29uZmlnIiwiUG9ydEJpbmRpbmdzIiwiSG9zdFBvcnQiLCJTdHJpbmciLCJSZXN0YXJ0UG9saWN5IiwiTmFtZSIsIkxhYmVscyIsIkNtZCIsImNvbnRhaW5lciIsImNyZWF0ZUNvbnRhaW5lciIsImNvbnRhaW5lcklkIiwic3RhcnQiLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImxhc3RVc2VkQXQiLCJzdGFydERhdGFiYXNlIiwiZmluZCIsImdldENvbnRhaW5lciIsInN0b3BEYXRhYmFzZSIsInN0b3AiLCJyZW1vdmVEYXRhYmFzZSIsInJlbW92ZSIsInVwZGF0ZWREYXRhYmFzZXMiLCJmaWx0ZXIiLCJzeW5jRGF0YWJhc2VTdGF0dXMiLCJ1cGRhdGVkIiwiaW5mbyIsImluc3BlY3QiLCJuZXdTdGF0dXMiLCJTdGF0ZSIsIlJ1bm5pbmciLCJ1cGRhdGVEYXRhYmFzZUFjdGl2aXR5IiwiZCIsIm9yZ0RiIiwiZW5zdXJlRGF0YWJhc2VTdGFydGVkIiwic2V0VGltZW91dCIsImlkbGVDaGVja0ludGVydmFsIiwiSURMRV9USU1FT1VUX01TIiwic3RhcnRJZGxlVGltZW91dENoZWNrIiwic2V0SW50ZXJ2YWwiLCJsYXN0VXNlZCIsImdldFRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/docker-manager.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/store.ts":
/*!**************************!*\
  !*** ./src/lib/store.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapterInstances: () => (/* binding */ adapterInstances),\n/* harmony export */   clearOrgCache: () => (/* binding */ clearOrgCache),\n/* harmony export */   connections: () => (/* binding */ connections),\n/* harmony export */   getAdapterInstances: () => (/* binding */ getAdapterInstances),\n/* harmony export */   getAdapterInstancesByOrg: () => (/* binding */ getAdapterInstancesByOrg),\n/* harmony export */   getConnection: () => (/* binding */ getConnection),\n/* harmony export */   getConnections: () => (/* binding */ getConnections),\n/* harmony export */   getConnectionsByOrg: () => (/* binding */ getConnectionsByOrg),\n/* harmony export */   saveConnections: () => (/* binding */ saveConnections),\n/* harmony export */   saveConnectionsByOrg: () => (/* binding */ saveConnectionsByOrg)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// Shared in-memory storage for connections and adapters\n// With organization-scoped file-based persistence\n\n\nconst DATA_DIR_NAME = \".bosdb-data\";\nconst LEGACY_STORAGE_FILE_NAME = \".bosdb-connections.json\";\n// Find project root (contains package.json)\n// Find monorepo root (contains package.json and apps directory)\nfunction findProjectRoot(current) {\n    let dir = current;\n    // Walk up until we find a directory with package.json and an 'apps' folder (monorepo root)\n    // or we hit the disk root\n    while(dir !== path__WEBPACK_IMPORTED_MODULE_1___default().parse(dir).root){\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(dir, \"package.json\")) && fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(dir, \"apps\"))) {\n            return dir;\n        }\n        dir = path__WEBPACK_IMPORTED_MODULE_1___default().dirname(dir);\n    }\n    return current; // Fallback to current\n}\nconst PROJECT_ROOT = findProjectRoot(process.cwd());\nconst DATA_DIR = path__WEBPACK_IMPORTED_MODULE_1___default().join(PROJECT_ROOT, DATA_DIR_NAME);\nconst ORGS_DIR = path__WEBPACK_IMPORTED_MODULE_1___default().join(DATA_DIR, \"orgs\");\nconsole.log(`[Store] Initialized with Project Root: ${PROJECT_ROOT}`);\nconst LEGACY_STORAGE_FILE = path__WEBPACK_IMPORTED_MODULE_1___default().join(PROJECT_ROOT, LEGACY_STORAGE_FILE_NAME);\nfunction getOrgDataDir(orgId) {\n    const orgDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(ORGS_DIR, orgId);\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(orgDir)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(orgDir, {\n            recursive: true\n        });\n    }\n    return orgDir;\n}\n// Get organization-specific connections file path\nfunction getConnectionsFilePath(orgId) {\n    const orgDir = getOrgDataDir(orgId);\n    return path__WEBPACK_IMPORTED_MODULE_1___default().join(orgDir, \"connections.json\");\n}\n// Load connections for a specific organization\nfunction loadConnectionsByOrg(orgId) {\n    try {\n        const filePath = getConnectionsFilePath(orgId);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(filePath)) {\n            const data = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(filePath, \"utf-8\");\n            const parsed = JSON.parse(data);\n            console.log(`[Store] Loaded ${Object.keys(parsed).length} connections for org ${orgId}`);\n            return new Map(Object.entries(parsed));\n        }\n    } catch (error) {\n        console.error(`[Store] Failed to load connections for org ${orgId}:`, error);\n    }\n    return new Map();\n}\n// Load connections from legacy file (for backward compatibility)\nfunction loadLegacyConnections() {\n    try {\n        // Migration: If root file doesn't exist, try to find it in common subdirectories and copy it over\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(LEGACY_STORAGE_FILE)) {\n            const possibleLocations = [\n                path__WEBPACK_IMPORTED_MODULE_1___default().join(PROJECT_ROOT, \"apps\", \"web\", LEGACY_STORAGE_FILE_NAME),\n                path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), LEGACY_STORAGE_FILE_NAME),\n                path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"apps\", \"web\", LEGACY_STORAGE_FILE_NAME)\n            ];\n            for (const loc of possibleLocations){\n                if (loc !== LEGACY_STORAGE_FILE && fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(loc)) {\n                    console.log(`[Store] Migrating legacy connections from ${loc} to ${LEGACY_STORAGE_FILE}`);\n                    try {\n                        const data = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(loc, \"utf-8\");\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(LEGACY_STORAGE_FILE, data);\n                        break;\n                    } catch (e) {\n                        console.error(`[Store] Migration from ${loc} failed:`, e);\n                    }\n                }\n            }\n        }\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(LEGACY_STORAGE_FILE)) {\n            const data = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(LEGACY_STORAGE_FILE, \"utf-8\");\n            const parsed = JSON.parse(data);\n            console.log(`[Store] Loaded ${Object.keys(parsed).length} connections from legacy file at ${LEGACY_STORAGE_FILE}`);\n            return new Map(Object.entries(parsed));\n        }\n    } catch (error) {\n        console.error(\"[Store] Failed to load legacy connections:\", error);\n    }\n    return new Map();\n}\n// Save connections for a specific organization\nfunction saveConnectionsByOrg(orgId, connections) {\n    try {\n        const filePath = getConnectionsFilePath(orgId);\n        const obj = Object.fromEntries(connections);\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(filePath, JSON.stringify(obj, null, 2));\n        console.log(`[Store] Saved ${connections.size} connections for org ${orgId}`);\n    } catch (error) {\n        console.error(`[Store] Failed to save connections for org ${orgId}:`, error);\n    }\n}\n// Save connections to legacy file (for backward compatibility)\nfunction saveConnections() {\n    try {\n        const obj = Object.fromEntries(getConnections());\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(LEGACY_STORAGE_FILE, JSON.stringify(obj, null, 2));\n        console.log(`[Store] Saved ${getConnections().size} connections to legacy file`);\n    } catch (error) {\n        console.error(\"[Store] Failed to save connections:\", error);\n    }\n}\n// Organization-scoped connection and adapter caches\nconst _orgConnections = new Map();\nconst _orgAdapterInstances = new Map();\n// Legacy single map (loads from legacy file)\nlet _legacyConnections = null;\nlet _legacyAdapterInstances = null;\n// Get connections for a specific organization\nfunction getConnectionsByOrg(orgId) {\n    if (!_orgConnections.has(orgId)) {\n        _orgConnections.set(orgId, loadConnectionsByOrg(orgId));\n    }\n    return _orgConnections.get(orgId);\n}\n// Get adapter instances for a specific organization\nfunction getAdapterInstancesByOrg(orgId) {\n    if (!_orgAdapterInstances.has(orgId)) {\n        _orgAdapterInstances.set(orgId, new Map());\n    }\n    return _orgAdapterInstances.get(orgId);\n}\n// Legacy: Get all connections (from legacy file)\nfunction getConnections() {\n    if (!_legacyConnections) {\n        _legacyConnections = loadLegacyConnections();\n    }\n    return _legacyConnections;\n}\n// Legacy: Get all adapter instances\nfunction getAdapterInstances() {\n    if (!_legacyAdapterInstances) {\n        _legacyAdapterInstances = new Map();\n    }\n    return _legacyAdapterInstances;\n}\n// Clear organization cache (for refresh)\nfunction clearOrgCache(orgId) {\n    _orgConnections.delete(orgId);\n    _orgAdapterInstances.delete(orgId);\n}\n// Legacy exports for compatibility - these now use lazy loading with proper Map delegation\nconst connections = new Proxy({}, {\n    get (_target, prop) {\n        const map = getConnections();\n        const value = map[prop];\n        if (typeof value === \"function\") {\n            return value.bind(map);\n        }\n        return map.get(prop);\n    },\n    set (_target, prop, value) {\n        getConnections().set(prop, value);\n        return true;\n    },\n    deleteProperty (_target, prop) {\n        return getConnections().delete(prop);\n    }\n});\nconst adapterInstances = new Proxy({}, {\n    get (_target, prop) {\n        const map = getAdapterInstances();\n        const value = map[prop];\n        if (typeof value === \"function\") {\n            return value.bind(map);\n        }\n        return map.get(prop);\n    },\n    set (_target, prop, value) {\n        getAdapterInstances().set(prop, value);\n        return true;\n    },\n    deleteProperty (_target, prop) {\n        return getAdapterInstances().delete(prop);\n    }\n});\nasync function getConnection(connectionId) {\n    const map = getConnections();\n    let conn = map.get(connectionId);\n    if (!conn) {\n        console.log(`[Store] Connection ${connectionId} not found in memory (size: ${map.size}), forcing reload...`);\n        _legacyConnections = loadLegacyConnections();\n        conn = _legacyConnections.get(connectionId);\n        if (!conn) {\n            console.log(`[Store] Connection ${connectionId} STILL not found after reload. Available IDs: ${Array.from(_legacyConnections.keys()).join(\", \")}`);\n        } else {\n            console.log(`[Store] Connection ${connectionId} found after reload!`);\n        }\n    }\n    return conn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVzRCxhQUFhLDRCQUE0QixFQUFFTixJQUFJbEIsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1FBQzNHSyxxQkFBcUJmO1FBQ3JCbUMsT0FBT3BCLG1CQUFtQkssR0FBRyxDQUFDYztRQUM5QixJQUFJLENBQUNDLE1BQU07WUFDUHhELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFc0QsYUFBYSw4Q0FBOEMsRUFBRUUsTUFBTUMsSUFBSSxDQUFDdEIsbUJBQW1CcEIsSUFBSSxJQUFJdkIsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNySixPQUFPO1lBQ0hPLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFc0QsYUFBYSxvQkFBb0IsQ0FBQztRQUN4RTtJQUNKO0lBQ0EsT0FBT0M7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi9zcmMvbGliL3N0b3JlLnRzP2FkMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hhcmVkIGluLW1lbW9yeSBzdG9yYWdlIGZvciBjb25uZWN0aW9ucyBhbmQgYWRhcHRlcnNcclxuLy8gV2l0aCBvcmdhbml6YXRpb24tc2NvcGVkIGZpbGUtYmFzZWQgcGVyc2lzdGVuY2VcclxuXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuY29uc3QgREFUQV9ESVJfTkFNRSA9ICcuYm9zZGItZGF0YSc7XHJcbmNvbnN0IExFR0FDWV9TVE9SQUdFX0ZJTEVfTkFNRSA9ICcuYm9zZGItY29ubmVjdGlvbnMuanNvbic7XHJcblxyXG4vLyBGaW5kIHByb2plY3Qgcm9vdCAoY29udGFpbnMgcGFja2FnZS5qc29uKVxyXG4vLyBGaW5kIG1vbm9yZXBvIHJvb3QgKGNvbnRhaW5zIHBhY2thZ2UuanNvbiBhbmQgYXBwcyBkaXJlY3RvcnkpXHJcbmZ1bmN0aW9uIGZpbmRQcm9qZWN0Um9vdChjdXJyZW50OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgbGV0IGRpciA9IGN1cnJlbnQ7XHJcbiAgICAvLyBXYWxrIHVwIHVudGlsIHdlIGZpbmQgYSBkaXJlY3Rvcnkgd2l0aCBwYWNrYWdlLmpzb24gYW5kIGFuICdhcHBzJyBmb2xkZXIgKG1vbm9yZXBvIHJvb3QpXHJcbiAgICAvLyBvciB3ZSBoaXQgdGhlIGRpc2sgcm9vdFxyXG4gICAgd2hpbGUgKGRpciAhPT0gcGF0aC5wYXJzZShkaXIpLnJvb3QpIHtcclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oZGlyLCAncGFja2FnZS5qc29uJykpICYmXHJcbiAgICAgICAgICAgIGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKGRpciwgJ2FwcHMnKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyID0gcGF0aC5kaXJuYW1lKGRpcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudDsgLy8gRmFsbGJhY2sgdG8gY3VycmVudFxyXG59XHJcblxyXG5jb25zdCBQUk9KRUNUX1JPT1QgPSBmaW5kUHJvamVjdFJvb3QocHJvY2Vzcy5jd2QoKSk7XHJcbmNvbnN0IERBVEFfRElSID0gcGF0aC5qb2luKFBST0pFQ1RfUk9PVCwgREFUQV9ESVJfTkFNRSk7XHJcbmNvbnN0IE9SR1NfRElSID0gcGF0aC5qb2luKERBVEFfRElSLCAnb3JncycpO1xyXG5cclxuY29uc29sZS5sb2coYFtTdG9yZV0gSW5pdGlhbGl6ZWQgd2l0aCBQcm9qZWN0IFJvb3Q6ICR7UFJPSkVDVF9ST09UfWApO1xyXG5cclxuY29uc3QgTEVHQUNZX1NUT1JBR0VfRklMRSA9IHBhdGguam9pbihQUk9KRUNUX1JPT1QsIExFR0FDWV9TVE9SQUdFX0ZJTEVfTkFNRSk7XHJcblxyXG5mdW5jdGlvbiBnZXRPcmdEYXRhRGlyKG9yZ0lkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgb3JnRGlyID0gcGF0aC5qb2luKE9SR1NfRElSLCBvcmdJZCk7XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMob3JnRGlyKSkge1xyXG4gICAgICAgIGZzLm1rZGlyU3luYyhvcmdEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yZ0RpcjtcclxufVxyXG5cclxuLy8gR2V0IG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBjb25uZWN0aW9ucyBmaWxlIHBhdGhcclxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbnNGaWxlUGF0aChvcmdJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG9yZ0RpciA9IGdldE9yZ0RhdGFEaXIob3JnSWQpO1xyXG4gICAgcmV0dXJuIHBhdGguam9pbihvcmdEaXIsICdjb25uZWN0aW9ucy5qc29uJyk7XHJcbn1cclxuXHJcbi8vIExvYWQgY29ubmVjdGlvbnMgZm9yIGEgc3BlY2lmaWMgb3JnYW5pemF0aW9uXHJcbmZ1bmN0aW9uIGxvYWRDb25uZWN0aW9uc0J5T3JnKG9yZ0lkOiBzdHJpbmcpOiBNYXA8c3RyaW5nLCBhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBnZXRDb25uZWN0aW9uc0ZpbGVQYXRoKG9yZ0lkKTtcclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbU3RvcmVdIExvYWRlZCAke09iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RofSBjb25uZWN0aW9ucyBmb3Igb3JnICR7b3JnSWR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHBhcnNlZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1N0b3JlXSBGYWlsZWQgdG8gbG9hZCBjb25uZWN0aW9ucyBmb3Igb3JnICR7b3JnSWR9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTWFwKCk7XHJcbn1cclxuXHJcbi8vIExvYWQgY29ubmVjdGlvbnMgZnJvbSBsZWdhY3kgZmlsZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcbmZ1bmN0aW9uIGxvYWRMZWdhY3lDb25uZWN0aW9ucygpOiBNYXA8c3RyaW5nLCBhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gTWlncmF0aW9uOiBJZiByb290IGZpbGUgZG9lc24ndCBleGlzdCwgdHJ5IHRvIGZpbmQgaXQgaW4gY29tbW9uIHN1YmRpcmVjdG9yaWVzIGFuZCBjb3B5IGl0IG92ZXJcclxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoTEVHQUNZX1NUT1JBR0VfRklMRSkpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVMb2NhdGlvbnMgPSBbXHJcbiAgICAgICAgICAgICAgICBwYXRoLmpvaW4oUFJPSkVDVF9ST09ULCAnYXBwcycsICd3ZWInLCBMRUdBQ1lfU1RPUkFHRV9GSUxFX05BTUUpLFxyXG4gICAgICAgICAgICAgICAgcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIExFR0FDWV9TVE9SQUdFX0ZJTEVfTkFNRSksXHJcbiAgICAgICAgICAgICAgICBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2FwcHMnLCAnd2ViJywgTEVHQUNZX1NUT1JBR0VfRklMRV9OQU1FKSxcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9jIG9mIHBvc3NpYmxlTG9jYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jICE9PSBMRUdBQ1lfU1RPUkFHRV9GSUxFICYmIGZzLmV4aXN0c1N5bmMobG9jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbU3RvcmVdIE1pZ3JhdGluZyBsZWdhY3kgY29ubmVjdGlvbnMgZnJvbSAke2xvY30gdG8gJHtMRUdBQ1lfU1RPUkFHRV9GSUxFfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMobG9jLCAndXRmLTgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhMRUdBQ1lfU1RPUkFHRV9GSUxFLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbU3RvcmVdIE1pZ3JhdGlvbiBmcm9tICR7bG9jfSBmYWlsZWQ6YCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhMRUdBQ1lfU1RPUkFHRV9GSUxFKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKExFR0FDWV9TVE9SQUdFX0ZJTEUsICd1dGYtOCcpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1N0b3JlXSBMb2FkZWQgJHtPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aH0gY29ubmVjdGlvbnMgZnJvbSBsZWdhY3kgZmlsZSBhdCAke0xFR0FDWV9TVE9SQUdFX0ZJTEV9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHBhcnNlZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N0b3JlXSBGYWlsZWQgdG8gbG9hZCBsZWdhY3kgY29ubmVjdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcclxufVxyXG5cclxuLy8gU2F2ZSBjb25uZWN0aW9ucyBmb3IgYSBzcGVjaWZpYyBvcmdhbml6YXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVDb25uZWN0aW9uc0J5T3JnKG9yZ0lkOiBzdHJpbmcsIGNvbm5lY3Rpb25zOiBNYXA8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZ2V0Q29ubmVjdGlvbnNGaWxlUGF0aChvcmdJZCk7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmZyb21FbnRyaWVzKGNvbm5lY3Rpb25zKTtcclxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgW1N0b3JlXSBTYXZlZCAke2Nvbm5lY3Rpb25zLnNpemV9IGNvbm5lY3Rpb25zIGZvciBvcmcgJHtvcmdJZH1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1N0b3JlXSBGYWlsZWQgdG8gc2F2ZSBjb25uZWN0aW9ucyBmb3Igb3JnICR7b3JnSWR9OmAsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gU2F2ZSBjb25uZWN0aW9ucyB0byBsZWdhY3kgZmlsZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcbmV4cG9ydCBmdW5jdGlvbiBzYXZlQ29ubmVjdGlvbnMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRDb25uZWN0aW9ucygpKTtcclxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKExFR0FDWV9TVE9SQUdFX0ZJTEUsIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMikpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbU3RvcmVdIFNhdmVkICR7Z2V0Q29ubmVjdGlvbnMoKS5zaXplfSBjb25uZWN0aW9ucyB0byBsZWdhY3kgZmlsZWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3RvcmVdIEZhaWxlZCB0byBzYXZlIGNvbm5lY3Rpb25zOicsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gT3JnYW5pemF0aW9uLXNjb3BlZCBjb25uZWN0aW9uIGFuZCBhZGFwdGVyIGNhY2hlc1xyXG5jb25zdCBfb3JnQ29ubmVjdGlvbnM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIGFueT4+ID0gbmV3IE1hcCgpO1xyXG5jb25zdCBfb3JnQWRhcHRlckluc3RhbmNlczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgYW55Pj4gPSBuZXcgTWFwKCk7XHJcblxyXG4vLyBMZWdhY3kgc2luZ2xlIG1hcCAobG9hZHMgZnJvbSBsZWdhY3kgZmlsZSlcclxubGV0IF9sZWdhY3lDb25uZWN0aW9uczogTWFwPHN0cmluZywgYW55PiB8IG51bGwgPSBudWxsO1xyXG5sZXQgX2xlZ2FjeUFkYXB0ZXJJbnN0YW5jZXM6IE1hcDxzdHJpbmcsIGFueT4gfCBudWxsID0gbnVsbDtcclxuXHJcbi8vIEdldCBjb25uZWN0aW9ucyBmb3IgYSBzcGVjaWZpYyBvcmdhbml6YXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbm5lY3Rpb25zQnlPcmcob3JnSWQ6IHN0cmluZyk6IE1hcDxzdHJpbmcsIGFueT4ge1xyXG4gICAgaWYgKCFfb3JnQ29ubmVjdGlvbnMuaGFzKG9yZ0lkKSkge1xyXG4gICAgICAgIF9vcmdDb25uZWN0aW9ucy5zZXQob3JnSWQsIGxvYWRDb25uZWN0aW9uc0J5T3JnKG9yZ0lkKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX29yZ0Nvbm5lY3Rpb25zLmdldChvcmdJZCkhO1xyXG59XHJcblxyXG4vLyBHZXQgYWRhcHRlciBpbnN0YW5jZXMgZm9yIGEgc3BlY2lmaWMgb3JnYW5pemF0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGFwdGVySW5zdGFuY2VzQnlPcmcob3JnSWQ6IHN0cmluZyk6IE1hcDxzdHJpbmcsIGFueT4ge1xyXG4gICAgaWYgKCFfb3JnQWRhcHRlckluc3RhbmNlcy5oYXMob3JnSWQpKSB7XHJcbiAgICAgICAgX29yZ0FkYXB0ZXJJbnN0YW5jZXMuc2V0KG9yZ0lkLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9vcmdBZGFwdGVySW5zdGFuY2VzLmdldChvcmdJZCkhO1xyXG59XHJcblxyXG4vLyBMZWdhY3k6IEdldCBhbGwgY29ubmVjdGlvbnMgKGZyb20gbGVnYWN5IGZpbGUpXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25uZWN0aW9ucygpOiBNYXA8c3RyaW5nLCBhbnk+IHtcclxuICAgIGlmICghX2xlZ2FjeUNvbm5lY3Rpb25zKSB7XHJcbiAgICAgICAgX2xlZ2FjeUNvbm5lY3Rpb25zID0gbG9hZExlZ2FjeUNvbm5lY3Rpb25zKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2xlZ2FjeUNvbm5lY3Rpb25zO1xyXG59XHJcblxyXG4vLyBMZWdhY3k6IEdldCBhbGwgYWRhcHRlciBpbnN0YW5jZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkYXB0ZXJJbnN0YW5jZXMoKTogTWFwPHN0cmluZywgYW55PiB7XHJcbiAgICBpZiAoIV9sZWdhY3lBZGFwdGVySW5zdGFuY2VzKSB7XHJcbiAgICAgICAgX2xlZ2FjeUFkYXB0ZXJJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2xlZ2FjeUFkYXB0ZXJJbnN0YW5jZXM7XHJcbn1cclxuXHJcbi8vIENsZWFyIG9yZ2FuaXphdGlvbiBjYWNoZSAoZm9yIHJlZnJlc2gpXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhck9yZ0NhY2hlKG9yZ0lkOiBzdHJpbmcpIHtcclxuICAgIF9vcmdDb25uZWN0aW9ucy5kZWxldGUob3JnSWQpO1xyXG4gICAgX29yZ0FkYXB0ZXJJbnN0YW5jZXMuZGVsZXRlKG9yZ0lkKTtcclxufVxyXG5cclxuLy8gTGVnYWN5IGV4cG9ydHMgZm9yIGNvbXBhdGliaWxpdHkgLSB0aGVzZSBub3cgdXNlIGxhenkgbG9hZGluZyB3aXRoIHByb3BlciBNYXAgZGVsZWdhdGlvblxyXG5leHBvcnQgY29uc3QgY29ubmVjdGlvbnMgPSBuZXcgUHJveHkoe30gYXMgTWFwPHN0cmluZywgYW55Piwge1xyXG4gICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBnZXRDb25uZWN0aW9ucygpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gKG1hcCBhcyBhbnkpW3Byb3BdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQobWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQocHJvcCBhcyBzdHJpbmcpO1xyXG4gICAgfSxcclxuICAgIHNldChfdGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xyXG4gICAgICAgIGdldENvbm5lY3Rpb25zKCkuc2V0KHByb3AgYXMgc3RyaW5nLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkoX3RhcmdldCwgcHJvcCkge1xyXG4gICAgICAgIHJldHVybiBnZXRDb25uZWN0aW9ucygpLmRlbGV0ZShwcm9wIGFzIHN0cmluZyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkYXB0ZXJJbnN0YW5jZXMgPSBuZXcgUHJveHkoe30gYXMgTWFwPHN0cmluZywgYW55Piwge1xyXG4gICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBnZXRBZGFwdGVySW5zdGFuY2VzKCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSAobWFwIGFzIGFueSlbcHJvcF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZChtYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFwLmdldChwcm9wIGFzIHN0cmluZyk7XHJcbiAgICB9LFxyXG4gICAgc2V0KF90YXJnZXQsIHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgZ2V0QWRhcHRlckluc3RhbmNlcygpLnNldChwcm9wIGFzIHN0cmluZywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRlbGV0ZVByb3BlcnR5KF90YXJnZXQsIHByb3ApIHtcclxuICAgICAgICByZXR1cm4gZ2V0QWRhcHRlckluc3RhbmNlcygpLmRlbGV0ZShwcm9wIGFzIHN0cmluZyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3Rpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgY29uc3QgbWFwID0gZ2V0Q29ubmVjdGlvbnMoKTtcclxuICAgIGxldCBjb25uID0gbWFwLmdldChjb25uZWN0aW9uSWQpO1xyXG4gICAgaWYgKCFjb25uKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFtTdG9yZV0gQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kIGluIG1lbW9yeSAoc2l6ZTogJHttYXAuc2l6ZX0pLCBmb3JjaW5nIHJlbG9hZC4uLmApO1xyXG4gICAgICAgIF9sZWdhY3lDb25uZWN0aW9ucyA9IGxvYWRMZWdhY3lDb25uZWN0aW9ucygpO1xyXG4gICAgICAgIGNvbm4gPSBfbGVnYWN5Q29ubmVjdGlvbnMuZ2V0KGNvbm5lY3Rpb25JZCk7XHJcbiAgICAgICAgaWYgKCFjb25uKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbU3RvcmVdIENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IFNUSUxMIG5vdCBmb3VuZCBhZnRlciByZWxvYWQuIEF2YWlsYWJsZSBJRHM6ICR7QXJyYXkuZnJvbShfbGVnYWN5Q29ubmVjdGlvbnMua2V5cygpKS5qb2luKCcsICcpfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbU3RvcmVdIENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IGZvdW5kIGFmdGVyIHJlbG9hZCFgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29ubjtcclxufVxyXG4iXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiREFUQV9ESVJfTkFNRSIsIkxFR0FDWV9TVE9SQUdFX0ZJTEVfTkFNRSIsImZpbmRQcm9qZWN0Um9vdCIsImN1cnJlbnQiLCJkaXIiLCJwYXJzZSIsInJvb3QiLCJleGlzdHNTeW5jIiwiam9pbiIsImRpcm5hbWUiLCJQUk9KRUNUX1JPT1QiLCJwcm9jZXNzIiwiY3dkIiwiREFUQV9ESVIiLCJPUkdTX0RJUiIsImNvbnNvbGUiLCJsb2ciLCJMRUdBQ1lfU1RPUkFHRV9GSUxFIiwiZ2V0T3JnRGF0YURpciIsIm9yZ0lkIiwib3JnRGlyIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiZ2V0Q29ubmVjdGlvbnNGaWxlUGF0aCIsImxvYWRDb25uZWN0aW9uc0J5T3JnIiwiZmlsZVBhdGgiLCJkYXRhIiwicmVhZEZpbGVTeW5jIiwicGFyc2VkIiwiSlNPTiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJNYXAiLCJlbnRyaWVzIiwiZXJyb3IiLCJsb2FkTGVnYWN5Q29ubmVjdGlvbnMiLCJwb3NzaWJsZUxvY2F0aW9ucyIsImxvYyIsIndyaXRlRmlsZVN5bmMiLCJlIiwic2F2ZUNvbm5lY3Rpb25zQnlPcmciLCJjb25uZWN0aW9ucyIsIm9iaiIsImZyb21FbnRyaWVzIiwic3RyaW5naWZ5Iiwic2l6ZSIsInNhdmVDb25uZWN0aW9ucyIsImdldENvbm5lY3Rpb25zIiwiX29yZ0Nvbm5lY3Rpb25zIiwiX29yZ0FkYXB0ZXJJbnN0YW5jZXMiLCJfbGVnYWN5Q29ubmVjdGlvbnMiLCJfbGVnYWN5QWRhcHRlckluc3RhbmNlcyIsImdldENvbm5lY3Rpb25zQnlPcmciLCJoYXMiLCJzZXQiLCJnZXQiLCJnZXRBZGFwdGVySW5zdGFuY2VzQnlPcmciLCJnZXRBZGFwdGVySW5zdGFuY2VzIiwiY2xlYXJPcmdDYWNoZSIsImRlbGV0ZSIsIlByb3h5IiwiX3RhcmdldCIsInByb3AiLCJtYXAiLCJ2YWx1ZSIsImJpbmQiLCJkZWxldGVQcm9wZXJ0eSIsImFkYXB0ZXJJbnN0YW5jZXMiLCJnZXRDb25uZWN0aW9uIiwiY29ubmVjdGlvbklkIiwiY29ubiIsIkFycmF5IiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/store.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/vcs-helper.ts":
/*!*******************************!*\
  !*** ./src/lib/vcs-helper.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkoutBranch: () => (/* binding */ checkoutBranch),\n/* harmony export */   commitChanges: () => (/* binding */ commitChanges),\n/* harmony export */   createBranch: () => (/* binding */ createBranch),\n/* harmony export */   generateRollbackSQL: () => (/* binding */ generateRollbackSQL),\n/* harmony export */   getBranches: () => (/* binding */ getBranches),\n/* harmony export */   getCommitHistory: () => (/* binding */ getCommitHistory),\n/* harmony export */   getPendingChanges: () => (/* binding */ getPendingChanges),\n/* harmony export */   parseQueryForChanges: () => (/* binding */ parseQueryForChanges),\n/* harmony export */   trackChange: () => (/* binding */ trackChange),\n/* harmony export */   trackSchemaChange: () => (/* binding */ trackSchemaChange)\n/* harmony export */ });\n/**\r\n * VCS Integration Helper\r\n * Automatically tracks database changes for version control\r\n */ /**\r\n * Track a database change for version control\r\n */ async function trackChange(connectionId, change) {\n    try {\n        await fetch(\"/api/vcs/pending\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                change\n            })\n        });\n    } catch (error) {\n        console.error(\"Failed to track change:\", error);\n    }\n}\n/**\r\n * Track a schema change (CREATE, ALTER, DROP table)\r\n */ async function trackSchemaChange(connectionId, operation, tableName, sql, author) {\n    const change = {\n        type: \"SCHEMA\",\n        operation: operation.toUpperCase(),\n        target: tableName,\n        tableName,\n        description: `${operation.charAt(0).toUpperCase() + operation.slice(1)} table ${tableName} by ${author.name}`,\n        query: sql,\n        rollbackSQL: generateRollbackSQL(sql),\n        status: \"APPLIED\"\n    };\n    await trackChange(connectionId, change);\n}\n/**\r\n * Parse SQL query to detect change type\r\n */ function parseQueryForChanges(query, affectedRows) {\n    // Remove comments and trim\n    const cleanQuery = query.replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const normalizedQuery = cleanQuery.toUpperCase();\n    // Database / Schema changes\n    if (normalizedQuery.match(/\\bCREATE\\s+(DATABASE|SCHEMA)\\b/i)) {\n        const type = normalizedQuery.includes(\"DATABASE\") ? \"DATABASE\" : \"SCHEMA\";\n        const name = normalizedQuery.match(/\\bCREATE\\s+(?:DATABASE|SCHEMA)\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SYSTEM\",\n            operation: \"CREATE\",\n            target: name,\n            description: `Create ${type.toLowerCase()} ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bDROP\\s+(DATABASE|SCHEMA)\\b/i)) {\n        const type = normalizedQuery.includes(\"DATABASE\") ? \"DATABASE\" : \"SCHEMA\";\n        const name = normalizedQuery.match(/\\bDROP\\s+(?:DATABASE|SCHEMA)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SYSTEM\",\n            operation: \"DROP\",\n            target: name,\n            description: `Drop ${type.toLowerCase()} ${name}`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Indices / Triggers / Sequences\n    if (normalizedQuery.match(/\\bCREATE\\s+(?:UNIQUE\\s+)?INDEX\\b/i)) {\n        const name = normalizedQuery.match(/\\bCREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: `Create index ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bCREATE\\s+TRIGGER\\b/i)) {\n        const name = normalizedQuery.match(/\\bCREATE\\s+TRIGGER\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: `Create trigger ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bCREATE\\s+SEQUENCE\\b/i)) {\n        const name = normalizedQuery.match(/\\bCREATE\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: `Create sequence ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Table Schema changes\n    if (normalizedQuery.includes(\"CREATE TABLE\")) {\n        const match = cleanQuery.match(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: tableName,\n            tableName,\n            description: `Create table ${tableName}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"ALTER TABLE\")) {\n        const match = cleanQuery.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: tableName,\n            tableName,\n            description: `Alter table ${tableName}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.includes(\"DROP TABLE\")) {\n        const match = cleanQuery.match(/DROP\\s+TABLE\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: tableName,\n            tableName,\n            description: `Drop table ${tableName}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Procedure/Function/View/Trigger/Index Drop\n    const dropObjMatch = normalizedQuery.match(/DROP\\s+(PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|SEQUENCE|ROLE)\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\2/i);\n    if (dropObjMatch) {\n        const type = dropObjMatch[1].toUpperCase();\n        const name = dropObjMatch[3];\n        return {\n            type: type === \"ROLE\" ? \"ACL\" : \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: `Drop ${type.toLowerCase()} ${name}`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bREFRESH\\s+MATERIALIZED\\s+VIEW\\b/i)) {\n        const name = normalizedQuery.match(/\\bREFRESH\\s+MATERIALIZED\\s+VIEW\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: name,\n            description: `Refresh materialized view ${name}`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Materialized view drop handle\n    if (normalizedQuery.match(/\\bDROP\\s+MATERIALIZED\\s+VIEW\\b/i)) {\n        const name = normalizedQuery.match(/\\bDROP\\s+MATERIALIZED\\s+VIEW\\s+(?:IF\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"DROP\",\n            target: name,\n            description: `Drop materialized view ${name}`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Views/Procedures/Functions\n    const procMatch = cleanQuery.match(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(PROCEDURE|FUNCTION|VIEW|MATERIALIZED\\s+VIEW|ROUTINE)\\s+([`\"]?)(\\w+)\\2/i);\n    if (procMatch) {\n        const type = procMatch[1].toUpperCase();\n        const name = procMatch[3];\n        return {\n            type: \"SCHEMA\",\n            operation: \"CREATE\",\n            target: name,\n            description: `Create ${type.toLowerCase()} ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // ACL changes\n    if (normalizedQuery.startsWith(\"GRANT\") || normalizedQuery.startsWith(\"REVOKE\")) {\n        return {\n            type: \"ACL\",\n            operation: normalizedQuery.startsWith(\"GRANT\") ? \"GRANT\" : \"REVOKE\",\n            target: \"permissions\",\n            description: `${normalizedQuery.startsWith(\"GRANT\") ? \"Grant\" : \"Revoke\"} permissions`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    // Comments\n    if (normalizedQuery.startsWith(\"COMMENT ON\")) {\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: \"comment\",\n            description: `Update comment`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    // Data changes (DML)\n    if (normalizedQuery.startsWith(\"INSERT INTO\") || normalizedQuery.startsWith(\"MERGE\")) {\n        const isMerge = normalizedQuery.startsWith(\"MERGE\");\n        const match = cleanQuery.match(/(?:INSERT\\s+INTO|MERGE\\s+INTO?)\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: isMerge ? \"ALTER\" : \"INSERT\",\n            target: tableName,\n            tableName,\n            description: `${isMerge ? \"Merge\" : \"Insert\"} ${affectedRows || 1} row(s) into ${tableName}`,\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.match(/\\bALTER\\s+(SEQUENCE|INDEX)\\b/i)) {\n        const type = normalizedQuery.includes(\"SEQUENCE\") ? \"SEQUENCE\" : \"INDEX\";\n        const name = normalizedQuery.match(/\\bALTER\\s+(?:SEQUENCE|INDEX)\\s+([`\"]?)(\\w+)\\1/i)?.[2] || \"unknown\";\n        return {\n            type: \"SCHEMA\",\n            operation: \"ALTER\",\n            target: name,\n            description: `Alter ${type.toLowerCase()} ${name}`,\n            query,\n            rollbackSQL: generateRollbackSQL(query),\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"REINDEX\") || normalizedQuery.startsWith(\"VACUUM\") || normalizedQuery.startsWith(\"ANALYZE\")) {\n        const op = normalizedQuery.split(\" \")[0];\n        return {\n            type: \"SYSTEM\",\n            operation: \"ALTER\",\n            target: \"database\",\n            description: `Run ${op.toLowerCase()}`,\n            query,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"UPDATE\")) {\n        const match = cleanQuery.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"UPDATE\",\n            target: tableName,\n            tableName,\n            description: `Update ${affectedRows || \"unknown\"} row(s) in ${tableName}`,\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    if (normalizedQuery.startsWith(\"DELETE FROM\")) {\n        const match = cleanQuery.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        const tableName = match ? match[2] : \"unknown\";\n        return {\n            type: \"DATA\",\n            operation: \"DELETE\",\n            target: tableName,\n            tableName,\n            description: `Delete ${affectedRows || \"unknown\"} row(s) from ${tableName}`,\n            query,\n            affectedRows,\n            rollbackSQL: \"MANUAL\",\n            status: \"APPLIED\"\n        };\n    }\n    return null;\n}\n/**\r\n * Detect DDL/DML and generate rollback SQL using regex patterns\r\n * Covers the MASTER SQL OPERATION MATRIX\r\n */ function generateRollbackSQL(query, metadata) {\n    const q = query.trim().replace(/\\/\\*[\\s\\S]*?\\*\\/|--.*?\\n/g, \"\").trim();\n    const upper = q.toUpperCase();\n    // Helper to get name from common regex groups\n    const getMatch = (regex, groupIndex = 2)=>{\n        const match = q.match(regex);\n        return match ? match[groupIndex] : null;\n    };\n    // 1 & 2. DATABASE / SCHEMA LEVEL\n    if (upper.startsWith(\"CREATE DATABASE\")) return `DROP DATABASE ${getMatch(/CREATE\\s+DATABASE\\s+([`\"]?)(\\w+)\\1/i, 2)};`;\n    if (upper.startsWith(\"DROP DATABASE\")) return \"MANUAL\";\n    if (upper.startsWith(\"CREATE SCHEMA\")) return `DROP SCHEMA ${getMatch(/CREATE\\s+SCHEMA\\s+([`\"]?)(\\w+)\\1/i, 2)};`;\n    if (upper.startsWith(\"DROP SCHEMA\")) return \"MANUAL\";\n    if (upper.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        const m = q.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return m ? `${m[1]} ${m[5]} RENAME TO ${m[3]};` : \"MANUAL\";\n    }\n    if (upper.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+OWNER\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        if (metadata?.oldOwner) {\n            const m = q.match(/(ALTER\\s+DATABASE|ALTER\\s+SCHEMA)\\s+([`\"]?)(\\w+)\\2\\s+OWNER\\s+TO\\s+/i);\n            return m ? `${m[1]} ${m[3]} OWNER TO ${metadata.oldOwner};` : \"MANUAL\";\n        }\n        return \"MANUAL\";\n    }\n    // 3. TABLE OPERATIONS\n    if (upper.startsWith(\"CREATE TABLE\")) {\n        const name = getMatch(/CREATE\\s+TABLE\\s+(?:IF\\s+NOT\\s+EXISTS\\s+)?([`\"]?)(\\w+)\\1/i);\n        return name ? `DROP TABLE IF EXISTS ${name};` : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP TABLE\")) return metadata?.originalCreateSQL || \"MANUAL\";\n    if (upper.startsWith(\"TRUNCATE\")) return \"MANUAL\";\n    if (upper.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i)) {\n        const m = q.match(/(RENAME\\s+TABLE|ALTER\\s+TABLE)\\s+([`\"]?)(\\w+)\\2\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\4/i);\n        return m ? `ALTER TABLE ${m[5]} RENAME TO ${m[3]};` : \"MANUAL\";\n    }\n    if (upper.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+OWNER\\s+TO\\s+/i)) {\n        if (metadata?.oldOwner) {\n            const m = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1/i);\n            return m ? `ALTER TABLE ${m[2]} OWNER TO ${metadata.oldOwner};` : \"MANUAL\";\n        }\n        return \"MANUAL\";\n    }\n    // 4. COLUMN OPERATIONS\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"ADD\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:COLUMN\\s+)?([`\"]?)(\\w+)\\3/i);\n        return mt ? `ALTER TABLE ${mt[2]} DROP COLUMN ${mt[4]};` : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"DROP COLUMN\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+DROP\\s+COLUMN\\s+([`\"]?)(\\w+)\\3/i);\n        return mt && metadata?.columnDefinition ? `ALTER TABLE ${mt[2]} ADD COLUMN ${metadata.columnDefinition};` : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER TABLE\") && upper.includes(\"RENAME COLUMN\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+COLUMN\\s+([`\"]?)(\\w+)\\3\\s+TO\\s+([`\"]?)(\\w+)\\5/i);\n        return mt ? `ALTER TABLE ${mt[2]} RENAME COLUMN ${mt[6]} TO ${mt[4]};` : \"MANUAL\";\n    }\n    if (upper.includes(\"ALTER COLUMN\") || upper.includes(\"MODIFY\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+(?:ALTER\\s+COLUMN|MODIFY)\\s+([`\"]?)(\\w+)\\3/i);\n        if (mt) {\n            if (upper.includes(\"SET DEFAULT\")) return metadata?.oldDefault !== undefined ? `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} SET DEFAULT ${metadata.oldDefault};` : `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} DROP DEFAULT;`;\n            if (upper.includes(\"DROP DEFAULT\")) return metadata?.oldDefault !== undefined ? `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} SET DEFAULT ${metadata.oldDefault};` : \"MANUAL\";\n            if (upper.includes(\"SET NOT NULL\")) return `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} DROP NOT NULL;`;\n            if (upper.includes(\"DROP NOT NULL\")) return `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} SET NOT NULL;`;\n            if (metadata?.oldColumnState) return `ALTER TABLE ${mt[2]} ALTER COLUMN ${mt[4]} ${metadata.oldColumnState};`;\n        }\n        return \"MANUAL\";\n    }\n    // 5. CONSTRAINTS\n    if (upper.includes(\"ADD PRIMARY KEY\") || upper.includes(\"ADD CONSTRAINT\")) {\n        const mt = q.match(/ALTER\\s+TABLE\\s+([`\"]?)(\\w+)\\1\\s+ADD\\s+(?:CONSTRAINT\\s+([`\"]?)(\\w+)\\3\\s+)?(?:PRIMARY\\s+KEY|FOREIGN\\s+KEY|UNIQUE|CHECK)/i);\n        const name = mt ? mt[4] || \"pk\" : null; // Need to know constraint name to drop it\n        return mt && name ? `ALTER TABLE ${mt[2]} DROP CONSTRAINT ${name};` : \"MANUAL\";\n    }\n    // 6. INDEXES\n    if (upper.startsWith(\"CREATE\") && upper.includes(\"INDEX\")) {\n        const name = getMatch(/CREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+([`\"]?)(\\w+)\\1/i);\n        return name ? `DROP INDEX ${name};` : \"MANUAL\";\n    }\n    if (upper.startsWith(\"DROP INDEX\")) return metadata?.originalIndexSQL || \"MANUAL\";\n    if (upper.includes(\"ALTER INDEX\") && upper.includes(\"RENAME TO\")) {\n        const m = q.match(/ALTER\\s+INDEX\\s+([`\"]?)(\\w+)\\1\\s+RENAME\\s+TO\\s+([`\"]?)(\\w+)\\3/i);\n        return m ? `ALTER INDEX ${m[3]} RENAME TO ${m[1]};` : \"MANUAL\";\n    }\n    // 7 & 8. VIEWS\n    if (upper.startsWith(\"CREATE\") && (upper.includes(\"VIEW\") || upper.includes(\"MATERIALIZED VIEW\"))) {\n        const isMat = upper.includes(\"MATERIALIZED\");\n        const name = getMatch(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(?:MATERIALIZED\\s+)?VIEW\\s+([`\"]?)(\\w+)\\1/i);\n        if (upper.includes(\"REPLACE\") && metadata?.oldViewDefinition) return metadata.oldViewDefinition;\n        return name ? `DROP ${isMat ? \"MATERIALIZED \" : \"\"}VIEW ${name};` : \"MANUAL\";\n    }\n    if (upper.startsWith(\"REFRESH MATERIALIZED VIEW\")) return \"MANUAL\";\n    // 9. FUNCTIONS / PROCEDURES\n    if (upper.startsWith(\"CREATE\") && (upper.includes(\"FUNCTION\") || upper.includes(\"PROCEDURE\"))) {\n        const type = upper.includes(\"FUNCTION\") ? \"FUNCTION\" : \"PROCEDURE\";\n        if (upper.includes(\"REPLACE\") && metadata?.oldBody) return metadata.oldBody;\n        const name = getMatch(/CREATE\\s+(?:OR\\s+REPLACE\\s+)?(FUNCTION|PROCEDURE)\\s+([`\"]?)(\\w+)\\2/i, 3);\n        return name ? `DROP ${type} ${name};` : \"MANUAL\";\n    }\n    // 10. TRIGGERS\n    if (upper.startsWith(\"CREATE TRIGGER\")) {\n        const m = q.match(/CREATE\\s+TRIGGER\\s+([`\"]?)(\\w+)\\1\\s+ON\\s+([`\"]?)(\\w+)\\3/i);\n        return m ? `DROP TRIGGER ${m[2]} ON ${m[4]};` : \"MANUAL\";\n    }\n    if (upper.includes(\"ENABLE TRIGGER\") || upper.includes(\"DISABLE TRIGGER\")) {\n        const isEnable = upper.includes(\"ENABLE\");\n        const m = q.match(/(ENABLE|DISABLE)\\s+TRIGGER\\s+([`\"]?)(\\w+)\\3\\s+ON\\s+([`\"]?)(\\w+)\\5/i);\n        return m ? `ALTER TABLE ${m[5]} ${isEnable ? \"DISABLE\" : \"ENABLE\"} TRIGGER ${m[3]};` : \"MANUAL\";\n    }\n    // 11. SEQUENCES\n    if (upper.startsWith(\"CREATE SEQUENCE\")) return `DROP SEQUENCE ${getMatch(/CREATE\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i, 2)};`;\n    if (upper.startsWith(\"DROP SEQUENCE\")) return metadata?.originalSeqSQL || \"MANUAL\";\n    if (upper.startsWith(\"ALTER SEQUENCE\")) {\n        const name = getMatch(/ALTER\\s+SEQUENCE\\s+([`\"]?)(\\w+)\\1/i, 2);\n        if (upper.includes(\"RESTART\")) return \"MANUAL\"; // value lost unless we have it\n        return metadata?.oldSeqState ? `ALTER SEQUENCE ${name} ${metadata.oldSeqState};` : \"MANUAL\";\n    }\n    // 12. DATA (DML)\n    if (upper.startsWith(\"MERGE\")) return \"MANUAL\"; // Complex inverse\n    if (upper.startsWith(\"INSERT INTO\")) {\n        const match = q.match(/INSERT\\s+INTO\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && metadata?.primaryKey) {\n            const pk = metadata.primaryKey;\n            const conds = Object.entries(pk).map(([c, v])=>`${c} = ${typeof v === \"string\" ? `'${v}'` : v}`).join(\" AND \");\n            return `DELETE FROM ${match[2]} WHERE ${conds};`;\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"DELETE FROM\")) {\n        const match = q.match(/DELETE\\s+FROM\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && metadata?.rows) {\n            return metadata.rows.map((row)=>{\n                const cols = Object.keys(row).join(\", \");\n                const vals = Object.values(row).map((v)=>typeof v === \"string\" ? `'${v}'` : v).join(\", \");\n                return `INSERT INTO ${match[2]} (${cols}) VALUES (${vals});`;\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    if (upper.startsWith(\"UPDATE\")) {\n        const match = q.match(/UPDATE\\s+([`\"]?)(\\w+)\\1/i);\n        if (match && metadata?.oldRows) {\n            return metadata.oldRows.map((row)=>{\n                const pk = metadata.primaryKeyFields.reduce((acc, f)=>({\n                        ...acc,\n                        [f]: row[f]\n                    }), {});\n                const set = Object.entries(row).map(([c, v])=>`${c} = ${typeof v === \"string\" ? `'${v}'` : v}`).join(\", \");\n                const where = Object.entries(pk).map(([c, v])=>`${c} = ${typeof v === \"string\" ? `'${v}'` : v}`).join(\" AND \");\n                return `UPDATE ${match[2]} SET ${set} WHERE ${where};`;\n            }).join(\"\\n\");\n        }\n        return \"MANUAL\";\n    }\n    // 14. PERMISSIONS / ACL\n    if (upper.startsWith(\"GRANT\")) return q.replace(/GRANT/i, \"REVOKE\").replace(/TO/i, \"FROM\");\n    if (upper.startsWith(\"REVOKE\")) return q.replace(/REVOKE/i, \"GRANT\").replace(/FROM/i, \"TO\");\n    if (upper.startsWith(\"CREATE ROLE\")) return `DROP ROLE ${getMatch(/CREATE\\s+ROLE\\s+([`\"]?)(\\w+)\\1/i, 2)};`;\n    // 20. COMMENTS\n    if (upper.startsWith(\"COMMENT ON\")) {\n        const m = q.match(/COMMENT\\s+ON\\s+(TABLE|COLUMN)\\s+([\\s\\S]+?)\\s+IS/i);\n        if (m && metadata?.oldComment !== undefined) return `COMMENT ON ${m[1]} ${m[2]} IS ${metadata.oldComment === null ? \"NULL\" : `'${metadata.oldComment}'`};`;\n        return \"MANUAL\";\n    }\n    return \"MANUAL\";\n}\n/**\r\n * Get pending changes for a connection\r\n */ async function getPendingChanges(connectionId) {\n    try {\n        const response = await fetch(`/api/vcs/pending?connectionId=${connectionId}`);\n        const data = await response.json();\n        return data.changes || [];\n    } catch (error) {\n        console.error(\"Failed to get pending changes:\", error);\n        return [];\n    }\n}\n/**\r\n * Commit pending changes\r\n */ async function commitChanges(connectionId, message, author) {\n    try {\n        const pending = await getPendingChanges(connectionId);\n        const response = await fetch(\"/api/vcs/commit\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                message,\n                author,\n                changes: pending,\n                snapshot: {\n                    schema: {\n                        tables: {}\n                    },\n                    data: {\n                        tables: {}\n                    },\n                    timestamp: new Date()\n                }\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to commit changes:\", error);\n        return false;\n    }\n}\n/**\r\n * Get commit history for a connection\r\n */ async function getCommitHistory(connectionId) {\n    try {\n        const response = await fetch(`/api/vcs/commit?connectionId=${connectionId}`);\n        const data = await response.json();\n        return data.commits || [];\n    } catch (error) {\n        console.error(\"Failed to get commit history:\", error);\n        return [];\n    }\n}\n/**\r\n * Get branches for a connection\r\n */ async function getBranches(connectionId) {\n    try {\n        const response = await fetch(`/api/vcs/branches?connectionId=${connectionId}`);\n        const data = await response.json();\n        return {\n            branches: data.branches || [],\n            currentBranch: data.currentBranch || \"main\"\n        };\n    } catch (error) {\n        console.error(\"Failed to get branches:\", error);\n        return {\n            branches: [],\n            currentBranch: \"main\"\n        };\n    }\n}\n/**\r\n * Create a new branch\r\n */ async function createBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"create\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to create branch:\", error);\n        return false;\n    }\n}\n/**  \r\n * Checkout a branch\r\n */ async function checkoutBranch(connectionId, name) {\n    try {\n        const response = await fetch(\"/api/vcs/branches\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                connectionId,\n                name,\n                action: \"checkout\"\n            })\n        });\n        const result = await response.json();\n        return result.success;\n    } catch (error) {\n        console.error(\"Failed to checkout branch:\", error);\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7Z0JBQUVQO2dCQUFjcUI7Z0JBQU1xRixRQUFRO1lBQVc7UUFDbEU7UUFDQSxNQUFNUixTQUFTLE1BQU1aLFNBQVNFLElBQUk7UUFDbEMsT0FBT1UsT0FBT0MsT0FBTztJQUN6QixFQUFFLE9BQU8zRixPQUFPO1FBQ1pDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU87SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uL3NyYy9saWIvdmNzLWhlbHBlci50cz9iYzc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBWQ1MgSW50ZWdyYXRpb24gSGVscGVyXHJcbiAqIEF1dG9tYXRpY2FsbHkgdHJhY2tzIGRhdGFiYXNlIGNoYW5nZXMgZm9yIHZlcnNpb24gY29udHJvbFxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YWJhc2VDaGFuZ2Uge1xyXG4gICAgaWQ/OiBzdHJpbmc7XHJcbiAgICB0eXBlOiAnU0NIRU1BJyB8ICdEQVRBJyB8ICdBQ0wnIHwgJ1NZU1RFTSc7XHJcbiAgICBvcGVyYXRpb246ICdDUkVBVEUnIHwgJ0FMVEVSJyB8ICdEUk9QJyB8ICdJTlNFUlQnIHwgJ1VQREFURScgfCAnREVMRVRFJyB8ICdSRU5BTUUnIHwgJ1RSVU5DQVRFJyB8ICdHUkFOVCcgfCAnUkVWT0tFJztcclxuICAgIHRhcmdldDogc3RyaW5nO1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICByb2xsYmFja1NRTDogc3RyaW5nIHwgJ01BTlVBTCc7XHJcbiAgICBzdGF0dXM6ICdBUFBMSUVEJyB8ICdSRVZFUlRFRCc7XHJcbiAgICB0YWJsZU5hbWU/OiBzdHJpbmc7XHJcbiAgICBhZmZlY3RlZFJvd3M/OiBudW1iZXI7XHJcbiAgICBtZXRhZGF0YT86IGFueTtcclxuICAgIHRpbWVzdGFtcD86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgZGF0YWJhc2UgY2hhbmdlIGZvciB2ZXJzaW9uIGNvbnRyb2xcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQ6IHN0cmluZywgY2hhbmdlOiBEYXRhYmFzZUNoYW5nZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvcGVuZGluZycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbm5lY3Rpb25JZCwgY2hhbmdlIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB0cmFjayBjaGFuZ2U6JywgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgYSBzY2hlbWEgY2hhbmdlIChDUkVBVEUsIEFMVEVSLCBEUk9QIHRhYmxlKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrU2NoZW1hQ2hhbmdlKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBvcGVyYXRpb246ICdjcmVhdGUnIHwgJ2FsdGVyJyB8ICdkcm9wJyxcclxuICAgIHRhYmxlTmFtZTogc3RyaW5nLFxyXG4gICAgc3FsOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1cclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBjaGFuZ2U6IERhdGFiYXNlQ2hhbmdlID0ge1xyXG4gICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLnRvVXBwZXJDYXNlKCkgYXMgJ0NSRUFURScgfCAnQUxURVInIHwgJ0RST1AnLFxyXG4gICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgIHRhYmxlTmFtZSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYCR7b3BlcmF0aW9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3BlcmF0aW9uLnNsaWNlKDEpfSB0YWJsZSAke3RhYmxlTmFtZX0gYnkgJHthdXRob3IubmFtZX1gLFxyXG4gICAgICAgIHF1ZXJ5OiBzcWwsXHJcbiAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwoc3FsKSxcclxuICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCB0cmFja0NoYW5nZShjb25uZWN0aW9uSWQsIGNoYW5nZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBTUUwgcXVlcnkgdG8gZGV0ZWN0IGNoYW5nZSB0eXBlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeUZvckNoYW5nZXMocXVlcnk6IHN0cmluZywgYWZmZWN0ZWRSb3dzPzogbnVtYmVyKTogRGF0YWJhc2VDaGFuZ2UgfCBudWxsIHtcclxuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgdHJpbVxyXG4gICAgY29uc3QgY2xlYW5RdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRRdWVyeSA9IGNsZWFuUXVlcnkudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAvLyBEYXRhYmFzZSAvIFNjaGVtYSBjaGFuZ2VzXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJDUkVBVEVcXHMrKERBVEFCQVNFfFNDSEVNQSlcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gbm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEQVRBQkFTRScpID8gJ0RBVEFCQVNFJyA6ICdTQ0hFTUEnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkNSRUFURVxccysoPzpEQVRBQkFTRXxTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTWVNURU0nLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrKERBVEFCQVNFfFNDSEVNQSlcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gbm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdEQVRBQkFTRScpID8gJ0RBVEFCQVNFJyA6ICdTQ0hFTUEnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrKD86REFUQUJBU0V8U0NIRU1BKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU1lTVEVNJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnRFJPUCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wICR7dHlwZS50b0xvd2VyQ2FzZSgpfSAke25hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiAnTUFOVUFMJyxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluZGljZXMgLyBUcmlnZ2VycyAvIFNlcXVlbmNlc1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzKyg/OlVOSVFVRVxccyspP0lOREVYXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzKyg/OlVOSVFVRVxccyspP0lOREVYXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIGluZGV4ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1RSSUdHRVJcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJDUkVBVEVcXHMrVFJJR0dFUlxccysoW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSB0cmlnZ2VyICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1NFUVVFTkNFXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiQ1JFQVRFXFxzK1NFUVVFTkNFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdDUkVBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIHNlcXVlbmNlICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGFibGUgU2NoZW1hIGNoYW5nZXNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0NSRUFURSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9DUkVBVEVcXHMrVEFCTEVcXHMrKD86SUZcXHMrTk9UXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0NSRUFURScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ3JlYXRlIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdBTFRFUicsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQWx0ZXIgdGFibGUgJHt0YWJsZU5hbWV9YCxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiBnZW5lcmF0ZVJvbGxiYWNrU1FMKHF1ZXJ5KSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuaW5jbHVkZXMoJ0RST1AgVEFCTEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvRFJPUFxccytUQUJMRVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaCA/IG1hdGNoWzJdIDogJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBEcm9wIHRhYmxlICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZWR1cmUvRnVuY3Rpb24vVmlldy9UcmlnZ2VyL0luZGV4IERyb3BcclxuICAgIGNvbnN0IGRyb3BPYmpNYXRjaCA9IG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvRFJPUFxccysoUFJPQ0VEVVJFfEZVTkNUSU9OfFZJRVd8VFJJR0dFUnxJTkRFWHxTRVFVRU5DRXxST0xFKVxccysoPzpJRlxccytFWElTVFNcXHMrKT8oW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChkcm9wT2JqTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gZHJvcE9iak1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGRyb3BPYmpNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlID09PSAnUk9MRScgPyAnQUNMJyA6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgJHt0eXBlLnRvTG93ZXJDYXNlKCl9ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5tYXRjaCgvXFxiUkVGUkVTSFxccytNQVRFUklBTElaRURcXHMrVklFV1xcYi9pKSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYlJFRlJFU0hcXHMrTUFURVJJQUxJWkVEXFxzK1ZJRVdcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk/LlsyXSB8fCAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0FMVEVSJyBhcyBhbnksXHJcbiAgICAgICAgICAgIHRhcmdldDogbmFtZSxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZWZyZXNoIG1hdGVyaWFsaXplZCB2aWV3ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0ZXJpYWxpemVkIHZpZXcgZHJvcCBoYW5kbGVcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkRST1BcXHMrTUFURVJJQUxJWkVEXFxzK1ZJRVdcXGIvaSkpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJEUk9QXFxzK01BVEVSSUFMSVpFRFxccytWSUVXXFxzKyg/OklGXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpPy5bMl0gfHwgJ3Vua25vd24nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTQ0hFTUEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdEUk9QJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERyb3AgbWF0ZXJpYWxpemVkIHZpZXcgJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFZpZXdzL1Byb2NlZHVyZXMvRnVuY3Rpb25zXHJcbiAgICBjb25zdCBwcm9jTWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC9DUkVBVEVcXHMrKD86T1JcXHMrUkVQTEFDRVxccyspPyhQUk9DRURVUkV8RlVOQ1RJT058VklFV3xNQVRFUklBTElaRURcXHMrVklFV3xST1VUSU5FKVxccysoW2BcIl0/KShcXHcrKVxcMi9pKTtcclxuICAgIGlmIChwcm9jTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gcHJvY01hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb2NNYXRjaFszXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQ1JFQVRFJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENyZWF0ZSAke3R5cGUudG9Mb3dlckNhc2UoKX0gJHtuYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogZ2VuZXJhdGVSb2xsYmFja1NRTChxdWVyeSksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ0wgY2hhbmdlc1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdHUkFOVCcpIHx8IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdSRVZPS0UnKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdBQ0wnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdHUkFOVCcpID8gJ0dSQU5UJyA6ICdSRVZPS0UnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICdwZXJtaXNzaW9ucycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnR1JBTlQnKSA/ICdHcmFudCcgOiAnUmV2b2tlJ30gcGVybWlzc2lvbnNgLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tbWVudHNcclxuICAgIGlmIChub3JtYWxpemVkUXVlcnkuc3RhcnRzV2l0aCgnQ09NTUVOVCBPTicpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ1NDSEVNQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ0FMVEVSJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnY29tbWVudCcsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVXBkYXRlIGNvbW1lbnRgLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGF0YSBjaGFuZ2VzIChETUwpXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ01FUkdFJykpIHtcclxuICAgICAgICBjb25zdCBpc01lcmdlID0gbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ01FUkdFJyk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjbGVhblF1ZXJ5Lm1hdGNoKC8oPzpJTlNFUlRcXHMrSU5UT3xNRVJHRVxccytJTlRPPylcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbWF0Y2ggPyBtYXRjaFsyXSA6ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnREFUQScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogaXNNZXJnZSA/ICdBTFRFUicgYXMgYW55IDogJ0lOU0VSVCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFibGVOYW1lLFxyXG4gICAgICAgICAgICB0YWJsZU5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtpc01lcmdlID8gJ01lcmdlJyA6ICdJbnNlcnQnfSAke2FmZmVjdGVkUm93cyB8fCAxfSByb3cocykgaW50byAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5Lm1hdGNoKC9cXGJBTFRFUlxccysoU0VRVUVOQ0V8SU5ERVgpXFxiL2kpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vcm1hbGl6ZWRRdWVyeS5pbmNsdWRlcygnU0VRVUVOQ0UnKSA/ICdTRVFVRU5DRScgOiAnSU5ERVgnO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVkUXVlcnkubWF0Y2goL1xcYkFMVEVSXFxzKyg/OlNFUVVFTkNFfElOREVYKVxccysoW2BcIl0/KShcXHcrKVxcMS9pKT8uWzJdIHx8ICd1bmtub3duJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnU0NIRU1BJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnQUxURVInLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQWx0ZXIgJHt0eXBlLnRvTG93ZXJDYXNlKCl9ICR7bmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6IGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnkpLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdSRUlOREVYJykgfHwgbm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ1ZBQ1VVTScpIHx8IG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdBTkFMWVpFJykpIHtcclxuICAgICAgICBjb25zdCBvcCA9IG5vcm1hbGl6ZWRRdWVyeS5zcGxpdCgnICcpWzBdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTWVNURU0nLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdBTFRFUicgYXMgYW55LFxyXG4gICAgICAgICAgICB0YXJnZXQ6ICdkYXRhYmFzZScsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUnVuICR7b3AudG9Mb3dlckNhc2UoKX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgcm9sbGJhY2tTUUw6ICdNQU5VQUwnLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdBUFBMSUVEJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vcm1hbGl6ZWRRdWVyeS5zdGFydHNXaXRoKCdVUERBVEUnKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2xlYW5RdWVyeS5tYXRjaCgvVVBEQVRFXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdVUERBVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVwZGF0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBpbiAke3RhYmxlTmFtZX1gLFxyXG4gICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgYWZmZWN0ZWRSb3dzLFxyXG4gICAgICAgICAgICByb2xsYmFja1NRTDogJ01BTlVBTCcsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUExJRUQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsaXplZFF1ZXJ5LnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IGNsZWFuUXVlcnkubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1hdGNoID8gbWF0Y2hbMl0gOiAndW5rbm93bic7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ0RBVEEnLFxyXG4gICAgICAgICAgICBvcGVyYXRpb246ICdERUxFVEUnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgdGFibGVOYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYERlbGV0ZSAke2FmZmVjdGVkUm93cyB8fCAndW5rbm93bid9IHJvdyhzKSBmcm9tICR7dGFibGVOYW1lfWAsXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3MsXHJcbiAgICAgICAgICAgIHJvbGxiYWNrU1FMOiAnTUFOVUFMJyxcclxuICAgICAgICAgICAgc3RhdHVzOiAnQVBQTElFRCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IERETC9ETUwgYW5kIGdlbmVyYXRlIHJvbGxiYWNrIFNRTCB1c2luZyByZWdleCBwYXR0ZXJuc1xyXG4gKiBDb3ZlcnMgdGhlIE1BU1RFUiBTUUwgT1BFUkFUSU9OIE1BVFJJWFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUm9sbGJhY2tTUUwocXVlcnk6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpOiBzdHJpbmcgfCAnTUFOVUFMJyB7XHJcbiAgICBjb25zdCBxID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98LS0uKj9cXG4vZywgJycpLnRyaW0oKTtcclxuICAgIGNvbnN0IHVwcGVyID0gcS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIC8vIEhlbHBlciB0byBnZXQgbmFtZSBmcm9tIGNvbW1vbiByZWdleCBncm91cHNcclxuICAgIGNvbnN0IGdldE1hdGNoID0gKHJlZ2V4OiBSZWdFeHAsIGdyb3VwSW5kZXg6IG51bWJlciA9IDIpID0+IHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2gocmVnZXgpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoW2dyb3VwSW5kZXhdIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gMSAmIDIuIERBVEFCQVNFIC8gU0NIRU1BIExFVkVMXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIERBVEFCQVNFJykpIHJldHVybiBgRFJPUCBEQVRBQkFTRSAke2dldE1hdGNoKC9DUkVBVEVcXHMrREFUQUJBU0VcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMil9O2A7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnRFJPUCBEQVRBQkFTRScpKSByZXR1cm4gJ01BTlVBTCc7XHJcblxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBTQ0hFTUEnKSkgcmV0dXJuIGBEUk9QIFNDSEVNQSAke2dldE1hdGNoKC9DUkVBVEVcXHMrU0NIRU1BXFxzKyhbYFwiXT8pKFxcdyspXFwxL2ksIDIpfTtgO1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgU0NIRU1BJykpIHJldHVybiAnTUFOVUFMJztcclxuXHJcbiAgICBpZiAodXBwZXIubWF0Y2goLyhBTFRFUlxccytEQVRBQkFTRXxBTFRFUlxccytTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwyXFxzK1JFTkFNRVxccytUT1xccysoW2BcIl0/KShcXHcrKVxcNC9pKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC8oQUxURVJcXHMrREFUQUJBU0V8QUxURVJcXHMrU0NIRU1BKVxccysoW2BcIl0/KShcXHcrKVxcMlxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDQvaSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBgJHttWzFdfSAke21bNV19IFJFTkFNRSBUTyAke21bM119O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXBwZXIubWF0Y2goLyhBTFRFUlxccytEQVRBQkFTRXxBTFRFUlxccytTQ0hFTUEpXFxzKyhbYFwiXT8pKFxcdyspXFwyXFxzK09XTkVSXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw0L2kpKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhPy5vbGRPd25lcikge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKEFMVEVSXFxzK0RBVEFCQVNFfEFMVEVSXFxzK1NDSEVNQSlcXHMrKFtgXCJdPykoXFx3KylcXDJcXHMrT1dORVJcXHMrVE9cXHMrL2kpO1xyXG4gICAgICAgICAgICByZXR1cm4gbSA/IGAke21bMV19ICR7bVszXX0gT1dORVIgVE8gJHttZXRhZGF0YS5vbGRPd25lcn07YCA6ICdNQU5VQUwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4gVEFCTEUgT1BFUkFUSU9OU1xyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0NSRUFURSBUQUJMRScpKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldE1hdGNoKC9DUkVBVEVcXHMrVEFCTEVcXHMrKD86SUZcXHMrTk9UXFxzK0VYSVNUU1xccyspPyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIHJldHVybiBuYW1lID8gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7bmFtZX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgVEFCTEUnKSkgcmV0dXJuIG1ldGFkYXRhPy5vcmlnaW5hbENyZWF0ZVNRTCB8fCAnTUFOVUFMJztcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdUUlVOQ0FURScpKSByZXR1cm4gJ01BTlVBTCc7XHJcblxyXG4gICAgaWYgKHVwcGVyLm1hdGNoKC8oUkVOQU1FXFxzK1RBQkxFfEFMVEVSXFxzK1RBQkxFKVxccysoW2BcIl0/KShcXHcrKVxcMlxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDQvaSkpIHtcclxuICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKFJFTkFNRVxccytUQUJMRXxBTFRFUlxccytUQUJMRSlcXHMrKFtgXCJdPykoXFx3KylcXDJcXHMrUkVOQU1FXFxzK1RPXFxzKyhbYFwiXT8pKFxcdyspXFw0L2kpO1xyXG4gICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVs1XX0gUkVOQU1FIFRPICR7bVszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cHBlci5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDFcXHMrT1dORVJcXHMrVE9cXHMrL2kpKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhPy5vbGRPd25lcikge1xyXG4gICAgICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvQUxURVJcXHMrVEFCTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVsyXX0gT1dORVIgVE8gJHttZXRhZGF0YS5vbGRPd25lcn07YCA6ICdNQU5VQUwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNC4gQ09MVU1OIE9QRVJBVElPTlNcclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUxURVIgVEFCTEUnKSAmJiB1cHBlci5pbmNsdWRlcygnQUREJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK0FERFxccysoPzpDT0xVTU5cXHMrKT8oW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gbXQgPyBgQUxURVIgVEFCTEUgJHttdFsyXX0gRFJPUCBDT0xVTU4gJHttdFs0XX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdEUk9QIENPTFVNTicpKSB7XHJcbiAgICAgICAgY29uc3QgbXQgPSBxLm1hdGNoKC9BTFRFUlxccytUQUJMRVxccysoW2BcIl0/KShcXHcrKVxcMVxccytEUk9QXFxzK0NPTFVNTlxccysoW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gKG10ICYmIG1ldGFkYXRhPy5jb2x1bW5EZWZpbml0aW9uKSA/IGBBTFRFUiBUQUJMRSAke210WzJdfSBBREQgQ09MVU1OICR7bWV0YWRhdGEuY29sdW1uRGVmaW5pdGlvbn07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBUQUJMRScpICYmIHVwcGVyLmluY2x1ZGVzKCdSRU5BTUUgQ09MVU1OJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK1JFTkFNRVxccytDT0xVTU5cXHMrKFtgXCJdPykoXFx3KylcXDNcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDUvaSk7XHJcbiAgICAgICAgcmV0dXJuIG10ID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IFJFTkFNRSBDT0xVTU4gJHttdFs2XX0gVE8gJHttdFs0XX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBDT0xVTU4nKSB8fCB1cHBlci5pbmNsdWRlcygnTU9ESUZZJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzKyg/OkFMVEVSXFxzK0NPTFVNTnxNT0RJRlkpXFxzKyhbYFwiXT8pKFxcdyspXFwzL2kpO1xyXG4gICAgICAgIGlmIChtdCkge1xyXG4gICAgICAgICAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ1NFVCBERUZBVUxUJykpIHJldHVybiBtZXRhZGF0YT8ub2xkRGVmYXVsdCAhPT0gdW5kZWZpbmVkID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IEFMVEVSIENPTFVNTiAke210WzRdfSBTRVQgREVGQVVMVCAke21ldGFkYXRhLm9sZERlZmF1bHR9O2AgOiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IERST1AgREVGQVVMVDtgO1xyXG4gICAgICAgICAgICBpZiAodXBwZXIuaW5jbHVkZXMoJ0RST1AgREVGQVVMVCcpKSByZXR1cm4gbWV0YWRhdGE/Lm9sZERlZmF1bHQgIT09IHVuZGVmaW5lZCA/IGBBTFRFUiBUQUJMRSAke210WzJdfSBBTFRFUiBDT0xVTU4gJHttdFs0XX0gU0VUIERFRkFVTFQgJHttZXRhZGF0YS5vbGREZWZhdWx0fTtgIDogJ01BTlVBTCc7XHJcbiAgICAgICAgICAgIGlmICh1cHBlci5pbmNsdWRlcygnU0VUIE5PVCBOVUxMJykpIHJldHVybiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IERST1AgTk9UIE5VTEw7YDtcclxuICAgICAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdEUk9QIE5PVCBOVUxMJykpIHJldHVybiBgQUxURVIgVEFCTEUgJHttdFsyXX0gQUxURVIgQ09MVU1OICR7bXRbNF19IFNFVCBOT1QgTlVMTDtgO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/Lm9sZENvbHVtblN0YXRlKSByZXR1cm4gYEFMVEVSIFRBQkxFICR7bXRbMl19IEFMVEVSIENPTFVNTiAke210WzRdfSAke21ldGFkYXRhLm9sZENvbHVtblN0YXRlfTtgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4gQ09OU1RSQUlOVFNcclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnQUREIFBSSU1BUlkgS0VZJykgfHwgdXBwZXIuaW5jbHVkZXMoJ0FERCBDT05TVFJBSU5UJykpIHtcclxuICAgICAgICBjb25zdCBtdCA9IHEubWF0Y2goL0FMVEVSXFxzK1RBQkxFXFxzKyhbYFwiXT8pKFxcdyspXFwxXFxzK0FERFxccysoPzpDT05TVFJBSU5UXFxzKyhbYFwiXT8pKFxcdyspXFwzXFxzKyk/KD86UFJJTUFSWVxccytLRVl8Rk9SRUlHTlxccytLRVl8VU5JUVVFfENIRUNLKS9pKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gbXQgPyAobXRbNF0gfHwgJ3BrJykgOiBudWxsOyAvLyBOZWVkIHRvIGtub3cgY29uc3RyYWludCBuYW1lIHRvIGRyb3AgaXRcclxuICAgICAgICByZXR1cm4gKG10ICYmIG5hbWUpID8gYEFMVEVSIFRBQkxFICR7bXRbMl19IERST1AgQ09OU1RSQUlOVCAke25hbWV9O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyA2LiBJTkRFWEVTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgdXBwZXIuaW5jbHVkZXMoJ0lOREVYJykpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0TWF0Y2goL0NSRUFURVxccysoPzpVTklRVUVcXHMrKT9JTkRFWFxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICByZXR1cm4gbmFtZSA/IGBEUk9QIElOREVYICR7bmFtZX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RST1AgSU5ERVgnKSkgcmV0dXJuIG1ldGFkYXRhPy5vcmlnaW5hbEluZGV4U1FMIHx8ICdNQU5VQUwnO1xyXG4gICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdBTFRFUiBJTkRFWCcpICYmIHVwcGVyLmluY2x1ZGVzKCdSRU5BTUUgVE8nKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC9BTFRFUlxccytJTkRFWFxccysoW2BcIl0/KShcXHcrKVxcMVxccytSRU5BTUVcXHMrVE9cXHMrKFtgXCJdPykoXFx3KylcXDMvaSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBgQUxURVIgSU5ERVggJHttWzNdfSBSRU5BTUUgVE8gJHttWzFdfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNyAmIDguIFZJRVdTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgKHVwcGVyLmluY2x1ZGVzKCdWSUVXJykgfHwgdXBwZXIuaW5jbHVkZXMoJ01BVEVSSUFMSVpFRCBWSUVXJykpKSB7XHJcbiAgICAgICAgY29uc3QgaXNNYXQgPSB1cHBlci5pbmNsdWRlcygnTUFURVJJQUxJWkVEJyk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldE1hdGNoKC9DUkVBVEVcXHMrKD86T1JcXHMrUkVQTEFDRVxccyspPyg/Ok1BVEVSSUFMSVpFRFxccyspP1ZJRVdcXHMrKFtgXCJdPykoXFx3KylcXDEvaSk7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVBMQUNFJykgJiYgbWV0YWRhdGE/Lm9sZFZpZXdEZWZpbml0aW9uKSByZXR1cm4gbWV0YWRhdGEub2xkVmlld0RlZmluaXRpb247XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBgRFJPUCAke2lzTWF0ID8gJ01BVEVSSUFMSVpFRCAnIDogJyd9VklFVyAke25hbWV9O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdSRUZSRVNIIE1BVEVSSUFMSVpFRCBWSUVXJykpIHJldHVybiAnTUFOVUFMJztcclxuXHJcbiAgICAvLyA5LiBGVU5DVElPTlMgLyBQUk9DRURVUkVTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFJykgJiYgKHVwcGVyLmluY2x1ZGVzKCdGVU5DVElPTicpIHx8IHVwcGVyLmluY2x1ZGVzKCdQUk9DRURVUkUnKSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdXBwZXIuaW5jbHVkZXMoJ0ZVTkNUSU9OJykgPyAnRlVOQ1RJT04nIDogJ1BST0NFRFVSRSc7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVBMQUNFJykgJiYgbWV0YWRhdGE/Lm9sZEJvZHkpIHJldHVybiBtZXRhZGF0YS5vbGRCb2R5O1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRNYXRjaCgvQ1JFQVRFXFxzKyg/Ok9SXFxzK1JFUExBQ0VcXHMrKT8oRlVOQ1RJT058UFJPQ0VEVVJFKVxccysoW2BcIl0/KShcXHcrKVxcMi9pLCAzKTtcclxuICAgICAgICByZXR1cm4gbmFtZSA/IGBEUk9QICR7dHlwZX0gJHtuYW1lfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMTAuIFRSSUdHRVJTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFRSSUdHRVInKSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBxLm1hdGNoKC9DUkVBVEVcXHMrVFJJR0dFUlxccysoW2BcIl0/KShcXHcrKVxcMVxccytPTlxccysoW2BcIl0/KShcXHcrKVxcMy9pKTtcclxuICAgICAgICByZXR1cm4gbSA/IGBEUk9QIFRSSUdHRVIgJHttWzJdfSBPTiAke21bNF19O2AgOiAnTUFOVUFMJztcclxuICAgIH1cclxuICAgIGlmICh1cHBlci5pbmNsdWRlcygnRU5BQkxFIFRSSUdHRVInKSB8fCB1cHBlci5pbmNsdWRlcygnRElTQUJMRSBUUklHR0VSJykpIHtcclxuICAgICAgICBjb25zdCBpc0VuYWJsZSA9IHVwcGVyLmluY2x1ZGVzKCdFTkFCTEUnKTtcclxuICAgICAgICBjb25zdCBtID0gcS5tYXRjaCgvKEVOQUJMRXxESVNBQkxFKVxccytUUklHR0VSXFxzKyhbYFwiXT8pKFxcdyspXFwzXFxzK09OXFxzKyhbYFwiXT8pKFxcdyspXFw1L2kpO1xyXG4gICAgICAgIHJldHVybiBtID8gYEFMVEVSIFRBQkxFICR7bVs1XX0gJHtpc0VuYWJsZSA/ICdESVNBQkxFJyA6ICdFTkFCTEUnfSBUUklHR0VSICR7bVszXX07YCA6ICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDExLiBTRVFVRU5DRVNcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdDUkVBVEUgU0VRVUVOQ0UnKSkgcmV0dXJuIGBEUk9QIFNFUVVFTkNFICR7Z2V0TWF0Y2goL0NSRUFURVxccytTRVFVRU5DRVxccysoW2BcIl0/KShcXHcrKVxcMS9pLCAyKX07YDtcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdEUk9QIFNFUVVFTkNFJykpIHJldHVybiBtZXRhZGF0YT8ub3JpZ2luYWxTZXFTUUwgfHwgJ01BTlVBTCc7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQUxURVIgU0VRVUVOQ0UnKSkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRNYXRjaCgvQUxURVJcXHMrU0VRVUVOQ0VcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMik7XHJcbiAgICAgICAgaWYgKHVwcGVyLmluY2x1ZGVzKCdSRVNUQVJUJykpIHJldHVybiAnTUFOVUFMJzsgLy8gdmFsdWUgbG9zdCB1bmxlc3Mgd2UgaGF2ZSBpdFxyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YT8ub2xkU2VxU3RhdGUgPyBgQUxURVIgU0VRVUVOQ0UgJHtuYW1lfSAke21ldGFkYXRhLm9sZFNlcVN0YXRlfTtgIDogJ01BTlVBTCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMTIuIERBVEEgKERNTClcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdNRVJHRScpKSByZXR1cm4gJ01BTlVBTCc7IC8vIENvbXBsZXggaW52ZXJzZVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0lOU0VSVCBJTlRPJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0lOU0VSVFxccytJTlRPXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucHJpbWFyeUtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBwayA9IG1ldGFkYXRhLnByaW1hcnlLZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRzID0gT2JqZWN0LmVudHJpZXMocGspLm1hcCgoW2MsIHZdKSA9PiBgJHtjfSA9ICR7dHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3Z9J2AgOiB2fWApLmpvaW4oJyBBTkQgJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBgREVMRVRFIEZST00gJHttYXRjaFsyXX0gV0hFUkUgJHtjb25kc307YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwcGVyLnN0YXJ0c1dpdGgoJ0RFTEVURSBGUk9NJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL0RFTEVURVxccytGUk9NXFxzKyhbYFwiXT8pKFxcdyspXFwxL2kpO1xyXG4gICAgICAgIGlmIChtYXRjaCAmJiBtZXRhZGF0YT8ucm93cykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEucm93cy5tYXAoKHJvdzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xzID0gT2JqZWN0LmtleXMocm93KS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFscyA9IE9iamVjdC52YWx1ZXMocm93KS5tYXAodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7dn0nYCA6IHYpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYElOU0VSVCBJTlRPICR7bWF0Y2hbMl19ICgke2NvbHN9KSBWQUxVRVMgKCR7dmFsc30pO2A7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ01BTlVBTCc7XHJcbiAgICB9XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnVVBEQVRFJykpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IHEubWF0Y2goL1VQREFURVxccysoW2BcIl0/KShcXHcrKVxcMS9pKTtcclxuICAgICAgICBpZiAobWF0Y2ggJiYgbWV0YWRhdGE/Lm9sZFJvd3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhLm9sZFJvd3MubWFwKChyb3c6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBtZXRhZGF0YS5wcmltYXJ5S2V5RmllbGRzLnJlZHVjZSgoYWNjOiBhbnksIGY6IHN0cmluZykgPT4gKHsgLi4uYWNjLCBbZl06IHJvd1tmXSB9KSwge30pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gT2JqZWN0LmVudHJpZXMocm93KS5tYXAoKFtjLCB2XSkgPT4gYCR7Y30gPSAke3R5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGAnJHt2fSdgIDogdn1gKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlcmUgPSBPYmplY3QuZW50cmllcyhwaykubWFwKChbYywgdl0pID0+IGAke2N9ID0gJHt0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBgJyR7dn0nYCA6IHZ9YCkuam9pbignIEFORCAnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgVVBEQVRFICR7bWF0Y2hbMl19IFNFVCAke3NldH0gV0hFUkUgJHt3aGVyZX07YDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnTUFOVUFMJztcclxuICAgIH1cclxuXHJcbiAgICAvLyAxNC4gUEVSTUlTU0lPTlMgLyBBQ0xcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdHUkFOVCcpKSByZXR1cm4gcS5yZXBsYWNlKC9HUkFOVC9pLCAnUkVWT0tFJykucmVwbGFjZSgvVE8vaSwgJ0ZST00nKTtcclxuICAgIGlmICh1cHBlci5zdGFydHNXaXRoKCdSRVZPS0UnKSkgcmV0dXJuIHEucmVwbGFjZSgvUkVWT0tFL2ksICdHUkFOVCcpLnJlcGxhY2UoL0ZST00vaSwgJ1RPJyk7XHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ1JFQVRFIFJPTEUnKSkgcmV0dXJuIGBEUk9QIFJPTEUgJHtnZXRNYXRjaCgvQ1JFQVRFXFxzK1JPTEVcXHMrKFtgXCJdPykoXFx3KylcXDEvaSwgMil9O2A7XHJcblxyXG4gICAgLy8gMjAuIENPTU1FTlRTXHJcbiAgICBpZiAodXBwZXIuc3RhcnRzV2l0aCgnQ09NTUVOVCBPTicpKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IHEubWF0Y2goL0NPTU1FTlRcXHMrT05cXHMrKFRBQkxFfENPTFVNTilcXHMrKFtcXHNcXFNdKz8pXFxzK0lTL2kpO1xyXG4gICAgICAgIGlmIChtICYmIG1ldGFkYXRhPy5vbGRDb21tZW50ICE9PSB1bmRlZmluZWQpIHJldHVybiBgQ09NTUVOVCBPTiAke21bMV19ICR7bVsyXX0gSVMgJHttZXRhZGF0YS5vbGRDb21tZW50ID09PSBudWxsID8gJ05VTEwnIDogYCcke21ldGFkYXRhLm9sZENvbW1lbnR9J2B9O2A7XHJcbiAgICAgICAgcmV0dXJuICdNQU5VQUwnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnTUFOVUFMJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwZW5kaW5nIGNoYW5nZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdDaGFuZ2VzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUNoYW5nZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL3BlbmRpbmc/Y29ubmVjdGlvbklkPSR7Y29ubmVjdGlvbklkfWApO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhbmdlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBwZW5kaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbW1pdCBwZW5kaW5nIGNoYW5nZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21taXRDaGFuZ2VzKFxyXG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgICBhdXRob3I6IHsgbmFtZTogc3RyaW5nOyBlbWFpbDogc3RyaW5nIH1cclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBhd2FpdCBnZXRQZW5kaW5nQ2hhbmdlcyhjb25uZWN0aW9uSWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Zjcy9jb21taXQnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcixcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB0YWJsZXM6IHt9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb21taXQgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGNvbW1pdCBoaXN0b3J5IGZvciBhIGNvbm5lY3Rpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21taXRIaXN0b3J5KGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2NvbW1pdD9jb25uZWN0aW9uSWQ9JHtjb25uZWN0aW9uSWR9YCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gZGF0YS5jb21taXRzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNvbW1pdCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYnJhbmNoZXMgZm9yIGEgY29ubmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdmNzL2JyYW5jaGVzP2Nvbm5lY3Rpb25JZD0ke2Nvbm5lY3Rpb25JZH1gKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBkYXRhLmJyYW5jaGVzIHx8IFtdLCBjdXJyZW50QnJhbmNoOiBkYXRhLmN1cnJlbnRCcmFuY2ggfHwgJ21haW4nIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYnJhbmNoZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzOiBbXSwgY3VycmVudEJyYW5jaDogJ21haW4nIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgYnJhbmNoXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NyZWF0ZScgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGJyYW5jaDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogIFxyXG4gKiBDaGVja291dCBhIGJyYW5jaFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrb3V0QnJhbmNoKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92Y3MvYnJhbmNoZXMnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb25uZWN0aW9uSWQsIG5hbWUsIGFjdGlvbjogJ2NoZWNrb3V0JyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVja291dCBicmFuY2g6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidHJhY2tDaGFuZ2UiLCJjb25uZWN0aW9uSWQiLCJjaGFuZ2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsInRyYWNrU2NoZW1hQ2hhbmdlIiwib3BlcmF0aW9uIiwidGFibGVOYW1lIiwic3FsIiwiYXV0aG9yIiwidHlwZSIsInRvVXBwZXJDYXNlIiwidGFyZ2V0IiwiZGVzY3JpcHRpb24iLCJjaGFyQXQiLCJzbGljZSIsIm5hbWUiLCJxdWVyeSIsInJvbGxiYWNrU1FMIiwiZ2VuZXJhdGVSb2xsYmFja1NRTCIsInN0YXR1cyIsInBhcnNlUXVlcnlGb3JDaGFuZ2VzIiwiYWZmZWN0ZWRSb3dzIiwiY2xlYW5RdWVyeSIsInJlcGxhY2UiLCJ0cmltIiwibm9ybWFsaXplZFF1ZXJ5IiwibWF0Y2giLCJpbmNsdWRlcyIsInRvTG93ZXJDYXNlIiwiZHJvcE9iak1hdGNoIiwicHJvY01hdGNoIiwic3RhcnRzV2l0aCIsImlzTWVyZ2UiLCJvcCIsInNwbGl0IiwibWV0YWRhdGEiLCJxIiwidXBwZXIiLCJnZXRNYXRjaCIsInJlZ2V4IiwiZ3JvdXBJbmRleCIsIm0iLCJvbGRPd25lciIsIm9yaWdpbmFsQ3JlYXRlU1FMIiwibXQiLCJjb2x1bW5EZWZpbml0aW9uIiwib2xkRGVmYXVsdCIsInVuZGVmaW5lZCIsIm9sZENvbHVtblN0YXRlIiwib3JpZ2luYWxJbmRleFNRTCIsImlzTWF0Iiwib2xkVmlld0RlZmluaXRpb24iLCJvbGRCb2R5IiwiaXNFbmFibGUiLCJvcmlnaW5hbFNlcVNRTCIsIm9sZFNlcVN0YXRlIiwicHJpbWFyeUtleSIsInBrIiwiY29uZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiYyIsInYiLCJqb2luIiwicm93cyIsInJvdyIsImNvbHMiLCJrZXlzIiwidmFscyIsInZhbHVlcyIsIm9sZFJvd3MiLCJwcmltYXJ5S2V5RmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZiIsInNldCIsIndoZXJlIiwib2xkQ29tbWVudCIsImdldFBlbmRpbmdDaGFuZ2VzIiwicmVzcG9uc2UiLCJkYXRhIiwianNvbiIsImNoYW5nZXMiLCJjb21taXRDaGFuZ2VzIiwibWVzc2FnZSIsInBlbmRpbmciLCJzbmFwc2hvdCIsInNjaGVtYSIsInRhYmxlcyIsInRpbWVzdGFtcCIsIkRhdGUiLCJyZXN1bHQiLCJzdWNjZXNzIiwiZ2V0Q29tbWl0SGlzdG9yeSIsImNvbW1pdHMiLCJnZXRCcmFuY2hlcyIsImJyYW5jaGVzIiwiY3VycmVudEJyYW5jaCIsImNyZWF0ZUJyYW5jaCIsImFjdGlvbiIsImNoZWNrb3V0QnJhbmNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/vcs-helper.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/constants/index.ts":
/*!**************************************************!*\
  !*** ../../packages/core/src/constants/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CONNECTION_TIMEOUT: () => (/* binding */ DEFAULT_CONNECTION_TIMEOUT),\n/* harmony export */   DEFAULT_MAX_ROWS: () => (/* binding */ DEFAULT_MAX_ROWS),\n/* harmony export */   DEFAULT_PAGE_SIZE: () => (/* binding */ DEFAULT_PAGE_SIZE),\n/* harmony export */   DEFAULT_POOL_SIZE: () => (/* binding */ DEFAULT_POOL_SIZE),\n/* harmony export */   DEFAULT_PORTS: () => (/* binding */ DEFAULT_PORTS),\n/* harmony export */   DEFAULT_QUERY_TIMEOUT: () => (/* binding */ DEFAULT_QUERY_TIMEOUT),\n/* harmony export */   IDLE_TIMEOUT: () => (/* binding */ IDLE_TIMEOUT),\n/* harmony export */   MAX_PAGE_SIZE: () => (/* binding */ MAX_PAGE_SIZE),\n/* harmony export */   MAX_POOL_SIZE: () => (/* binding */ MAX_POOL_SIZE),\n/* harmony export */   MAX_QUERY_TIMEOUT: () => (/* binding */ MAX_QUERY_TIMEOUT),\n/* harmony export */   MAX_ROWS_LIMIT: () => (/* binding */ MAX_ROWS_LIMIT),\n/* harmony export */   RATE_LIMIT: () => (/* binding */ RATE_LIMIT)\n/* harmony export */ });\n/**\n * Application-wide constants\n */ // Query Limits\nconst DEFAULT_QUERY_TIMEOUT = 30000; // 30 seconds\nconst MAX_QUERY_TIMEOUT = 300000; // 5 minutes\nconst DEFAULT_MAX_ROWS = 1000;\nconst MAX_ROWS_LIMIT = 100000;\n// Connection Limits\nconst DEFAULT_CONNECTION_TIMEOUT = 5000; // 5 seconds\nconst DEFAULT_POOL_SIZE = 10;\nconst MAX_POOL_SIZE = 50;\nconst IDLE_TIMEOUT = 30000; // 30 seconds\n// Rate Limits\nconst RATE_LIMIT = {\n    queriesPerMinute: 30,\n    connectionsPerWorkspace: 10,\n    maxConcurrentQueries: 5,\n    savedQueriesPerWorkspace: 100\n};\n// Database Default Ports\nconst DEFAULT_PORTS = {\n    postgresql: 5432,\n    mysql: 3306,\n    mongodb: 27017\n};\n// Pagination\nconst DEFAULT_PAGE_SIZE = 50;\nconst MAX_PAGE_SIZE = 1000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY29uc3RhbnRzL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRUQsZUFBZTtBQUNSLE1BQU1BLHdCQUF3QixNQUFNLENBQUMsYUFBYTtBQUNsRCxNQUFNQyxvQkFBb0IsT0FBTyxDQUFDLFlBQVk7QUFDOUMsTUFBTUMsbUJBQW1CLEtBQUs7QUFDOUIsTUFBTUMsaUJBQWlCLE9BQU87QUFFckMsb0JBQW9CO0FBQ2IsTUFBTUMsNkJBQTZCLEtBQUssQ0FBQyxZQUFZO0FBQ3JELE1BQU1DLG9CQUFvQixHQUFHO0FBQzdCLE1BQU1DLGdCQUFnQixHQUFHO0FBQ3pCLE1BQU1DLGVBQWUsTUFBTSxDQUFDLGFBQWE7QUFFaEQsY0FBYztBQUNQLE1BQU1DLGFBQWE7SUFDdEJDLGtCQUFrQjtJQUNsQkMseUJBQXlCO0lBQ3pCQyxzQkFBc0I7SUFDdEJDLDBCQUEwQjtBQUM5QixFQUFXO0FBRVgseUJBQXlCO0FBQ2xCLE1BQU1DLGdCQUF3QztJQUNqREMsWUFBWTtJQUNaQyxPQUFPO0lBQ1BDLFNBQVM7QUFDYixFQUFFO0FBS0YsYUFBYTtBQUNOLE1BQU1DLG9CQUFvQixHQUFHO0FBQzdCLE1BQU1DLGdCQUFnQixLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9jb25zdGFudHMvaW5kZXgudHM/ZTc4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFwcGxpY2F0aW9uLXdpZGUgY29uc3RhbnRzXG4gKi9cblxuLy8gUXVlcnkgTGltaXRzXG5leHBvcnQgY29uc3QgREVGQVVMVF9RVUVSWV9USU1FT1VUID0gMzAwMDA7IC8vIDMwIHNlY29uZHNcbmV4cG9ydCBjb25zdCBNQVhfUVVFUllfVElNRU9VVCA9IDMwMDAwMDsgLy8gNSBtaW51dGVzXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfUk9XUyA9IDEwMDA7XG5leHBvcnQgY29uc3QgTUFYX1JPV1NfTElNSVQgPSAxMDAwMDA7XG5cbi8vIENvbm5lY3Rpb24gTGltaXRzXG5leHBvcnQgY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1MDAwOyAvLyA1IHNlY29uZHNcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xuZXhwb3J0IGNvbnN0IE1BWF9QT09MX1NJWkUgPSA1MDtcbmV4cG9ydCBjb25zdCBJRExFX1RJTUVPVVQgPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuXG4vLyBSYXRlIExpbWl0c1xuZXhwb3J0IGNvbnN0IFJBVEVfTElNSVQgPSB7XG4gICAgcXVlcmllc1Blck1pbnV0ZTogMzAsXG4gICAgY29ubmVjdGlvbnNQZXJXb3Jrc3BhY2U6IDEwLFxuICAgIG1heENvbmN1cnJlbnRRdWVyaWVzOiA1LFxuICAgIHNhdmVkUXVlcmllc1BlcldvcmtzcGFjZTogMTAwLFxufSBhcyBjb25zdDtcblxuLy8gRGF0YWJhc2UgRGVmYXVsdCBQb3J0c1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUE9SVFM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgcG9zdGdyZXNxbDogNTQzMixcbiAgICBteXNxbDogMzMwNixcbiAgICBtb25nb2RiOiAyNzAxNyxcbn07XG5cbi8vIEV4cG9ydCBGb3JtYXRcbmV4cG9ydCB0eXBlIEV4cG9ydEZvcm1hdCA9ICdjc3YnIHwgJ2pzb24nIHwgJ3NxbCc7XG5cbi8vIFBhZ2luYXRpb25cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BBR0VfU0laRSA9IDUwO1xuZXhwb3J0IGNvbnN0IE1BWF9QQUdFX1NJWkUgPSAxMDAwO1xuIl0sIm5hbWVzIjpbIkRFRkFVTFRfUVVFUllfVElNRU9VVCIsIk1BWF9RVUVSWV9USU1FT1VUIiwiREVGQVVMVF9NQVhfUk9XUyIsIk1BWF9ST1dTX0xJTUlUIiwiREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJERUZBVUxUX1BPT0xfU0laRSIsIk1BWF9QT09MX1NJWkUiLCJJRExFX1RJTUVPVVQiLCJSQVRFX0xJTUlUIiwicXVlcmllc1Blck1pbnV0ZSIsImNvbm5lY3Rpb25zUGVyV29ya3NwYWNlIiwibWF4Q29uY3VycmVudFF1ZXJpZXMiLCJzYXZlZFF1ZXJpZXNQZXJXb3Jrc3BhY2UiLCJERUZBVUxUX1BPUlRTIiwicG9zdGdyZXNxbCIsIm15c3FsIiwibW9uZ29kYiIsIkRFRkFVTFRfUEFHRV9TSVpFIiwiTUFYX1BBR0VfU0laRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/constants/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/index.ts":
/*!****************************************!*\
  !*** ../../packages/core/src/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BosDBError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.BosDBError),\n/* harmony export */   ConnectionError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionError),\n/* harmony export */   DEFAULT_CONNECTION_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CONNECTION_TIMEOUT),\n/* harmony export */   DEFAULT_MAX_ROWS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_MAX_ROWS),\n/* harmony export */   DEFAULT_PAGE_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PAGE_SIZE),\n/* harmony export */   DEFAULT_POOL_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_POOL_SIZE),\n/* harmony export */   DEFAULT_PORTS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PORTS),\n/* harmony export */   DEFAULT_QUERY_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_QUERY_TIMEOUT),\n/* harmony export */   IDLE_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.IDLE_TIMEOUT),\n/* harmony export */   MAX_PAGE_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_PAGE_SIZE),\n/* harmony export */   MAX_POOL_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_POOL_SIZE),\n/* harmony export */   MAX_QUERY_TIMEOUT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_QUERY_TIMEOUT),\n/* harmony export */   MAX_ROWS_LIMIT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MAX_ROWS_LIMIT),\n/* harmony export */   QueryExecutionError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.QueryExecutionError),\n/* harmony export */   RATE_LIMIT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.RATE_LIMIT),\n/* harmony export */   SecurityError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.SecurityError),\n/* harmony export */   ValidationError: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.ValidationError)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(rsc)/../../packages/core/src/types/index.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(rsc)/../../packages/core/src/constants/index.ts\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9pbmRleC50cz8zYjk3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/core/src/types/index.ts":
/*!**********************************************!*\
  !*** ../../packages/core/src/types/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BosDBError: () => (/* binding */ BosDBError),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   QueryExecutionError: () => (/* binding */ QueryExecutionError),\n/* harmony export */   SecurityError: () => (/* binding */ SecurityError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError)\n/* harmony export */ });\n/**\n * Core type definitions for BosDB\n */ // Database Types\n// Error Types\nclass BosDBError extends Error {\n    constructor(message, code, details){\n        super(message);\n        this.code = code;\n        this.details = details;\n        this.name = \"BosDBError\";\n    }\n}\nclass ConnectionError extends BosDBError {\n    constructor(message, details){\n        super(message, \"CONNECTION_ERROR\", details);\n        this.name = \"ConnectionError\";\n    }\n}\nclass QueryExecutionError extends BosDBError {\n    constructor(message, details){\n        super(message, \"QUERY_EXECUTION_ERROR\", details);\n        this.name = \"QueryExecutionError\";\n    }\n}\nclass SecurityError extends BosDBError {\n    constructor(message, details){\n        super(message, \"SECURITY_ERROR\", details);\n        this.name = \"SecurityError\";\n    }\n}\nclass ValidationError extends BosDBError {\n    constructor(message, details){\n        super(message, \"VALIDATION_ERROR\", details);\n        this.name = \"ValidationError\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvdHlwZXMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELGlCQUFpQjtBQStNakIsY0FBYztBQUNQLE1BQU1BLG1CQUFtQkM7SUFDNUJDLFlBQ0lDLE9BQWUsRUFDZixJQUFvQixFQUNwQixPQUFvQixDQUN0QjtRQUNFLEtBQUssQ0FBQ0E7YUFIQ0MsT0FBQUE7YUFDQUMsVUFBQUE7UUFHUCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBRU8sTUFBTUMsd0JBQXdCUDtJQUNqQ0UsWUFBWUMsT0FBZSxFQUFFRSxPQUFhLENBQUU7UUFDeEMsS0FBSyxDQUFDRixTQUFTLG9CQUFvQkU7UUFDbkMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUVPLE1BQU1FLDRCQUE0QlI7SUFDckNFLFlBQVlDLE9BQWUsRUFBRUUsT0FBYSxDQUFFO1FBQ3hDLEtBQUssQ0FBQ0YsU0FBUyx5QkFBeUJFO1FBQ3hDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFFTyxNQUFNRyxzQkFBc0JUO0lBQy9CRSxZQUFZQyxPQUFlLEVBQUVFLE9BQWEsQ0FBRTtRQUN4QyxLQUFLLENBQUNGLFNBQVMsa0JBQWtCRTtRQUNqQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBRU8sTUFBTUksd0JBQXdCVjtJQUNqQ0UsWUFBWUMsT0FBZSxFQUFFRSxPQUFhLENBQUU7UUFDeEMsS0FBSyxDQUFDRixTQUFTLG9CQUFvQkU7UUFDbkMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvdHlwZXMvaW5kZXgudHM/Y2U3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcmUgdHlwZSBkZWZpbml0aW9ucyBmb3IgQm9zREJcbiAqL1xuXG4vLyBEYXRhYmFzZSBUeXBlc1xuZXhwb3J0IHR5cGUgRGF0YWJhc2VUeXBlID0gJ3Bvc3RncmVzcWwnIHwgJ215c3FsJyB8ICdtYXJpYWRiJyB8ICdtb25nb2RiJyB8ICdyZWRpcyc7XG5cbmV4cG9ydCB0eXBlIERhdGFiYXNlU3RhdHVzID0gJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJyB8ICdlcnJvcic7XG5cbi8vIFVzZXIgJiBXb3Jrc3BhY2UgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgY3JlYXRlZEF0OiBEYXRlO1xuICAgIHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3Jrc3BhY2Uge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG93bmVySWQ6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtzcGFjZU1lbWJlciB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIHVzZXJJZDogc3RyaW5nO1xuICAgIHJvbGU6ICdvd25lcicgfCAnYWRtaW4nIHwgJ21lbWJlcicgfCAndmlld2VyJztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG59XG5cbi8vIENvbm5lY3Rpb24gVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBEYXRhYmFzZVR5cGU7XG4gICAgaG9zdDogc3RyaW5nO1xuICAgIHBvcnQ6IG51bWJlcjtcbiAgICBkYXRhYmFzZTogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgcmVhZE9ubHk6IGJvb2xlYW47XG4gICAgc3RhdHVzOiBEYXRhYmFzZVN0YXR1cztcbiAgICBjcmVhdGVkQnk6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25Db25maWcge1xuICAgIGlkPzogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBob3N0OiBzdHJpbmc7XG4gICAgcG9ydDogbnVtYmVyO1xuICAgIGRhdGFiYXNlOiBzdHJpbmc7XG4gICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIHNzbD86IGJvb2xlYW47XG4gICAgcmVhZE9ubHk/OiBib29sZWFuO1xuICAgIGNvbm5lY3Rpb25UaW1lb3V0PzogbnVtYmVyO1xuICAgIHF1ZXJ5VGltZW91dD86IG51bWJlcjtcbiAgICBtYXhQb29sU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uUmVzdWx0IHtcbiAgICBjb25uZWN0aW9uSWQ6IHN0cmluZztcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIHZlcnNpb24/OiBzdHJpbmc7XG4gICAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdFJlc3VsdCB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICAgIGxhdGVuY3k/OiBudW1iZXI7XG59XG5cbi8vIFF1ZXJ5IFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5UmVxdWVzdCB7XG4gICAgY29ubmVjdGlvbklkOiBzdHJpbmc7XG4gICAgcXVlcnk6IHN0cmluZztcbiAgICB0aW1lb3V0PzogbnVtYmVyO1xuICAgIG1heFJvd3M/OiBudW1iZXI7XG4gICAgc3RyZWFtUmVzdWx0cz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlSZXN1bHQge1xuICAgIHJvd3M6IGFueVtdO1xuICAgIGZpZWxkczogUXVlcnlGaWVsZFtdO1xuICAgIHJvd0NvdW50OiBudW1iZXI7XG4gICAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICAgIGhhc01vcmU/OiBib29sZWFuO1xuICAgIGN1cnNvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUZpZWxkIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgICB0YWJsZUlEPzogbnVtYmVyO1xuICAgIGNvbHVtbklEPzogbnVtYmVyO1xuICAgIG51bGxhYmxlPzogYm9vbGVhbjtcbiAgICBpc1ByaW1hcnlLZXk/OiBib29sZWFuO1xuICAgIGlzRm9yZWlnbktleT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblJlc3VsdCB7XG4gICAgcGxhbjogYW55O1xuICAgIGV4ZWN1dGlvblRpbWU/OiBudW1iZXI7XG4gICAgdG90YWxDb3N0PzogbnVtYmVyO1xuICAgIHBsYW5UZXh0Pzogc3RyaW5nO1xufVxuXG4vLyBTY2hlbWEgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb3duZXI/OiBzdHJpbmc7XG4gICAgdGFibGVDb3VudD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZSB7XG4gICAgc2NoZW1hOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHR5cGU6ICd0YWJsZScgfCAndmlldycgfCAnbWF0ZXJpYWxpemVkX3ZpZXcnO1xuICAgIHJvd0NvdW50PzogbnVtYmVyO1xuICAgIHNpemU/OiBzdHJpbmc7XG4gICAgY29tbWVudD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU1ldGFkYXRhIHtcbiAgICBzY2hlbWE6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogQ29sdW1uW107XG4gICAgcHJpbWFyeUtleXM6IHN0cmluZ1tdO1xuICAgIGZvcmVpZ25LZXlzOiBGb3JlaWduS2V5W107XG4gICAgaW5kZXhlczogSW5kZXhbXTtcbiAgICByb3dDb3VudD86IG51bWJlcjtcbiAgICBzaXplPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGRhdGFUeXBlOiBzdHJpbmc7XG4gICAgbWF4TGVuZ3RoPzogbnVtYmVyO1xuICAgIHByZWNpc2lvbj86IG51bWJlcjtcbiAgICBzY2FsZT86IG51bWJlcjtcbiAgICBudWxsYWJsZTogYm9vbGVhbjtcbiAgICBkZWZhdWx0VmFsdWU/OiBzdHJpbmc7XG4gICAgaXNQcmltYXJ5S2V5OiBib29sZWFuO1xuICAgIGlzRm9yZWlnbktleTogYm9vbGVhbjtcbiAgICBjb21tZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogc3RyaW5nW107XG4gICAgdW5pcXVlOiBib29sZWFuO1xuICAgIHByaW1hcnk6IGJvb2xlYW47XG4gICAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JlaWduS2V5IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgY29sdW1uczogc3RyaW5nW107XG4gICAgcmVmZXJlbmNlZFRhYmxlOiBzdHJpbmc7XG4gICAgcmVmZXJlbmNlZENvbHVtbnM6IHN0cmluZ1tdO1xuICAgIG9uRGVsZXRlPzogc3RyaW5nO1xuICAgIG9uVXBkYXRlPzogc3RyaW5nO1xufVxuXG4vLyBTYXZlZCBRdWVyeSBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBTYXZlZFF1ZXJ5IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgY29ubmVjdGlvbklkPzogc3RyaW5nO1xuICAgIGNyZWF0ZWRCeTogc3RyaW5nO1xuICAgIGNyZWF0ZWRBdDogRGF0ZTtcbiAgICB1cGRhdGVkQXQ6IERhdGU7XG4gICAgdGFncz86IHN0cmluZ1tdO1xufVxuXG4vLyBRdWVyeSBIaXN0b3J5IFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5SGlzdG9yeSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nO1xuICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICAgIHJvd0NvdW50OiBudW1iZXI7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICBleGVjdXRlZEJ5OiBzdHJpbmc7XG4gICAgZXhlY3V0ZWRBdDogRGF0ZTtcbn1cblxuLy8gRGF0YWJhc2UgSW5mb1xuZXhwb3J0IGludGVyZmFjZSBEYXRhYmFzZUluZm8ge1xuICAgIHZlcnNpb246IHN0cmluZztcbiAgICBzZXJ2ZXJWZXJzaW9uPzogc3RyaW5nO1xuICAgIHVwdGltZT86IG51bWJlcjtcbiAgICBjdXJyZW50RGF0YWJhc2U/OiBzdHJpbmc7XG4gICAgY3VycmVudFVzZXI/OiBzdHJpbmc7XG4gICAgZW5jb2Rpbmc/OiBzdHJpbmc7XG4gICAgY29sbGF0aW9uPzogc3RyaW5nO1xufVxuXG4vLyBFcnJvciBUeXBlc1xuZXhwb3J0IGNsYXNzIEJvc0RCRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGNvZGU/OiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBkZXRhaWxzPzogYW55XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQm9zREJFcnJvcic7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQm9zREJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzPzogYW55KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdDT05ORUNUSU9OX0VSUk9SJywgZGV0YWlscyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDb25uZWN0aW9uRXJyb3InO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFF1ZXJ5RXhlY3V0aW9uRXJyb3IgZXh0ZW5kcyBCb3NEQkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM/OiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ1FVRVJZX0VYRUNVVElPTl9FUlJPUicsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUXVlcnlFeGVjdXRpb25FcnJvcic7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VjdXJpdHlFcnJvciBleHRlbmRzIEJvc0RCRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlscz86IGFueSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnU0VDVVJJVFlfRVJST1InLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NlY3VyaXR5RXJyb3InO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEJvc0RCRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlscz86IGFueSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnVkFMSURBVElPTl9FUlJPUicsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQm9zREJFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsImRldGFpbHMiLCJuYW1lIiwiQ29ubmVjdGlvbkVycm9yIiwiUXVlcnlFeGVjdXRpb25FcnJvciIsIlNlY3VyaXR5RXJyb3IiLCJWYWxpZGF0aW9uRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/core/src/types/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/AdapterFactory.ts":
/*!********************************************************!*\
  !*** ../../packages/db-adapters/src/AdapterFactory.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterFactory: () => (/* binding */ AdapterFactory)\n/* harmony export */ });\n/* harmony import */ var _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/postgresql/PostgreSQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\");\n/* harmony import */ var _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/mysql/MySQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts\");\n/* harmony import */ var _adapters_mongodb_MongoDBAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapters/mongodb/MongoDBAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts\");\n/* harmony import */ var _adapters_redis_RedisAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adapters/redis/RedisAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__]);\n_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n/**\n * Factory for creating database adapter instances\n */ class AdapterFactory {\n    /**\n     * Create a database adapter instance based on the database type\n     * @param type Database type ('postgresql', 'mysql', 'mongodb', 'redis', 'mariadb', etc.)\n     * @returns Database adapter instance\n     */ static create(type) {\n        switch(type.toLowerCase()){\n            case \"postgresql\":\n            case \"postgres\":\n                return new _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_0__.PostgreSQLAdapter();\n            case \"mysql\":\n                return new _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__.MySQLAdapter();\n            case \"mariadb\":\n                // MariaDB is MySQL-compatible, use MySQL adapter\n                return new _adapters_mysql_MySQLAdapter__WEBPACK_IMPORTED_MODULE_1__.MySQLAdapter();\n            case \"mongodb\":\n            case \"mongo\":\n                return new _adapters_mongodb_MongoDBAdapter__WEBPACK_IMPORTED_MODULE_2__.MongoDBAdapter();\n            case \"redis\":\n                return new _adapters_redis_RedisAdapter__WEBPACK_IMPORTED_MODULE_3__.RedisAdapter();\n            default:\n                throw new Error(`Unsupported database type: ${type}`);\n        }\n    }\n    /**\n     * Get list of supported database types\n     */ static getSupportedTypes() {\n        return [\n            \"postgresql\",\n            \"mysql\",\n            \"mariadb\",\n            \"mongodb\",\n            \"redis\"\n        ];\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL0FkYXB0ZXJGYWN0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRTRFO0FBQ2Y7QUFDTTtBQUNOO0FBRTdEOztDQUVDLEdBQ00sTUFBTUk7SUFDVDs7OztLQUlDLEdBQ0QsT0FBT0MsT0FBT0MsSUFBWSxFQUFjO1FBQ3BDLE9BQVFBLEtBQUtDLFdBQVc7WUFDcEIsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJUCxxRkFBaUJBO1lBRWhDLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJQyxzRUFBWUE7WUFFM0IsS0FBSztnQkFDRCxpREFBaUQ7Z0JBQ2pELE9BQU8sSUFBSUEsc0VBQVlBO1lBRTNCLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU8sSUFBSUMsNEVBQWNBO1lBRTdCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJQyxzRUFBWUE7WUFFM0I7Z0JBQ0ksTUFBTSxJQUFJSyxNQUFNLENBQUMsMkJBQTJCLEVBQUVGLEtBQUssQ0FBQztRQUM1RDtJQUNKO0lBRUE7O0tBRUMsR0FDRCxPQUFPRyxvQkFBb0M7UUFDdkMsT0FBTztZQUFDO1lBQWM7WUFBUztZQUFXO1lBQVc7U0FBUTtJQUNqRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvQWRhcHRlckZhY3RvcnkudHM/OGU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERhdGFiYXNlVHlwZSB9IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB0eXBlIHsgSURCQWRhcHRlciB9IGZyb20gJy4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB7IFBvc3RncmVTUUxBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9wb3N0Z3Jlc3FsL1Bvc3RncmVTUUxBZGFwdGVyJztcbmltcG9ydCB7IE15U1FMQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvbXlzcWwvTXlTUUxBZGFwdGVyJztcbmltcG9ydCB7IE1vbmdvREJBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9tb25nb2RiL01vbmdvREJBZGFwdGVyJztcbmltcG9ydCB7IFJlZGlzQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvcmVkaXMvUmVkaXNBZGFwdGVyJztcblxuLyoqXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyBkYXRhYmFzZSBhZGFwdGVyIGluc3RhbmNlc1xuICovXG5leHBvcnQgY2xhc3MgQWRhcHRlckZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRhdGFiYXNlIGFkYXB0ZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGRhdGFiYXNlIHR5cGVcbiAgICAgKiBAcGFyYW0gdHlwZSBEYXRhYmFzZSB0eXBlICgncG9zdGdyZXNxbCcsICdteXNxbCcsICdtb25nb2RiJywgJ3JlZGlzJywgJ21hcmlhZGInLCBldGMuKVxuICAgICAqIEByZXR1cm5zIERhdGFiYXNlIGFkYXB0ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHR5cGU6IHN0cmluZyk6IElEQkFkYXB0ZXIge1xuICAgICAgICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncG9zdGdyZXNxbCc6XG4gICAgICAgICAgICBjYXNlICdwb3N0Z3Jlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3JlU1FMQWRhcHRlcigpO1xuXG4gICAgICAgICAgICBjYXNlICdteXNxbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNeVNRTEFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSAnbWFyaWFkYic6XG4gICAgICAgICAgICAgICAgLy8gTWFyaWFEQiBpcyBNeVNRTC1jb21wYXRpYmxlLCB1c2UgTXlTUUwgYWRhcHRlclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXlTUUxBZGFwdGVyKCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vbmdvZGInOlxuICAgICAgICAgICAgY2FzZSAnbW9uZ28nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9uZ29EQkFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSAncmVkaXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVkaXNBZGFwdGVyKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGlzdCBvZiBzdXBwb3J0ZWQgZGF0YWJhc2UgdHlwZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3VwcG9ydGVkVHlwZXMoKTogRGF0YWJhc2VUeXBlW10ge1xuICAgICAgICByZXR1cm4gWydwb3N0Z3Jlc3FsJywgJ215c3FsJywgJ21hcmlhZGInLCAnbW9uZ29kYicsICdyZWRpcyddO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJQb3N0Z3JlU1FMQWRhcHRlciIsIk15U1FMQWRhcHRlciIsIk1vbmdvREJBZGFwdGVyIiwiUmVkaXNBZGFwdGVyIiwiQWRhcHRlckZhY3RvcnkiLCJjcmVhdGUiLCJ0eXBlIiwidG9Mb3dlckNhc2UiLCJFcnJvciIsImdldFN1cHBvcnRlZFR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/AdapterFactory.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts":
/*!*************************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MongoDBAdapter: () => (/* binding */ MongoDBAdapter)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"(rsc)/../../packages/db-adapters/node_modules/mongodb/lib/index.js\");\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"MongoDBAdapter\");\n/**\n * MongoDB Database Adapter\n * Implements IDBAdapter for MongoDB databases\n * \n * Note: MongoDB is document-oriented (NoSQL), so some SQL concepts don't apply:\n * - Schemas -> Databases\n * - Tables -> Collections\n * - Columns -> Document fields (dynamic)\n * - Query -> Aggregation pipelines or find operations\n */ class MongoDBAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"mongodb\");\n        try {\n            // Build MongoDB connection string\n            const uri = `mongodb://${config.username}:${config.password}@${config.host}:${config.port || 27017}/${config.database}?authSource=admin`;\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                connectTimeoutMS: config.connectionTimeout || 10000,\n                serverSelectionTimeoutMS: config.connectionTimeout || 10000\n            });\n            await client.connect();\n            const db = client.db(config.database);\n            // Test connection by running a simple command\n            const adminDb = client.db(\"admin\");\n            const serverInfo = await adminDb.command({\n                serverStatus: 1\n            });\n            this.clients.set(connectionId, client);\n            this.databases.set(connectionId, db);\n            logger.info(`Connected to MongoDB: ${config.host}:${config.port}/${config.database}`);\n            return {\n                connectionId,\n                success: true,\n                version: serverInfo.version\n            };\n        } catch (error) {\n            logger.error(`MongoDB connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (client) {\n            await client.close();\n            this.clients.delete(connectionId);\n            this.databases.delete(connectionId);\n            logger.info(`Disconnected from MongoDB: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const uri = `mongodb://${config.username}:${config.password}@${config.host}:${config.port || 27017}/${config.database}?authSource=admin`;\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                connectTimeoutMS: 5000,\n                serverSelectionTimeoutMS: 5000\n            });\n            await client.connect();\n            await client.db(\"admin\").command({\n                ping: 1\n            });\n            await client.close();\n            return {\n                success: true,\n                message: \"MongoDB connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`MongoDB test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const result = await adminDb.command({\n                listDatabases: 1\n            });\n            const schemas = [];\n            for (const dbInfo of result.databases){\n                if ([\n                    \"admin\",\n                    \"local\",\n                    \"config\"\n                ].includes(dbInfo.name)) {\n                    continue; // Skip system databases\n                }\n                // Get collection count for each database\n                const db = client.db(dbInfo.name);\n                const collections = await db.listCollections().toArray();\n                schemas.push({\n                    name: dbInfo.name,\n                    tableCount: collections.length\n                });\n            }\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list MongoDB databases: ${error.message}`, error);\n            throw new Error(`Failed to list databases: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const db = this.databases.get(connectionId);\n        const client = this.clients.get(connectionId);\n        if (!db || !client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        const dbName = schemaName || db.databaseName;\n        const targetDb = client.db(dbName);\n        try {\n            const collections = await targetDb.listCollections().toArray();\n            const tables = [];\n            for (const coll of collections){\n                // Get document count\n                const collection = targetDb.collection(coll.name);\n                const count = await collection.estimatedDocumentCount();\n                tables.push({\n                    schema: dbName,\n                    name: coll.name,\n                    type: coll.type === \"view\" ? \"view\" : \"table\",\n                    rowCount: count\n                });\n            }\n            return tables;\n        } catch (error) {\n            logger.error(`Failed to list MongoDB collections: ${error.message}`, error);\n            throw new Error(`Failed to list collections: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const db = client.db(schemaName);\n            const collection = db.collection(tableName);\n            // Sample documents to infer schema (MongoDB has dynamic schema)\n            const sampleDocs = await collection.find({}).limit(100).toArray();\n            // Infer fields from sample documents\n            const fieldSet = new Set();\n            for (const doc of sampleDocs){\n                Object.keys(doc).forEach((key)=>fieldSet.add(key));\n            }\n            const columns = Array.from(fieldSet).map((fieldName)=>({\n                    name: fieldName,\n                    dataType: this.inferMongoType(sampleDocs, fieldName),\n                    nullable: true,\n                    defaultValue: undefined,\n                    isPrimaryKey: fieldName === \"_id\",\n                    isForeignKey: false\n                }));\n            // Get indexes\n            const indexes = await this.getIndexes(connectionId, schemaName, tableName);\n            // Get document count\n            const rowCount = await collection.estimatedDocumentCount();\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys: [\n                    \"_id\"\n                ],\n                foreignKeys: [],\n                indexes,\n                rowCount\n            };\n        } catch (error) {\n            logger.error(`Failed to describe MongoDB collection: ${error.message}`, error);\n            throw new Error(`Failed to describe collection: ${error.message}`);\n        }\n    }\n    async getIndexes(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const db = client.db(schemaName);\n            const collection = db.collection(tableName);\n            const indexInfo = await collection.indexes();\n            return indexInfo.map((idx)=>({\n                    name: idx.name || \"unknown\",\n                    columns: Object.keys(idx.key),\n                    unique: idx.unique || false,\n                    primary: idx.name === \"_id_\",\n                    type: \"btree\"\n                }));\n        } catch (error) {\n            logger.error(`Failed to get MongoDB indexes: ${error.message}`, error);\n            throw new Error(`Failed to get indexes: ${error.message}`);\n        }\n    }\n    async executeQuery(request) {\n        const db = this.databases.get(request.connectionId);\n        if (!db) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            // Parse MongoDB query (JSON format)\n            // Supports: { \"find\": \"collection\", \"filter\": {...}, \"limit\": 10 }\n            // Or aggregation: { \"aggregate\": \"collection\", \"pipeline\": [...] }\n            const queryObj = JSON.parse(request.query);\n            let rows = [];\n            let fields = [];\n            if (queryObj.find) {\n                // Find operation\n                const collection = db.collection(queryObj.find);\n                const filter = queryObj.filter || {};\n                const options = {};\n                if (queryObj.sort) options.sort = queryObj.sort;\n                if (queryObj.limit) options.limit = queryObj.limit;\n                if (queryObj.skip) options.skip = queryObj.skip;\n                rows = await collection.find(filter, options).toArray();\n            } else if (queryObj.aggregate) {\n                // Aggregation pipeline\n                const collection = db.collection(queryObj.aggregate);\n                const pipeline = queryObj.pipeline || [];\n                rows = await collection.aggregate(pipeline).toArray();\n            } else {\n                throw new Error('Invalid query format. Use {\"find\": \"collection\", \"filter\": {...}} or {\"aggregate\": \"collection\", \"pipeline\": [...]}');\n            }\n            // Infer fields from results\n            if (rows.length > 0) {\n                const fieldNames = new Set();\n                rows.forEach((row)=>Object.keys(row).forEach((key)=>fieldNames.add(key)));\n                fields = Array.from(fieldNames).map((name)=>({\n                        name,\n                        dataType: \"mixed\"\n                    }));\n            }\n            const executionTime = Date.now() - startTime;\n            return {\n                rows: rows.slice(0, request.maxRows || 1000),\n                fields,\n                rowCount: rows.length,\n                executionTime,\n                hasMore: rows.length > (request.maxRows || 1000)\n            };\n        } catch (error) {\n            logger.error(`MongoDB query execution failed: ${error.message}`, error);\n            throw new Error(`Query execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const db = this.databases.get(connectionId);\n        if (!db) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const queryObj = JSON.parse(query);\n            if (queryObj.find) {\n                const collection = db.collection(queryObj.find);\n                const explainResult = await collection.find(queryObj.filter || {}).explain();\n                return {\n                    plan: explainResult,\n                    planText: JSON.stringify(explainResult, null, 2)\n                };\n            } else if (queryObj.aggregate) {\n                const collection = db.collection(queryObj.aggregate);\n                const explainResult = await collection.aggregate(queryObj.pipeline || [], {\n                    explain: true\n                }).toArray();\n                return {\n                    plan: explainResult,\n                    planText: JSON.stringify(explainResult, null, 2)\n                };\n            }\n            throw new Error(\"Cannot explain this query type\");\n        } catch (error) {\n            logger.error(`MongoDB EXPLAIN failed: ${error.message}`, error);\n            throw new Error(`EXPLAIN failed: ${error.message}`);\n        }\n    }\n    async getVersion(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const buildInfo = await adminDb.command({\n                buildInfo: 1\n            });\n            return buildInfo.version;\n        } catch (error) {\n            logger.error(`Failed to get MongoDB version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const client = this.clients.get(connectionId);\n        const db = this.databases.get(connectionId);\n        if (!client || !db) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const adminDb = client.db(\"admin\");\n            const serverStatus = await adminDb.command({\n                serverStatus: 1\n            });\n            return {\n                version: serverStatus.version,\n                serverVersion: serverStatus.version,\n                uptime: serverStatus.uptime,\n                currentDatabase: db.databaseName,\n                currentUser: serverStatus.connections?.current?.toString()\n            };\n        } catch (error) {\n            logger.error(`Failed to get MongoDB database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    /**\n     * Infer MongoDB field type from sample documents\n     */ inferMongoType(docs, fieldName) {\n        const types = new Set();\n        for (const doc of docs){\n            const value = doc[fieldName];\n            if (value === null || value === undefined) continue;\n            const type = Array.isArray(value) ? \"array\" : typeof value;\n            types.add(type);\n        }\n        if (types.size === 0) return \"null\";\n        if (types.size === 1) return Array.from(types)[0];\n        return \"mixed\";\n    }\n    constructor(...args){\n        super(...args);\n        this.clients = new Map();\n        this.databases = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL21vbmdvZGIvTW9uZ29EQkFkYXB0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNRO0FBZ0J0QjtBQUV0QyxNQUFNRyxTQUFTLElBQUlELGdEQUFNQSxDQUFDO0FBRTFCOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1FLHVCQUF1QkgsaUVBQWFBO0lBSTdDLE1BQU1JLFFBQVFDLE1BQXdCLEVBQTZCO1FBQy9ELE1BQU1DLGVBQWUsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQztRQUUvQyxJQUFJO1lBQ0Esa0NBQWtDO1lBQ2xDLE1BQU1DLE1BQU0sQ0FBQyxVQUFVLEVBQUVILE9BQU9JLFFBQVEsQ0FBQyxDQUFDLEVBQUVKLE9BQU9LLFFBQVEsQ0FBQyxDQUFDLEVBQUVMLE9BQU9NLElBQUksQ0FBQyxDQUFDLEVBQUVOLE9BQU9PLElBQUksSUFBSSxNQUFNLENBQUMsRUFBRVAsT0FBT1EsUUFBUSxDQUFDLGlCQUFpQixDQUFDO1lBRXhJLE1BQU1DLFNBQVMsSUFBSWYsZ0RBQVdBLENBQUNTLEtBQUs7Z0JBQ2hDTyxrQkFBa0JWLE9BQU9XLGlCQUFpQixJQUFJO2dCQUM5Q0MsMEJBQTBCWixPQUFPVyxpQkFBaUIsSUFBSTtZQUMxRDtZQUVBLE1BQU1GLE9BQU9WLE9BQU87WUFDcEIsTUFBTWMsS0FBS0osT0FBT0ksRUFBRSxDQUFDYixPQUFPUSxRQUFRO1lBRXBDLDhDQUE4QztZQUM5QyxNQUFNTSxVQUFVTCxPQUFPSSxFQUFFLENBQUM7WUFDMUIsTUFBTUUsYUFBYSxNQUFNRCxRQUFRRSxPQUFPLENBQUM7Z0JBQUVDLGNBQWM7WUFBRTtZQUUzRCxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDbEIsY0FBY1E7WUFDL0IsSUFBSSxDQUFDVyxTQUFTLENBQUNELEdBQUcsQ0FBQ2xCLGNBQWNZO1lBRWpDaEIsT0FBT3dCLElBQUksQ0FBQyxDQUFDLHNCQUFzQixFQUFFckIs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QU8yQixLQUFLLENBQUMsQ0FBQyxxQ0FBcUMsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENBQUMsRUFBRUQ7WUFDdEUsTUFBTSxJQUFJYSxNQUFNLENBQUMsNkJBQTZCLEVBQUViLE1BQU1DLE9BQU8sQ0FBQyxDQUFDO1FBQ25FO0lBQ0o7SUFFQTs7S0FFQyxHQUNELGVBQXVCMkcsSUFBZ0IsRUFBRXBELFNBQWlCLEVBQVU7UUFDaEUsTUFBTXFELFFBQVEsSUFBSWhFO1FBRWxCLEtBQUssTUFBTUMsT0FBTzhELEtBQU07WUFDcEIsTUFBTUUsUUFBUWhFLEdBQUcsQ0FBQ1UsVUFBVTtZQUM1QixJQUFJc0QsVUFBVSxRQUFRQSxVQUFVakQsV0FBVztZQUUzQyxNQUFNeEIsT0FBT2dCLE1BQU0wRCxPQUFPLENBQUNELFNBQVMsVUFBVSxPQUFPQTtZQUNyREQsTUFBTTFELEdBQUcsQ0FBQ2Q7UUFDZDtRQUVBLElBQUl3RSxNQUFNRyxJQUFJLEtBQUssR0FBRyxPQUFPO1FBQzdCLElBQUlILE1BQU1HLElBQUksS0FBSyxHQUFHLE9BQU8zRCxNQUFNQyxJQUFJLENBQUN1RCxNQUFNLENBQUMsRUFBRTtRQUNqRCxPQUFPO0lBQ1g7OzthQW5YUW5ILFVBQW9DLElBQUl1SDthQUN4Q3JILFlBQTZCLElBQUlxSDs7QUFtWDdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvYWRhcHRlcnMvbW9uZ29kYi9Nb25nb0RCQWRhcHRlci50cz9kMzZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vbmdvQ2xpZW50LCBEYiwgRG9jdW1lbnQgfSBmcm9tICdtb25nb2RiJztcbmltcG9ydCB7IEJhc2VEQkFkYXB0ZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuaW1wb3J0IHR5cGUge1xuICAgIENvbm5lY3Rpb25Db25maWcsXG4gICAgQ29ubmVjdGlvblJlc3VsdCxcbiAgICBUZXN0UmVzdWx0LFxuICAgIFF1ZXJ5UmVxdWVzdCxcbiAgICBRdWVyeVJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBDb2x1bW4sXG4gICAgSW5kZXgsXG5cbiAgICBEYXRhYmFzZUluZm8sXG4gICAgRXhwbGFpblJlc3VsdCxcbn0gZnJvbSAnQGJvc2RiL2NvcmUnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGJvc2RiL3V0aWxzJztcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignTW9uZ29EQkFkYXB0ZXInKTtcblxuLyoqXG4gKiBNb25nb0RCIERhdGFiYXNlIEFkYXB0ZXJcbiAqIEltcGxlbWVudHMgSURCQWRhcHRlciBmb3IgTW9uZ29EQiBkYXRhYmFzZXNcbiAqIFxuICogTm90ZTogTW9uZ29EQiBpcyBkb2N1bWVudC1vcmllbnRlZCAoTm9TUUwpLCBzbyBzb21lIFNRTCBjb25jZXB0cyBkb24ndCBhcHBseTpcbiAqIC0gU2NoZW1hcyAtPiBEYXRhYmFzZXNcbiAqIC0gVGFibGVzIC0+IENvbGxlY3Rpb25zXG4gKiAtIENvbHVtbnMgLT4gRG9jdW1lbnQgZmllbGRzIChkeW5hbWljKVxuICogLSBRdWVyeSAtPiBBZ2dyZWdhdGlvbiBwaXBlbGluZXMgb3IgZmluZCBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25nb0RCQWRhcHRlciBleHRlbmRzIEJhc2VEQkFkYXB0ZXIge1xuICAgIHByaXZhdGUgY2xpZW50czogTWFwPHN0cmluZywgTW9uZ29DbGllbnQ+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgZGF0YWJhc2VzOiBNYXA8c3RyaW5nLCBEYj4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdtb25nb2RiJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJ1aWxkIE1vbmdvREIgY29ubmVjdGlvbiBzdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IGBtb25nb2RiOi8vJHtjb25maWcudXNlcm5hbWV9OiR7Y29uZmlnLnBhc3N3b3JkfUAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0IHx8IDI3MDE3fS8ke2NvbmZpZy5kYXRhYmFzZX0/YXV0aFNvdXJjZT1hZG1pbmA7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBNb25nb0NsaWVudCh1cmksIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dE1TOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgMTAwMDAsXG4gICAgICAgICAgICAgICAgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgMTAwMDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKGNvbmZpZy5kYXRhYmFzZSk7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgY29ubmVjdGlvbiBieSBydW5uaW5nIGEgc2ltcGxlIGNvbW1hbmRcbiAgICAgICAgICAgIGNvbnN0IGFkbWluRGIgPSBjbGllbnQuZGIoJ2FkbWluJyk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgYWRtaW5EYi5jb21tYW5kKHsgc2VydmVyU3RhdHVzOiAxIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNsaWVudHMuc2V0KGNvbm5lY3Rpb25JZCwgY2xpZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2VzLnNldChjb25uZWN0aW9uSWQsIGRiKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYENvbm5lY3RlZCB0byBNb25nb0RCOiAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0fS8ke2NvbmZpZy5kYXRhYmFzZX1gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzZXJ2ZXJJbmZvLnZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE1vbmdvREIgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogJycsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhYmFzZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgRGlzY29ubmVjdGVkIGZyb20gTW9uZ29EQjogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IGBtb25nb2RiOi8vJHtjb25maWcudXNlcm5hbWV9OiR7Y29uZmlnLnBhc3N3b3JkfUAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0IHx8IDI3MDE3fS8ke2NvbmZpZy5kYXRhYmFzZX0/YXV0aFNvdXJjZT1hZG1pbmA7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBNb25nb0NsaWVudCh1cmksIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dE1TOiA1MDAwLFxuICAgICAgICAgICAgICAgIHNlcnZlclNlbGVjdGlvblRpbWVvdXRNUzogNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRiKCdhZG1pbicpLmNvbW1hbmQoeyBwaW5nOiAxIH0pO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsb3NlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTW9uZ29EQiBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE1vbmdvREIgdGVzdCBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRtaW5EYiA9IGNsaWVudC5kYignYWRtaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkbWluRGIuY29tbWFuZCh7IGxpc3REYXRhYmFzZXM6IDEgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYXM6IFNjaGVtYVtdID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRiSW5mbyBvZiByZXN1bHQuZGF0YWJhc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsnYWRtaW4nLCAnbG9jYWwnLCAnY29uZmlnJ10uaW5jbHVkZXMoZGJJbmZvLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHN5c3RlbSBkYXRhYmFzZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGVjdGlvbiBjb3VudCBmb3IgZWFjaCBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKGRiSW5mby5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9ucyA9IGF3YWl0IGRiLmxpc3RDb2xsZWN0aW9ucygpLnRvQXJyYXkoKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNvdW50OiBjb2xsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBsaXN0IE1vbmdvREIgZGF0YWJhc2VzOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBkYXRhYmFzZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxpc3RUYWJsZXMoY29ubmVjdGlvbklkOiBzdHJpbmcsIHNjaGVtYU5hbWU/OiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlW10+IHtcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmRhdGFiYXNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiIHx8ICFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYk5hbWUgPSBzY2hlbWFOYW1lIHx8IGRiLmRhdGFiYXNlTmFtZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGIgPSBjbGllbnQuZGIoZGJOYW1lKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbnMgPSBhd2FpdCB0YXJnZXREYi5saXN0Q29sbGVjdGlvbnMoKS50b0FycmF5KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhYmxlczogVGFibGVbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsIG9mIGNvbGxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50IGNvdW50XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRhcmdldERiLmNvbGxlY3Rpb24oY29sbC5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGF3YWl0IGNvbGxlY3Rpb24uZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgdGFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGRiTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY29sbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb2xsLnR5cGUgPT09ICd2aWV3JyA/ICd2aWV3JyA6ICd0YWJsZScsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBNb25nb0RCIGNvbGxlY3Rpb25zOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBjb2xsZWN0aW9uczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVzY3JpYmVUYWJsZShjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZTogc3RyaW5nLCB0YWJsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gY2xpZW50LmRiKHNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24odGFibGVOYW1lKTtcblxuICAgICAgICAgICAgLy8gU2FtcGxlIGRvY3VtZW50cyB0byBpbmZlciBzY2hlbWEgKE1vbmdvREIgaGFzIGR5bmFtaWMgc2NoZW1hKVxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRG9jcyA9IGF3YWl0IGNvbGxlY3Rpb24uZmluZCh7fSkubGltaXQoMTAwKS50b0FycmF5KCk7XG5cbiAgICAgICAgICAgIC8vIEluZmVyIGZpZWxkcyBmcm9tIHNhbXBsZSBkb2N1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBzYW1wbGVEb2NzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZG9jKS5mb3JFYWNoKGtleSA9PiBmaWVsZFNldC5hZGQoa2V5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gQXJyYXkuZnJvbShmaWVsZFNldCkubWFwKGZpZWxkTmFtZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5pbmZlck1vbmdvVHlwZShzYW1wbGVEb2NzLCBmaWVsZE5hbWUpLFxuICAgICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLCAvLyBNb25nb0RCIGZpZWxkcyBhcmUgYWx3YXlzIG9wdGlvbmFsIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IGZpZWxkTmFtZSA9PT0gJ19pZCcsXG4gICAgICAgICAgICAgICAgaXNGb3JlaWduS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gR2V0IGluZGV4ZXNcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZXMgPSBhd2FpdCB0aGlzLmdldEluZGV4ZXMoY29ubmVjdGlvbklkLCBzY2hlbWFOYW1lLCB0YWJsZU5hbWUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgY291bnRcbiAgICAgICAgICAgIGNvbnN0IHJvd0NvdW50ID0gYXdhaXQgY29sbGVjdGlvbi5lc3RpbWF0ZWREb2N1bWVudENvdW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlzOiBbJ19pZCddLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25LZXlzOiBbXSwgLy8gTW9uZ29EQiBkb2Vzbid0IGhhdmUgZW5mb3JjZWQgZm9yZWlnbiBrZXlzXG4gICAgICAgICAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgICAgICAgICByb3dDb3VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGRlc2NyaWJlIE1vbmdvREIgY29sbGVjdGlvbjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlc2NyaWJlIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEluZGV4ZXMoY29ubmVjdGlvbklkOiBzdHJpbmcsIHNjaGVtYU5hbWU6IHN0cmluZywgdGFibGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IGNsaWVudC5kYihzY2hlbWFOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBkYi5jb2xsZWN0aW9uKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluZm8gPSBhd2FpdCBjb2xsZWN0aW9uLmluZGV4ZXMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4SW5mby5tYXAoaWR4ID0+ICh7XG4gICAgICAgICAgICAgICAgbmFtZTogaWR4Lm5hbWUgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IE9iamVjdC5rZXlzKGlkeC5rZXkpLFxuICAgICAgICAgICAgICAgIHVuaXF1ZTogaWR4LnVuaXF1ZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiBpZHgubmFtZSA9PT0gJ19pZF8nLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdidHJlZScsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIGluZGV4ZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgaW5kZXhlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmRhdGFiYXNlcy5nZXQocmVxdWVzdC5jb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtyZXF1ZXN0LmNvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBNb25nb0RCIHF1ZXJ5IChKU09OIGZvcm1hdClcbiAgICAgICAgICAgIC8vIFN1cHBvcnRzOiB7IFwiZmluZFwiOiBcImNvbGxlY3Rpb25cIiwgXCJmaWx0ZXJcIjogey4uLn0sIFwibGltaXRcIjogMTAgfVxuICAgICAgICAgICAgLy8gT3IgYWdncmVnYXRpb246IHsgXCJhZ2dyZWdhdGVcIjogXCJjb2xsZWN0aW9uXCIsIFwicGlwZWxpbmVcIjogWy4uLl0gfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlPYmogPSBKU09OLnBhcnNlKHJlcXVlc3QucXVlcnkpO1xuXG4gICAgICAgICAgICBsZXQgcm93czogYW55W10gPSBbXTtcbiAgICAgICAgICAgIGxldCBmaWVsZHM6IGFueVtdID0gW107XG5cbiAgICAgICAgICAgIGlmIChxdWVyeU9iai5maW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gZGIuY29sbGVjdGlvbihxdWVyeU9iai5maW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBxdWVyeU9iai5maWx0ZXIgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogYW55ID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmouc29ydCkgb3B0aW9ucy5zb3J0ID0gcXVlcnlPYmouc29ydDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmoubGltaXQpIG9wdGlvbnMubGltaXQgPSBxdWVyeU9iai5saW1pdDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmouc2tpcCkgb3B0aW9ucy5za2lwID0gcXVlcnlPYmouc2tpcDtcblxuICAgICAgICAgICAgICAgIHJvd3MgPSBhd2FpdCBjb2xsZWN0aW9uLmZpbmQoZmlsdGVyLCBvcHRpb25zKS50b0FycmF5KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5T2JqLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEFnZ3JlZ2F0aW9uIHBpcGVsaW5lXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouYWdncmVnYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXBlbGluZSA9IHF1ZXJ5T2JqLnBpcGVsaW5lIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJvd3MgPSBhd2FpdCBjb2xsZWN0aW9uLmFnZ3JlZ2F0ZShwaXBlbGluZSkudG9BcnJheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcXVlcnkgZm9ybWF0LiBVc2Uge1wiZmluZFwiOiBcImNvbGxlY3Rpb25cIiwgXCJmaWx0ZXJcIjogey4uLn19IG9yIHtcImFnZ3JlZ2F0ZVwiOiBcImNvbGxlY3Rpb25cIiwgXCJwaXBlbGluZVwiOiBbLi4uXX0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5mZXIgZmllbGRzIGZyb20gcmVzdWx0c1xuICAgICAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgICAgICByb3dzLmZvckVhY2gocm93ID0+IE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChrZXkgPT4gZmllbGROYW1lcy5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgICAgIGZpZWxkcyA9IEFycmF5LmZyb20oZmllbGROYW1lcykubWFwKG5hbWUgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdtaXhlZCcsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzOiByb3dzLnNsaWNlKDAsIHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICAgICAgaGFzTW9yZTogcm93cy5sZW5ndGggPiAocmVxdWVzdC5tYXhSb3dzIHx8IDEwMDApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBNb25nb0RCIHF1ZXJ5IGV4ZWN1dGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXJ5IGV4ZWN1dGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGV4cGxhaW5RdWVyeShjb25uZWN0aW9uSWQ6IHN0cmluZywgcXVlcnk6IHN0cmluZyk6IFByb21pc2U8RXhwbGFpblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGF0YWJhc2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWRiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5T2JqID0gSlNPTi5wYXJzZShxdWVyeSk7XG5cbiAgICAgICAgICAgIGlmIChxdWVyeU9iai5maW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouZmluZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwbGFpblJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb24uZmluZChxdWVyeU9iai5maWx0ZXIgfHwge30pLmV4cGxhaW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwbGFuOiBleHBsYWluUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBwbGFuVGV4dDogSlNPTi5zdHJpbmdpZnkoZXhwbGFpblJlc3VsdCwgbnVsbCwgMiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnlPYmouYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24ocXVlcnlPYmouYWdncmVnYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBsYWluUmVzdWx0ID0gYXdhaXQgY29sbGVjdGlvbi5hZ2dyZWdhdGUocXVlcnlPYmoucGlwZWxpbmUgfHwgW10sIHsgZXhwbGFpbjogdHJ1ZSB9KS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhbjogZXhwbGFpblJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcGxhblRleHQ6IEpTT04uc3RyaW5naWZ5KGV4cGxhaW5SZXN1bHQsIG51bGwsIDIpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4cGxhaW4gdGhpcyBxdWVyeSB0eXBlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTW9uZ29EQiBFWFBMQUlOIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRVhQTEFJTiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkbWluRGIgPSBjbGllbnQuZGIoJ2FkbWluJyk7XG4gICAgICAgICAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCBhZG1pbkRiLmNvbW1hbmQoeyBidWlsZEluZm86IDEgfSk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRJbmZvLnZlcnNpb247XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdmVyc2lvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGF0YWJhc2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCB8fCAhZGIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRtaW5EYiA9IGNsaWVudC5kYignYWRtaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN0YXR1cyA9IGF3YWl0IGFkbWluRGIuY29tbWFuZCh7IHNlcnZlclN0YXR1czogMSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzZXJ2ZXJTdGF0dXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJWZXJzaW9uOiBzZXJ2ZXJTdGF0dXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICB1cHRpbWU6IHNlcnZlclN0YXR1cy51cHRpbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGFiYXNlOiBkYi5kYXRhYmFzZU5hbWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXI6IHNlcnZlclN0YXR1cy5jb25uZWN0aW9ucz8uY3VycmVudD8udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBNb25nb0RCIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mZXIgTW9uZ29EQiBmaWVsZCB0eXBlIGZyb20gc2FtcGxlIGRvY3VtZW50c1xuICAgICAqL1xuICAgIHByaXZhdGUgaW5mZXJNb25nb1R5cGUoZG9jczogRG9jdW1lbnRbXSwgZmllbGROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdhcnJheScgOiB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICB0eXBlcy5hZGQodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZXMuc2l6ZSA9PT0gMCkgcmV0dXJuICdudWxsJztcbiAgICAgICAgaWYgKHR5cGVzLnNpemUgPT09IDEpIHJldHVybiBBcnJheS5mcm9tKHR5cGVzKVswXTtcbiAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk1vbmdvQ2xpZW50IiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIk1vbmdvREJBZGFwdGVyIiwiY29ubmVjdCIsImNvbmZpZyIsImNvbm5lY3Rpb25JZCIsImdlbmVyYXRlQ29ubmVjdGlvbklkIiwidXJpIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImhvc3QiLCJwb3J0IiwiZGF0YWJhc2UiLCJjbGllbnQiLCJjb25uZWN0VGltZW91dE1TIiwiY29ubmVjdGlvblRpbWVvdXQiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJkYiIsImFkbWluRGIiLCJzZXJ2ZXJJbmZvIiwiY29tbWFuZCIsInNlcnZlclN0YXR1cyIsImNsaWVudHMiLCJzZXQiLCJkYXRhYmFzZXMiLCJpbmZvIiwic3VjY2VzcyIsInZlcnNpb24iLCJlcnJvciIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0IiwiZ2V0IiwiY2xvc2UiLCJkZWxldGUiLCJ0ZXN0Q29ubmVjdGlvbiIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJwaW5nIiwibGF0ZW5jeSIsImxpc3RTY2hlbWFzIiwiRXJyb3IiLCJyZXN1bHQiLCJsaXN0RGF0YWJhc2VzIiwic2NoZW1hcyIsImRiSW5mbyIsImluY2x1ZGVzIiwibmFtZSIsImNvbGxlY3Rpb25zIiwibGlzdENvbGxlY3Rpb25zIiwidG9BcnJheSIsInB1c2giLCJ0YWJsZUNvdW50IiwibGVuZ3RoIiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJkYk5hbWUiLCJkYXRhYmFzZU5hbWUiLCJ0YXJnZXREYiIsInRhYmxlcyIsImNvbGwiLCJjb2xsZWN0aW9uIiwiY291bnQiLCJlc3RpbWF0ZWREb2N1bWVudENvdW50Iiwic2NoZW1hIiwidHlwZSIsInJvd0NvdW50IiwiZGVzY3JpYmVUYWJsZSIsInRhYmxlTmFtZSIsInNhbXBsZURvY3MiLCJmaW5kIiwibGltaXQiLCJmaWVsZFNldCIsIlNldCIsImRvYyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiYWRkIiwiY29sdW1ucyIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImZpZWxkTmFtZSIsImRhdGFUeXBlIiwiaW5mZXJNb25nb1R5cGUiLCJudWxsYWJsZSIsImRlZmF1bHRWYWx1ZSIsInVuZGVmaW5lZCIsImlzUHJpbWFyeUtleSIsImlzRm9yZWlnbktleSIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwicHJpbWFyeUtleXMiLCJmb3JlaWduS2V5cyIsImluZGV4SW5mbyIsImlkeCIsInVuaXF1ZSIsInByaW1hcnkiLCJleGVjdXRlUXVlcnkiLCJyZXF1ZXN0IiwicXVlcnlPYmoiLCJKU09OIiwicGFyc2UiLCJxdWVyeSIsInJvd3MiLCJmaWVsZHMiLCJmaWx0ZXIiLCJvcHRpb25zIiwic29ydCIsInNraXAiLCJhZ2dyZWdhdGUiLCJwaXBlbGluZSIsImZpZWxkTmFtZXMiLCJyb3ciLCJleGVjdXRpb25UaW1lIiwic2xpY2UiLCJtYXhSb3dzIiwiaGFzTW9yZSIsImV4cGxhaW5RdWVyeSIsImV4cGxhaW5SZXN1bHQiLCJleHBsYWluIiwicGxhbiIsInBsYW5UZXh0Iiwic3RyaW5naWZ5IiwiZ2V0VmVyc2lvbiIsImJ1aWxkSW5mbyIsImdldERhdGFiYXNlSW5mbyIsInNlcnZlclZlcnNpb24iLCJ1cHRpbWUiLCJjdXJyZW50RGF0YWJhc2UiLCJjdXJyZW50VXNlciIsImNvbm5lY3Rpb25zIiwiY3VycmVudCIsInRvU3RyaW5nIiwiZG9jcyIsInR5cGVzIiwidmFsdWUiLCJpc0FycmF5Iiwic2l6ZSIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/mongodb/MongoDBAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts":
/*!*********************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MySQLAdapter: () => (/* binding */ MySQLAdapter)\n/* harmony export */ });\n/* harmony import */ var mysql2_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mysql2/promise */ \"mysql2/promise\");\n/* harmony import */ var mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mysql2_promise__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"MySQLAdapter\");\n/**\n * MySQL Database Adapter\n * Implements IDBAdapter for MySQL databases using mysql2\n */ class MySQLAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"mysql\");\n        try {\n            const pool = mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default().createPool({\n                host: config.host,\n                port: config.port || 3306,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : undefined,\n                connectionLimit: config.maxPoolSize || 10,\n                waitForConnections: true,\n                queueLimit: 0,\n                enableKeepAlive: true,\n                keepAliveInitialDelay: 0\n            });\n            // Test connection\n            const connection = await pool.getConnection();\n            const [versionRows] = await connection.query(\"SELECT VERSION() as version\");\n            const version = versionRows[0].version;\n            connection.release();\n            this.pools.set(connectionId, pool);\n            logger.info(`Connected to MySQL: ${config.host}:${config.port}/${config.database}`);\n            return {\n                connectionId,\n                success: true,\n                version\n            };\n        } catch (error) {\n            logger.error(`MySQL connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (pool) {\n            await pool.end();\n            this.pools.delete(connectionId);\n            logger.info(`Disconnected from MySQL: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const connection = await mysql2_promise__WEBPACK_IMPORTED_MODULE_0___default().createConnection({\n                host: config.host,\n                port: config.port || 3306,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : undefined\n            });\n            await connection.ping();\n            await connection.end();\n            return {\n                success: true,\n                message: \"MySQL connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`MySQL test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    SCHEMA_NAME as name,\n                    DEFAULT_CHARACTER_SET_NAME as charset\n                FROM information_schema.SCHEMATA\n                WHERE SCHEMA_NAME NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')\n                ORDER BY SCHEMA_NAME\n            `);\n            const schemas = [];\n            for (const row of rows){\n                // Get table count for schema\n                const [countRows] = await pool.query(`SELECT COUNT(*) as count FROM information_schema.TABLES WHERE TABLE_SCHEMA = ?`, [\n                    row.name\n                ]);\n                schemas.push({\n                    name: row.name,\n                    tableCount: countRows[0].count\n                });\n            }\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list MySQL schemas: ${error.message}`, error);\n            throw new Error(`Failed to list schemas: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        const schema = schemaName || \"public\";\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    TABLE_SCHEMA as schema_name,\n                    TABLE_NAME as name,\n                    TABLE_TYPE as table_type,\n                    TABLE_ROWS as row_count\n                FROM information_schema.TABLES\n                WHERE TABLE_SCHEMA = ?\n                ORDER BY TABLE_NAME\n            `, [\n                schema\n            ]);\n            return rows.map((row)=>({\n                    schema: row.schema_name,\n                    name: row.name,\n                    type: row.table_type === \"BASE TABLE\" ? \"table\" : \"view\",\n                    rowCount: row.row_count\n                }));\n        } catch (error) {\n            logger.error(`Failed to list MySQL tables: ${error.message}`, error);\n            throw new Error(`Failed to list tables: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Get columns\n            const [columnRows] = await pool.query(`\n                SELECT \n                    COLUMN_NAME as name,\n                    DATA_TYPE as data_type,\n                    IS_NULLABLE as is_nullable,\n                    COLUMN_DEFAULT as default_value,\n                    CHARACTER_MAXIMUM_LENGTH as max_length,\n                    NUMERIC_PRECISION as precision,\n                    NUMERIC_SCALE as scale,\n                    COLUMN_KEY as column_key\n                FROM information_schema.COLUMNS\n                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?\n                ORDER BY ORDINAL_POSITION\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const columns = columnRows.map((row)=>({\n                    name: row.name,\n                    dataType: row.data_type,\n                    maxLength: row.max_length,\n                    precision: row.precision,\n                    scale: row.scale,\n                    nullable: row.is_nullable === \"YES\",\n                    defaultValue: row.default_value,\n                    isPrimaryKey: row.column_key === \"PRI\",\n                    isForeignKey: row.column_key === \"MUL\"\n                }));\n            // Get primary keys\n            const primaryKeys = columns.filter((c)=>c.isPrimaryKey).map((c)=>c.name);\n            // Get foreign keys\n            const [fkRows] = await pool.query(`\n                SELECT \n                    CONSTRAINT_NAME as name,\n                    COLUMN_NAME as column_name,\n                    REFERENCED_TABLE_NAME as ref_table,\n                    REFERENCED_COLUMN_NAME as ref_column\n                FROM information_schema.KEY_COLUMN_USAGE\n                WHERE TABLE_SCHEMA = ? \n                    AND TABLE_NAME = ? \n                    AND REFERENCED_TABLE_NAME IS NOT NULL\n                ORDER BY CONSTRAINT_NAME, ORDINAL_POSITION\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const foreignKeysMap = new Map();\n            for (const row of fkRows){\n                if (!foreignKeysMap.has(row.name)) {\n                    foreignKeysMap.set(row.name, {\n                        name: row.name,\n                        columns: [\n                            row.column_name\n                        ],\n                        referencedTable: row.ref_table,\n                        referencedColumns: [\n                            row.ref_column\n                        ]\n                    });\n                } else {\n                    const fk = foreignKeysMap.get(row.name);\n                    fk.columns.push(row.column_name);\n                    fk.referencedColumns.push(row.ref_column);\n                }\n            }\n            // Get indexes\n            const indexes = await this.getIndexes(connectionId, schemaName, tableName);\n            // Get row count\n            const [countRows] = await pool.query(`SELECT TABLE_ROWS as row_count FROM information_schema.TABLES WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?`, [\n                schemaName,\n                tableName\n            ]);\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys,\n                foreignKeys: Array.from(foreignKeysMap.values()),\n                indexes,\n                rowCount: countRows[0]?.row_count\n            };\n        } catch (error) {\n            logger.error(`Failed to describe MySQL table: ${error.message}`, error);\n            throw new Error(`Failed to describe table: ${error.message}`);\n        }\n    }\n    async getIndexes(connectionId, schemaName, tableName) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`\n                SELECT \n                    INDEX_NAME as name,\n                    COLUMN_NAME as column_name,\n                    NOT NON_UNIQUE as is_unique,\n                    INDEX_TYPE as type\n                FROM information_schema.STATISTICS\n                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?\n                ORDER BY INDEX_NAME, SEQ_IN_INDEX\n            `, [\n                schemaName,\n                tableName\n            ]);\n            const indexMap = new Map();\n            for (const row of rows){\n                if (!indexMap.has(row.name)) {\n                    indexMap.set(row.name, {\n                        name: row.name,\n                        columns: [\n                            row.column_name\n                        ],\n                        unique: row.is_unique === 1,\n                        primary: row.name === \"PRIMARY\",\n                        type: row.type\n                    });\n                } else {\n                    indexMap.get(row.name).columns.push(row.column_name);\n                }\n            }\n            return Array.from(indexMap.values());\n        } catch (error) {\n            logger.error(`Failed to get MySQL indexes: ${error.message}`, error);\n            throw new Error(`Failed to get indexes: ${error.message}`);\n        }\n    }\n    async executeQuery(request) {\n        const pool = this.pools.get(request.connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            const [rows, fields] = await pool.query(request.query);\n            const queryFields = Array.isArray(fields) ? fields.map((field)=>({\n                    name: field.name,\n                    dataType: this.mapMySQLType(field.type)\n                })) : [];\n            const resultRows = Array.isArray(rows) ? rows : [];\n            const executionTime = Date.now() - startTime;\n            return {\n                rows: resultRows.slice(0, request.maxRows || 1000),\n                fields: queryFields,\n                rowCount: resultRows.length,\n                executionTime,\n                hasMore: resultRows.length > (request.maxRows || 1000)\n            };\n        } catch (error) {\n            logger.error(`MySQL query execution failed: ${error.message}`, error);\n            throw new Error(`Query execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(`EXPLAIN ${query}`);\n            return {\n                plan: rows,\n                planText: JSON.stringify(rows, null, 2)\n            };\n        } catch (error) {\n            logger.error(`MySQL EXPLAIN failed: ${error.message}`, error);\n            throw new Error(`EXPLAIN failed: ${error.message}`);\n        }\n    }\n    async getVersion(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [rows] = await pool.query(\"SELECT VERSION() as version\");\n            return rows[0].version;\n        } catch (error) {\n            logger.error(`Failed to get MySQL version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const pool = this.pools.get(connectionId);\n        if (!pool) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const [versionRows] = await pool.query(\"SELECT VERSION() as version\");\n            const [userRows] = await pool.query(\"SELECT USER() as user\");\n            const [dbRows] = await pool.query(\"SELECT DATABASE() as db\");\n            return {\n                version: versionRows[0].version,\n                serverVersion: versionRows[0].version,\n                currentUser: userRows[0].user,\n                currentDatabase: dbRows[0].db\n            };\n        } catch (error) {\n            logger.error(`Failed to get MySQL database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    mapMySQLType(type) {\n        // MySQL field type constants\n        const types = {\n            0: \"DECIMAL\",\n            1: \"TINY\",\n            2: \"SHORT\",\n            3: \"LONG\",\n            4: \"FLOAT\",\n            5: \"DOUBLE\",\n            6: \"NULL\",\n            7: \"TIMESTAMP\",\n            8: \"LONGLONG\",\n            9: \"INT24\",\n            10: \"DATE\",\n            11: \"TIME\",\n            12: \"DATETIME\",\n            13: \"YEAR\",\n            15: \"VARCHAR\",\n            16: \"BIT\",\n            245: \"JSON\",\n            246: \"NEWDECIMAL\",\n            247: \"ENUM\",\n            248: \"SET\",\n            249: \"TINY_BLOB\",\n            250: \"MEDIUM_BLOB\",\n            251: \"LONG_BLOB\",\n            252: \"BLOB\",\n            253: \"VAR_STRING\",\n            254: \"STRING\",\n            255: \"GEOMETRY\"\n        };\n        return types[type] || \"UNKNOWN\";\n    }\n    constructor(...args){\n        super(...args);\n        this.pools = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL215c3FsL015U1FMQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQztBQUN5QjtBQWdCdEI7QUFFdEMsTUFBTUcsU0FBUyxJQUFJRCxnREFBTUEsQ0FBQztBQUUxQjs7O0NBR0MsR0FDTSxNQUFNRSxxQkFBcUJILGlFQUFhQTtJQUczQyxNQUFNSSxRQUFRQyxNQUF3QixFQUE2QjtRQUMvRCxNQUFNQyxlQUFlLElBQUksQ0FBQ0Msb0JBQW9CLENBQUM7UUFFL0MsSUFBSTtZQUNBLE1BQU1DLE9BQU9ULGdFQUFnQixDQUFDO2dCQUMxQlcsTUFBTUwsT0FBT0ssSUFBSTtnQkFDakJDLE1BQU1OLE9BQU9NLElBQUksSUFBSTtnQkFDckJDLFVBQVVQLE9BQU9PLFFBQVE7Z0JBQ3pCQyxNQUFNUixPQUFPUyxRQUFRO2dCQUNyQkMsVUFBVVYsT0FBT1UsUUFBUTtnQkFDekJDLEtBQUtYLE9BQU9XLEdBQUcsR0FBRztvQkFBRUMsb0JBQW9CO2dCQUFNLElBQUlDO2dCQUNsREMsaUJBQWlCZCxPQUFPZSxXQUFXLElBQUk7Z0JBQ3ZDQyxvQkFBb0I7Z0JBQ3BCQyxZQUFZO2dCQUNaQyxpQkFBaUI7Z0JBQ2pCQyx1QkFBdUI7WUFDM0I7WUFFQSxrQkFBa0I7WUFDbEIsTUFBTUMsYUFBYSxNQUFNakIsS0FBS2tCLGFBQWE7WUFDM0MsTUFBTSxDQUFDQyxZQUFZLEdBQUcsTUFBTUYsV0FBV0csS0FBSyxDQUF3QjtZQUNwRSxNQUFNQyxVQUFVRixXQUFXLENBQUMsRUFBRSxDQUFDRSxPQUFPO1lBQ3RDSixXQUFXSyxPQUFPO1lBRWxCLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUMxQixjQUFjRTtZQUU3Qk4sT0FBTytCLElBQUksQ0FBQyxDQUFDLG9CQUFvQixFQUFFNUIsT0FBT0ssSUFBSSxDQUFDLENBQUMsRUFBRUwsT0FBT00sSUFBSSxDQUFDLENBQUMsRUFBRU4sT0FB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S29CLEtBQUssQ0FBd0I7WUFFekQsT0FBTztnQkFDSEMsU0FBU0YsV0FBVyxDQUFDLEVBQUUsQ0FBQ0UsT0FBTztnQkFDL0JvRyxlQUFldEcsV0FBVyxDQUFDLEVBQUUsQ0FBQ0UsT0FBTztnQkFDckNxRyxhQUFhSCxRQUFRLENBQUMsRUFBRSxDQUFDbEgsSUFBSTtnQkFDN0JzSCxpQkFBaUJILE1BQU0sQ0FBQyxFQUFFLENBQUNJLEVBQUU7WUFDakM7UUFDSixFQUFFLE9BQU9qRyxPQUFZO1lBQ2pCakMsT0FBT2lDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFQSxNQUFNQyxPQUFPLENBQUMsQ0FBQyxFQUFFRDtZQUNwRSxNQUFNLElBQUljLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRWQsTUFBTUMsT0FBTyxDQUFDLENBQUM7UUFDbkU7SUFDSjtJQUVRNkUsYUFBYWxELElBQVksRUFBVTtRQUN2Qyw2QkFBNkI7UUFDN0IsTUFBTXNFLFFBQW1DO1lBQ3JDLEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztRQUNUO1FBRUEsT0FBT0EsS0FBSyxDQUFDdEUsS0FBSyxJQUFJO0lBQzFCOzs7YUFwYVFoQyxRQUFpQyxJQUFJMEQ7O0FBcWFqRCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL215c3FsL015U1FMQWRhcHRlci50cz8zMTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBteXNxbCBmcm9tICdteXNxbDIvcHJvbWlzZSc7XG5pbXBvcnQgeyBCYXNlREJBZGFwdGVyIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgU2NoZW1hLFxuICAgIFRhYmxlLFxuICAgIFRhYmxlTWV0YWRhdGEsXG4gICAgQ29sdW1uLFxuICAgIEluZGV4LFxuICAgIEZvcmVpZ25LZXksXG4gICAgRGF0YWJhc2VJbmZvLFxuICAgIEV4cGxhaW5SZXN1bHQsXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0Bib3NkYi91dGlscyc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ015U1FMQWRhcHRlcicpO1xuXG4vKipcbiAqIE15U1FMIERhdGFiYXNlIEFkYXB0ZXJcbiAqIEltcGxlbWVudHMgSURCQWRhcHRlciBmb3IgTXlTUUwgZGF0YWJhc2VzIHVzaW5nIG15c3FsMlxuICovXG5leHBvcnQgY2xhc3MgTXlTUUxBZGFwdGVyIGV4dGVuZHMgQmFzZURCQWRhcHRlciB7XG4gICAgcHJpdmF0ZSBwb29sczogTWFwPHN0cmluZywgbXlzcWwuUG9vbD4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdteXNxbCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwb29sID0gbXlzcWwuY3JlYXRlUG9vbCh7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgMzMwNixcbiAgICAgICAgICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICAgICAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHNzbDogY29uZmlnLnNzbCA/IHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25MaW1pdDogY29uZmlnLm1heFBvb2xTaXplIHx8IDEwLFxuICAgICAgICAgICAgICAgIHdhaXRGb3JDb25uZWN0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUxpbWl0OiAwLFxuICAgICAgICAgICAgICAgIGVuYWJsZUtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVJbml0aWFsRGVsYXk6IDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVGVzdCBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgcG9vbC5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBbdmVyc2lvblJvd3NdID0gYXdhaXQgY29ubmVjdGlvbi5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KCdTRUxFQ1QgVkVSU0lPTigpIGFzIHZlcnNpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uUm93c1swXS52ZXJzaW9uO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5yZWxlYXNlKCk7XG5cbiAgICAgICAgICAgIHRoaXMucG9vbHMuc2V0KGNvbm5lY3Rpb25JZCwgcG9vbCk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBDb25uZWN0ZWQgdG8gTXlTUUw6ICR7Y29uZmlnLmhvc3R9OiR7Y29uZmlnLnBvcnR9LyR7Y29uZmlnLmRhdGFiYXNlfWApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE15U1FMIGNvbm5lY3Rpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6ICcnLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmIChwb29sKSB7XG4gICAgICAgICAgICBhd2FpdCBwb29sLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5wb29scy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBEaXNjb25uZWN0ZWQgZnJvbSBNeVNRTDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBteXNxbC5jcmVhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiBjb25maWcucG9ydCB8fCAzMzA2LFxuICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc3NsOiBjb25maWcuc3NsID8geyByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5waW5nKCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ015U1FMIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgdGVzdCBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KGBcbiAgICAgICAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICAgICAgICAgIFNDSEVNQV9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQ0hBUkFDVEVSX1NFVF9OQU1FIGFzIGNoYXJzZXRcbiAgICAgICAgICAgICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5TQ0hFTUFUQVxuICAgICAgICAgICAgICAgIFdIRVJFIFNDSEVNQV9OQU1FIE5PVCBJTiAoJ2luZm9ybWF0aW9uX3NjaGVtYScsICdwZXJmb3JtYW5jZV9zY2hlbWEnLCAnbXlzcWwnLCAnc3lzJylcbiAgICAgICAgICAgICAgICBPUkRFUiBCWSBTQ0hFTUFfTkFNRVxuICAgICAgICAgICAgYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYXM6IFNjaGVtYVtdID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRhYmxlIGNvdW50IGZvciBzY2hlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBbY291bnRSb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICAgICAgYFNFTEVDVCBDT1VOVCgqKSBhcyBjb3VudCBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5UQUJMRVMgV0hFUkUgVEFCTEVfU0NIRU1BID0gP2AsXG4gICAgICAgICAgICAgICAgICAgIFtyb3cubmFtZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ291bnQ6IGNvdW50Um93c1swXS5jb3VudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGxpc3QgTXlTUUwgc2NoZW1hczogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2NoZW1hczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZT86IHN0cmluZyk6IFByb21pc2U8VGFibGVbXT4ge1xuICAgICAgICBjb25zdCBwb29sID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hTmFtZSB8fCAncHVibGljJztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICBTRUxFQ1QgXG4gICAgICAgICAgICAgICAgICAgIFRBQkxFX1NDSEVNQSBhcyBzY2hlbWFfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgVEFCTEVfTkFNRSBhcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBUQUJMRV9UWVBFIGFzIHRhYmxlX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIFRBQkxFX1JPV1MgYXMgcm93X2NvdW50XG4gICAgICAgICAgICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVTXG4gICAgICAgICAgICAgICAgV0hFUkUgVEFCTEVfU0NIRU1BID0gP1xuICAgICAgICAgICAgICAgIE9SREVSIEJZIFRBQkxFX05BTUVcbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICAgICAgW3NjaGVtYV1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiByb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogcm93LnNjaGVtYV9uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHJvdy50YWJsZV90eXBlID09PSAnQkFTRSBUQUJMRScgPyAndGFibGUnIDogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByb3cucm93X2NvdW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBsaXN0IE15U1FMIHRhYmxlczogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgdGFibGVzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZXNjcmliZVRhYmxlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWFOYW1lOiBzdHJpbmcsIHRhYmxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGNvbHVtbnNcbiAgICAgICAgICAgIGNvbnN0IFtjb2x1bW5Sb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgICAgICAgICBDT0xVTU5fTkFNRSBhcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBEQVRBX1RZUEUgYXMgZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgICAgICBJU19OVUxMQUJMRSBhcyBpc19udWxsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgQ09MVU1OX0RFRkFVTFQgYXMgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIIGFzIG1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIE5VTUVSSUNfUFJFQ0lTSU9OIGFzIHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgTlVNRVJJQ19TQ0FMRSBhcyBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgQ09MVU1OX0tFWSBhcyBjb2x1bW5fa2V5XG4gICAgICAgICAgICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuQ09MVU1OU1xuICAgICAgICAgICAgICAgIFdIRVJFIFRBQkxFX1NDSEVNQSA9ID8gQU5EIFRBQkxFX05BTUUgPSA/XG4gICAgICAgICAgICAgICAgT1JERVIgQlkgT1JESU5BTF9QT1NJVElPTlxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgY29sdW1uczogQ29sdW1uW10gPSBjb2x1bW5Sb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiByb3cuZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aDogcm93Lm1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiByb3cucHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiByb3cuc2NhbGUsXG4gICAgICAgICAgICAgICAgbnVsbGFibGU6IHJvdy5pc19udWxsYWJsZSA9PT0gJ1lFUycsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiByb3cuZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHJvdy5jb2x1bW5fa2V5ID09PSAnUFJJJyxcbiAgICAgICAgICAgICAgICBpc0ZvcmVpZ25LZXk6IHJvdy5jb2x1bW5fa2V5ID09PSAnTVVMJyxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gR2V0IHByaW1hcnkga2V5c1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXMgPSBjb2x1bW5zLmZpbHRlcigoYykgPT4gYy5pc1ByaW1hcnlLZXkpLm1hcCgoYykgPT4gYy5uYW1lKTtcblxuICAgICAgICAgICAgLy8gR2V0IGZvcmVpZ24ga2V5c1xuICAgICAgICAgICAgY29uc3QgW2ZrUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIFNFTEVDVCBcbiAgICAgICAgICAgICAgICAgICAgQ09OU1RSQUlOVF9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIENPTFVNTl9OQU1FIGFzIGNvbHVtbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgYXMgcmVmX3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICBSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIGFzIHJlZl9jb2x1bW5cbiAgICAgICAgICAgICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5LRVlfQ09MVU1OX1VTQUdFXG4gICAgICAgICAgICAgICAgV0hFUkUgVEFCTEVfU0NIRU1BID0gPyBcbiAgICAgICAgICAgICAgICAgICAgQU5EIFRBQkxFX05BTUUgPSA/IFxuICAgICAgICAgICAgICAgICAgICBBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXG4gICAgICAgICAgICAgICAgT1JERVIgQlkgQ09OU1RSQUlOVF9OQU1FLCBPUkRJTkFMX1BPU0lUSU9OXG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgICAgIFtzY2hlbWFOYW1lLCB0YWJsZU5hbWVdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBmb3JlaWduS2V5c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBGb3JlaWduS2V5PigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgZmtSb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JlaWduS2V5c01hcC5oYXMocm93Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmVpZ25LZXlzTWFwLnNldChyb3cubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBbcm93LmNvbHVtbl9uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRUYWJsZTogcm93LnJlZl90YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRDb2x1bW5zOiBbcm93LnJlZl9jb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmayA9IGZvcmVpZ25LZXlzTWFwLmdldChyb3cubmFtZSkhO1xuICAgICAgICAgICAgICAgICAgICBmay5jb2x1bW5zLnB1c2gocm93LmNvbHVtbl9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZmsucmVmZXJlbmNlZENvbHVtbnMucHVzaChyb3cucmVmX2NvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgaW5kZXhlc1xuICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQsIHNjaGVtYU5hbWUsIHRhYmxlTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIEdldCByb3cgY291bnRcbiAgICAgICAgICAgIGNvbnN0IFtjb3VudFJvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KFxuICAgICAgICAgICAgICAgIGBTRUxFQ1QgVEFCTEVfUk9XUyBhcyByb3dfY291bnQgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuVEFCTEVTIFdIRVJFIFRBQkxFX1NDSEVNQSA9ID8gQU5EIFRBQkxFX05BTUUgPSA/YCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleXMsXG4gICAgICAgICAgICAgICAgZm9yZWlnbktleXM6IEFycmF5LmZyb20oZm9yZWlnbktleXNNYXAudmFsdWVzKCkpLFxuICAgICAgICAgICAgICAgIGluZGV4ZXMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IGNvdW50Um93c1swXT8ucm93X2NvdW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVzY3JpYmUgTXlTUUwgdGFibGU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSB0YWJsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZTogc3RyaW5nLCB0YWJsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8SW5kZXhbXT4ge1xuICAgICAgICBjb25zdCBwb29sID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyb3dzXSA9IGF3YWl0IHBvb2wucXVlcnk8bXlzcWwuUm93RGF0YVBhY2tldFtdPihcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgU0VMRUNUIFxuICAgICAgICAgICAgICAgICAgICBJTkRFWF9OQU1FIGFzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIENPTFVNTl9OQU1FIGFzIGNvbHVtbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBOT1QgTk9OX1VOSVFVRSBhcyBpc191bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgIElOREVYX1RZUEUgYXMgdHlwZVxuICAgICAgICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLlNUQVRJU1RJQ1NcbiAgICAgICAgICAgICAgICBXSEVSRSBUQUJMRV9TQ0hFTUEgPSA/IEFORCBUQUJMRV9OQU1FID0gP1xuICAgICAgICAgICAgICAgIE9SREVSIEJZIElOREVYX05BTUUsIFNFUV9JTl9JTkRFWFxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZSwgdGFibGVOYW1lXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBuZXcgTWFwPHN0cmluZywgSW5kZXg+KCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4TWFwLmhhcyhyb3cubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXAuc2V0KHJvdy5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtyb3cuY29sdW1uX25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiByb3cuaXNfdW5pcXVlID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTogcm93Lm5hbWUgPT09ICdQUklNQVJZJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJvdy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcC5nZXQocm93Lm5hbWUpIS5jb2x1bW5zLnB1c2gocm93LmNvbHVtbl9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGluZGV4TWFwLnZhbHVlcygpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIGluZGV4ZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgaW5kZXhlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KHJlcXVlc3QuY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtyZXF1ZXN0LmNvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbcm93cywgZmllbGRzXSA9IGF3YWl0IHBvb2wucXVlcnkocmVxdWVzdC5xdWVyeSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5RmllbGRzID0gQXJyYXkuaXNBcnJheShmaWVsZHMpXG4gICAgICAgICAgICAgICAgPyBmaWVsZHMubWFwKChmaWVsZDogYW55KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5tYXBNeVNRTFR5cGUoZmllbGQudHlwZSksXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgOiBbXTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Um93cyA9IEFycmF5LmlzQXJyYXkocm93cykgPyByb3dzIDogW107XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzOiByZXN1bHRSb3dzLnNsaWNlKDAsIHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHF1ZXJ5RmllbGRzLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByZXN1bHRSb3dzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIGhhc01vcmU6IHJlc3VsdFJvd3MubGVuZ3RoID4gKHJlcXVlc3QubWF4Um93cyB8fCAxMDAwKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgcXVlcnkgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVlcnkgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhwbGFpblF1ZXJ5KGNvbm5lY3Rpb25JZDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxFeHBsYWluUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jvd3NdID0gYXdhaXQgcG9vbC5xdWVyeShgRVhQTEFJTiAke3F1ZXJ5fWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbGFuOiByb3dzLFxuICAgICAgICAgICAgICAgIHBsYW5UZXh0OiBKU09OLnN0cmluZ2lmeShyb3dzLCBudWxsLCAyKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTXlTUUwgRVhQTEFJTiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVYUExBSU4gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRWZXJzaW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbcm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBWRVJTSU9OKCkgYXMgdmVyc2lvbicpO1xuICAgICAgICAgICAgcmV0dXJuIHJvd3NbMF0udmVyc2lvbjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdmVyc2lvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+IHtcbiAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbdmVyc2lvblJvd3NdID0gYXdhaXQgcG9vbC5xdWVyeTxteXNxbC5Sb3dEYXRhUGFja2V0W10+KCdTRUxFQ1QgVkVSU0lPTigpIGFzIHZlcnNpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IFt1c2VyUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBVU0VSKCkgYXMgdXNlcicpO1xuICAgICAgICAgICAgY29uc3QgW2RiUm93c10gPSBhd2FpdCBwb29sLnF1ZXJ5PG15c3FsLlJvd0RhdGFQYWNrZXRbXT4oJ1NFTEVDVCBEQVRBQkFTRSgpIGFzIGRiJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblJvd3NbMF0udmVyc2lvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJWZXJzaW9uOiB2ZXJzaW9uUm93c1swXS52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyOiB1c2VyUm93c1swXS51c2VyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhYmFzZTogZGJSb3dzWzBdLmRiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IE15U1FMIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXBNeVNRTFR5cGUodHlwZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgLy8gTXlTUUwgZmllbGQgdHlwZSBjb25zdGFudHNcbiAgICAgICAgY29uc3QgdHlwZXM6IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAwOiAnREVDSU1BTCcsXG4gICAgICAgICAgICAxOiAnVElOWScsXG4gICAgICAgICAgICAyOiAnU0hPUlQnLFxuICAgICAgICAgICAgMzogJ0xPTkcnLFxuICAgICAgICAgICAgNDogJ0ZMT0FUJyxcbiAgICAgICAgICAgIDU6ICdET1VCTEUnLFxuICAgICAgICAgICAgNjogJ05VTEwnLFxuICAgICAgICAgICAgNzogJ1RJTUVTVEFNUCcsXG4gICAgICAgICAgICA4OiAnTE9OR0xPTkcnLFxuICAgICAgICAgICAgOTogJ0lOVDI0JyxcbiAgICAgICAgICAgIDEwOiAnREFURScsXG4gICAgICAgICAgICAxMTogJ1RJTUUnLFxuICAgICAgICAgICAgMTI6ICdEQVRFVElNRScsXG4gICAgICAgICAgICAxMzogJ1lFQVInLFxuICAgICAgICAgICAgMTU6ICdWQVJDSEFSJyxcbiAgICAgICAgICAgIDE2OiAnQklUJyxcbiAgICAgICAgICAgIDI0NTogJ0pTT04nLFxuICAgICAgICAgICAgMjQ2OiAnTkVXREVDSU1BTCcsXG4gICAgICAgICAgICAyNDc6ICdFTlVNJyxcbiAgICAgICAgICAgIDI0ODogJ1NFVCcsXG4gICAgICAgICAgICAyNDk6ICdUSU5ZX0JMT0InLFxuICAgICAgICAgICAgMjUwOiAnTUVESVVNX0JMT0InLFxuICAgICAgICAgICAgMjUxOiAnTE9OR19CTE9CJyxcbiAgICAgICAgICAgIDI1MjogJ0JMT0InLFxuICAgICAgICAgICAgMjUzOiAnVkFSX1NUUklORycsXG4gICAgICAgICAgICAyNTQ6ICdTVFJJTkcnLFxuICAgICAgICAgICAgMjU1OiAnR0VPTUVUUlknLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0eXBlc1t0eXBlXSB8fCAnVU5LTk9XTic7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIm15c3FsIiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIk15U1FMQWRhcHRlciIsImNvbm5lY3QiLCJjb25maWciLCJjb25uZWN0aW9uSWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInBvb2wiLCJjcmVhdGVQb29sIiwiaG9zdCIsInBvcnQiLCJkYXRhYmFzZSIsInVzZXIiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic3NsIiwicmVqZWN0VW5hdXRob3JpemVkIiwidW5kZWZpbmVkIiwiY29ubmVjdGlvbkxpbWl0IiwibWF4UG9vbFNpemUiLCJ3YWl0Rm9yQ29ubmVjdGlvbnMiLCJxdWV1ZUxpbWl0IiwiZW5hYmxlS2VlcEFsaXZlIiwia2VlcEFsaXZlSW5pdGlhbERlbGF5IiwiY29ubmVjdGlvbiIsImdldENvbm5lY3Rpb24iLCJ2ZXJzaW9uUm93cyIsInF1ZXJ5IiwidmVyc2lvbiIsInJlbGVhc2UiLCJwb29scyIsInNldCIsImluZm8iLCJzdWNjZXNzIiwiZXJyb3IiLCJtZXNzYWdlIiwiZGlzY29ubmVjdCIsImdldCIsImVuZCIsImRlbGV0ZSIsInRlc3RDb25uZWN0aW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJwaW5nIiwibGF0ZW5jeSIsImxpc3RTY2hlbWFzIiwiRXJyb3IiLCJyb3dzIiwic2NoZW1hcyIsInJvdyIsImNvdW50Um93cyIsIm5hbWUiLCJwdXNoIiwidGFibGVDb3VudCIsImNvdW50IiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJzY2hlbWEiLCJtYXAiLCJzY2hlbWFfbmFtZSIsInR5cGUiLCJ0YWJsZV90eXBlIiwicm93Q291bnQiLCJyb3dfY291bnQiLCJkZXNjcmliZVRhYmxlIiwidGFibGVOYW1lIiwiY29sdW1uUm93cyIsImNvbHVtbnMiLCJkYXRhVHlwZSIsImRhdGFfdHlwZSIsIm1heExlbmd0aCIsIm1heF9sZW5ndGgiLCJwcmVjaXNpb24iLCJzY2FsZSIsIm51bGxhYmxlIiwiaXNfbnVsbGFibGUiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0X3ZhbHVlIiwiaXNQcmltYXJ5S2V5IiwiY29sdW1uX2tleSIsImlzRm9yZWlnbktleSIsInByaW1hcnlLZXlzIiwiZmlsdGVyIiwiYyIsImZrUm93cyIsImZvcmVpZ25LZXlzTWFwIiwiTWFwIiwiaGFzIiwiY29sdW1uX25hbWUiLCJyZWZlcmVuY2VkVGFibGUiLCJyZWZfdGFibGUiLCJyZWZlcmVuY2VkQ29sdW1ucyIsInJlZl9jb2x1bW4iLCJmayIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwiZm9yZWlnbktleXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJpbmRleE1hcCIsInVuaXF1ZSIsImlzX3VuaXF1ZSIsInByaW1hcnkiLCJleGVjdXRlUXVlcnkiLCJyZXF1ZXN0IiwiZmllbGRzIiwicXVlcnlGaWVsZHMiLCJpc0FycmF5IiwiZmllbGQiLCJtYXBNeVNRTFR5cGUiLCJyZXN1bHRSb3dzIiwiZXhlY3V0aW9uVGltZSIsInNsaWNlIiwibWF4Um93cyIsImxlbmd0aCIsImhhc01vcmUiLCJleHBsYWluUXVlcnkiLCJwbGFuIiwicGxhblRleHQiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0VmVyc2lvbiIsImdldERhdGFiYXNlSW5mbyIsInVzZXJSb3dzIiwiZGJSb3dzIiwic2VydmVyVmVyc2lvbiIsImN1cnJlbnRVc2VyIiwiY3VycmVudERhdGFiYXNlIiwiZGIiLCJ0eXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/mysql/MySQLAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts":
/*!*******************************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgreSQLAdapter: () => (/* binding */ PostgreSQLAdapter)\n/* harmony export */ });\n/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ \"pg\");\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/core */ \"(rsc)/../../packages/core/src/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([pg__WEBPACK_IMPORTED_MODULE_0__]);\npg__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n/**\n * PostgreSQL database adapter\n * Implements full PostgreSQL support with connection pooling and security\n */ class PostgreSQLAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = config.id || this.generateConnectionId(\"pg\");\n        try {\n            const poolConfig = {\n                host: config.host,\n                port: config.port,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : false,\n                max: config.maxPoolSize || 10,\n                idleTimeoutMillis: 30000,\n                connectionTimeoutMillis: config.connectionTimeout || 5000,\n                allowExitOnIdle: false\n            };\n            const pool = new pg__WEBPACK_IMPORTED_MODULE_0__.Pool(poolConfig);\n            // Test the connection\n            const client = await pool.connect();\n            try {\n                const result = await client.query(\"SELECT version() as version\");\n                const version = result.rows[0]?.version || \"Unknown\";\n                // Store pool info\n                this.pools.set(connectionId, {\n                    pool,\n                    config,\n                    createdAt: new Date(),\n                    lastUsed: new Date()\n                });\n                return {\n                    connectionId,\n                    success: true,\n                    version\n                };\n            } finally{\n                client.release();\n            }\n        } catch (error) {\n            throw new Error(`Failed to connect to PostgreSQL: ${error.message}`);\n        }\n    }\n    async disconnect(connectionId) {\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        await poolInfo.pool.end();\n        this.pools.delete(connectionId);\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const pool = new pg__WEBPACK_IMPORTED_MODULE_0__.Pool({\n                host: config.host,\n                port: config.port,\n                database: config.database,\n                user: config.username,\n                password: config.password,\n                ssl: config.ssl ? {\n                    rejectUnauthorized: false\n                } : false,\n                max: 1,\n                connectionTimeoutMillis: config.connectionTimeout || 5000\n            });\n            const client = await pool.connect();\n            await client.query(\"SELECT 1\");\n            client.release();\n            await pool.end();\n            const latency = Date.now() - startTime;\n            return {\n                success: true,\n                message: \"Connection successful\",\n                latency\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message,\n                latency: Date.now() - startTime\n            };\n        }\n    }\n    async executeQuery(request) {\n        const poolInfo = this.pools.get(request.connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${request.connectionId}`);\n        }\n        poolInfo.lastUsed = new Date();\n        const startTime = Date.now();\n        let client = null;\n        try {\n            client = await poolInfo.pool.connect();\n            // Set query timeout\n            const timeout = request.timeout || _bosdb_core__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_QUERY_TIMEOUT;\n            await client.query(`SET statement_timeout = ${timeout}`);\n            // Execute query\n            const result = await client.query(request.query);\n            const executionTime = Date.now() - startTime;\n            // Apply row limit (handle queries that don't return rows)\n            const maxRows = request.maxRows || _bosdb_core__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_MAX_ROWS;\n            const rows = result.rows ? result.rows.slice(0, maxRows) : [];\n            const hasMore = result.rows ? result.rows.length > maxRows : false;\n            // Map fields (handle queries that don't return fields)\n            const fields = result.fields ? result.fields.map((field)=>({\n                    name: field.name,\n                    dataType: this.mapDataType(field.dataTypeID),\n                    tableID: field.tableID,\n                    columnID: field.columnID\n                })) : [];\n            return {\n                rows,\n                fields,\n                rowCount: result.rowCount || 0,\n                executionTime,\n                hasMore\n            };\n        } catch (error) {\n            throw new Error(`Query execution failed: ${error.message}`);\n        } finally{\n            if (client) {\n                client.release();\n            }\n        }\n    }\n    async listSchemas(connectionId) {\n        const query = `\n      SELECT \n        schema_name as name,\n        schema_owner as owner,\n        (SELECT COUNT(*) FROM information_schema.tables \n         WHERE table_schema = s.schema_name) as table_count\n      FROM information_schema.schemata s\n      WHERE schema_name NOT IN ('pg_catalog', 'information_schema', 'pg_toast')\n      ORDER BY schema_name;\n    `;\n        const result = await this.executeQuery({\n            connectionId,\n            query,\n            maxRows: 1000\n        });\n        return result.rows.map((row)=>({\n                name: row.name,\n                owner: row.owner,\n                tableCount: parseInt(row.table_count) || 0\n            }));\n    }\n    async listTables(connectionId, schema = \"public\") {\n        const query = `\n      SELECT \n        table_schema as schema,\n        table_name as name,\n        table_type as type,\n        (SELECT reltuples::bigint \n         FROM pg_class \n         WHERE oid = (quote_ident(table_schema) || '.' || quote_ident(table_name))::regclass\n        ) as row_count,\n        pg_size_pretty(pg_total_relation_size(\n          (quote_ident(table_schema) || '.' || quote_ident(table_name))::regclass\n        )) as size\n      FROM information_schema.tables\n      WHERE table_schema = $1\n      ORDER BY table_name;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema\n            ]);\n            return result.rows.map((row)=>({\n                    schema: row.schema,\n                    name: row.name,\n                    type: row.type === \"BASE TABLE\" ? \"table\" : \"view\",\n                    rowCount: row.row_count,\n                    size: row.size\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async describeTable(connectionId, schema, table) {\n        const columns = await this.getColumns(connectionId, schema, table);\n        const indexes = await this.getIndexes(connectionId, schema, table);\n        const foreignKeys = await this.getForeignKeys(connectionId, schema, table);\n        // Get primary keys\n        const primaryKeys = columns.filter((col)=>col.isPrimaryKey).map((col)=>col.name);\n        return {\n            schema,\n            name: table,\n            columns,\n            primaryKeys,\n            foreignKeys,\n            indexes\n        };\n    }\n    async getIndexes(connectionId, schema, table) {\n        const query = `\n      SELECT\n        i.relname as name,\n        array_agg(a.attname ORDER BY a.attnum) as columns,\n        ix.indisunique as unique,\n        ix.indisprimary as primary,\n        am.amname as type\n      FROM pg_class t\n      JOIN pg_namespace n ON n.oid = t.relnamespace\n      JOIN pg_index ix ON t.oid = ix.indrelid\n      JOIN pg_class i ON i.oid = ix.indexrelid\n      JOIN pg_am am ON i.relam = am.oid\n      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\n      WHERE n.nspname = $1 AND t.relname = $2\n      GROUP BY i.relname, ix.indisunique, ix.indisprimary, am.amname\n      ORDER BY i.relname;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    columns: row.columns,\n                    unique: row.unique,\n                    primary: row.primary,\n                    type: row.type\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async explainQuery(connectionId, query) {\n        const explainQuery = `EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ${query}`;\n        const result = await this.executeQuery({\n            connectionId,\n            query: explainQuery,\n            maxRows: 1\n        });\n        const plan = result.rows[0]?.[\"QUERY PLAN\"];\n        return {\n            plan,\n            executionTime: plan?.[0]?.[\"Execution Time\"],\n            totalCost: plan?.[0]?.[\"Plan\"]?.[\"Total Cost\"],\n            planText: JSON.stringify(plan, null, 2)\n        };\n    }\n    async getVersion(connectionId) {\n        const result = await this.executeQuery({\n            connectionId,\n            query: \"SELECT version() as version\",\n            maxRows: 1\n        });\n        return result.rows[0]?.version || \"Unknown\";\n    }\n    async getDatabaseInfo(connectionId) {\n        const query = `\n      SELECT\n        version() as version,\n        current_database() as current_database,\n        current_user as current_user,\n        pg_encoding_to_char(encoding) as encoding\n      FROM pg_database\n      WHERE datname = current_database();\n    `;\n        const result = await this.executeQuery({\n            connectionId,\n            query,\n            maxRows: 1\n        });\n        const row = result.rows[0];\n        return {\n            version: row?.version || \"Unknown\",\n            currentDatabase: row?.current_database,\n            currentUser: row?.current_user,\n            encoding: row?.encoding\n        };\n    }\n    // Helper methods\n    async getColumns(connectionId, schema, table) {\n        const query = `\n      SELECT\n        c.column_name as name,\n        c.data_type as data_type,\n        c.character_maximum_length as max_length,\n        c.numeric_precision as precision,\n        c.numeric_scale as scale,\n        c.is_nullable = 'YES' as nullable,\n        c.column_default as default_value,\n        EXISTS(\n          SELECT 1 FROM information_schema.key_column_usage kcu\n          JOIN information_schema.table_constraints tc\n            ON kcu.constraint_name = tc.constraint_name\n          WHERE kcu.table_schema = c.table_schema\n            AND kcu.table_name = c.table_name\n            AND kcu.column_name = c.column_name\n            AND tc.constraint_type = 'PRIMARY KEY'\n        ) as is_primary_key,\n        EXISTS(\n          SELECT 1 FROM information_schema.key_column_usage kcu\n          JOIN information_schema.table_constraints tc\n            ON kcu.constraint_name = tc.constraint_name\n          WHERE kcu.table_schema = c.table_schema\n            AND kcu.table_name = c.table_name\n            AND kcu.column_name = c.column_name\n            AND tc.constraint_type = 'FOREIGN KEY'\n        ) as is_foreign_key,\n        pgd.description as comment\n      FROM information_schema.columns c\n      LEFT JOIN pg_catalog.pg_statio_all_tables st\n        ON c.table_schema = st.schemaname AND c.table_name = st.relname\n      LEFT JOIN pg_catalog.pg_description pgd\n        ON pgd.objoid = st.relid AND pgd.objsubid = c.ordinal_position\n      WHERE c.table_schema = $1 AND c.table_name = $2\n      ORDER BY c.ordinal_position;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    dataType: row.data_type,\n                    maxLength: row.max_length,\n                    precision: row.precision,\n                    scale: row.scale,\n                    nullable: row.nullable,\n                    defaultValue: row.default_value,\n                    isPrimaryKey: row.is_primary_key,\n                    isForeignKey: row.is_foreign_key,\n                    comment: row.comment\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    async getForeignKeys(connectionId, schema, table) {\n        const query = `\n      SELECT\n        tc.constraint_name as name,\n        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns,\n        ccu.table_name as referenced_table,\n        array_agg(ccu.column_name ORDER BY kcu.ordinal_position) as referenced_columns,\n        rc.update_rule as on_update,\n        rc.delete_rule as on_delete\n      FROM information_schema.table_constraints tc\n      JOIN information_schema.key_column_usage kcu\n        ON tc.constraint_name = kcu.constraint_name\n        AND tc.table_schema = kcu.table_schema\n      JOIN information_schema.constraint_column_usage ccu\n        ON ccu.constraint_name = tc.constraint_name\n        AND ccu.table_schema = tc.table_schema\n      JOIN information_schema.referential_constraints rc\n        ON tc.constraint_name = rc.constraint_name\n        AND tc.table_schema = rc.constraint_schema\n      WHERE tc.constraint_type = 'FOREIGN KEY'\n        AND tc.table_schema = $1\n        AND tc.table_name = $2\n      GROUP BY tc.constraint_name, ccu.table_name, rc.update_rule, rc.delete_rule;\n    `;\n        const poolInfo = this.pools.get(connectionId);\n        if (!poolInfo) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        const client = await poolInfo.pool.connect();\n        try {\n            const result = await client.query(query, [\n                schema,\n                table\n            ]);\n            return result.rows.map((row)=>({\n                    name: row.name,\n                    columns: row.columns,\n                    referencedTable: row.referenced_table,\n                    referencedColumns: row.referenced_columns,\n                    onUpdate: row.on_update,\n                    onDelete: row.on_delete\n                }));\n        } finally{\n            client.release();\n        }\n    }\n    mapDataType(oid) {\n        // PostgreSQL type OID mapping\n        const typeMap = {\n            16: \"boolean\",\n            17: \"bytea\",\n            20: \"bigint\",\n            21: \"smallint\",\n            23: \"integer\",\n            25: \"text\",\n            114: \"json\",\n            142: \"xml\",\n            700: \"real\",\n            701: \"double precision\",\n            1043: \"varchar\",\n            1082: \"date\",\n            1083: \"time\",\n            1114: \"timestamp\",\n            1184: \"timestamptz\",\n            1186: \"interval\",\n            1700: \"numeric\",\n            2950: \"uuid\",\n            3802: \"jsonb\"\n        };\n        return typeMap[oid] || \"unknown\";\n    }\n    constructor(...args){\n        super(...args);\n        this.pools = new Map();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL3Bvc3RncmVzcWwvUG9zdGdyZVNRTEFkYXB0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQW1CVTtBQUNVO0FBU3RFOzs7Q0FHQyxHQUNNLE1BQU1JLDBCQUEwQkgsaUVBQWFBO0lBR2hELE1BQU1JLFFBQVFDLE1BQXdCLEVBQTZCO1FBQy9ELE1BQU1DLGVBQWVELE9BQU9FLEVBQUUsSUFBSSxJQUFJLENBQUNDLG9CQUFvQixDQUFDO1FBRTVELElBQUk7WUFDQSxNQUFNQyxhQUF5QjtnQkFDM0JDLE1BQU1MLE9BQU9LLElBQUk7Z0JBQ2pCQyxNQUFNTixPQUFPTSxJQUFJO2dCQUNqQkMsVUFBVVAsT0FBT08sUUFBUTtnQkFDekJDLE1BQU1SLE9BQU9TLFFBQVE7Z0JBQ3JCQyxVQUFVVixPQUFPVSxRQUFRO2dCQUN6QkMsS0FBS1gsT0FBT1csR0FBRyxHQUFHO29CQUFFQyxvQkFBb0I7Z0JBQU0sSUFBSTtnQkFDbERDLEtBQUtiLE9BQU9jLFdBQVcsSUFBSTtnQkFDM0JDLG1CQUFtQjtnQkFDbkJDLHlCQUF5QmhCLE9BQU9pQixpQkFBaUIsSUFBSTtnQkFDckRDLGlCQUFpQjtZQUNyQjtZQUVBLE1BQU1DLE9BQU8sSUFBSXpCLG9DQUFJQSxDQUFDVTtZQUV0QixzQkFBc0I7WUFDdEIsTUFBTWdCLFNBQVMsTUFBTUQsS0FBS3BCLE9BQU87WUFDakMsSUFBSTtnQkFDQSxNQUFNc0IsU0FBUyxNQUFNRCxPQUFPRSxLQUFLLENBQUM7Z0JBQ2xDLE1BQU1DLFVBQVVGLE9BQU9HLElBQUksQ0FBQyxFQUFFLEVBQUVELFdBQVc7Z0JBRTNDLGtCQUFrQjtnQkFDbEIsSUFBSSxDQUFDRSxLQUFLLENBQUNDLEdBQUcsQ0FBQ3pCLGNBQWM7b0JBQ3pCa0I7b0JBQ0FuQjtvQkFDQTJCLFdBQVcsSUFBSUM7b0JBQ2ZDLFVBQVUsSUFBSUQ7Z0JBQ2xCO2dCQUVBLE9BQU87b0JBQ0gz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QUNKLFNBQVU7WUFDTm5HLE9BQU9XLE9BQU87UUFDbEI7SUFDSjtJQUVRMEIsWUFBWStELEdBQVcsRUFBVTtRQUNyQyw4QkFBOEI7UUFDOUIsTUFBTUMsVUFBa0M7WUFDcEMsSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtRQUNWO1FBRUEsT0FBT0EsT0FBTyxDQUFDRCxJQUFJLElBQUk7SUFDM0I7OzthQXhkUS9GLFFBQXlDLElBQUlpRzs7QUF5ZHpEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9kYi1hZGFwdGVycy9zcmMvYWRhcHRlcnMvcG9zdGdyZXNxbC9Qb3N0Z3JlU1FMQWRhcHRlci50cz80NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvb2wsIFBvb2xDbGllbnQsIFBvb2xDb25maWcgfSBmcm9tICdwZyc7XG5pbXBvcnQgdHlwZSB7XG4gICAgQ29ubmVjdGlvbkNvbmZpZyxcbiAgICBDb25uZWN0aW9uUmVzdWx0LFxuICAgIFRlc3RSZXN1bHQsXG4gICAgUXVlcnlSZXF1ZXN0LFxuICAgIFF1ZXJ5UmVzdWx0LFxuICAgIFF1ZXJ5RmllbGQsXG4gICAgRXhwbGFpblJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBDb2x1bW4sXG4gICAgSW5kZXgsXG4gICAgRm9yZWlnbktleSxcbiAgICBEYXRhYmFzZUluZm8sXG4gICAgQ29ubmVjdGlvbkVycm9yLFxuICAgIFF1ZXJ5RXhlY3V0aW9uRXJyb3IsXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcbmltcG9ydCB7IEJhc2VEQkFkYXB0ZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9USU1FT1VULCBERUZBVUxUX01BWF9ST1dTIH0gZnJvbSAnQGJvc2RiL2NvcmUnO1xuXG5pbnRlcmZhY2UgQ29ubmVjdGlvblBvb2xJbmZvIHtcbiAgICBwb29sOiBQb29sO1xuICAgIGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgbGFzdFVzZWQ6IERhdGU7XG59XG5cbi8qKlxuICogUG9zdGdyZVNRTCBkYXRhYmFzZSBhZGFwdGVyXG4gKiBJbXBsZW1lbnRzIGZ1bGwgUG9zdGdyZVNRTCBzdXBwb3J0IHdpdGggY29ubmVjdGlvbiBwb29saW5nIGFuZCBzZWN1cml0eVxuICovXG5leHBvcnQgY2xhc3MgUG9zdGdyZVNRTEFkYXB0ZXIgZXh0ZW5kcyBCYXNlREJBZGFwdGVyIHtcbiAgICBwcml2YXRlIHBvb2xzOiBNYXA8c3RyaW5nLCBDb25uZWN0aW9uUG9vbEluZm8+ID0gbmV3IE1hcCgpO1xuXG4gICAgYXN5bmMgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gY29uZmlnLmlkIHx8IHRoaXMuZ2VuZXJhdGVDb25uZWN0aW9uSWQoJ3BnJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2xDb25maWc6IFBvb2xDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICAgICAgICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBzc2w6IGNvbmZpZy5zc2wgPyB7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1heDogY29uZmlnLm1heFBvb2xTaXplIHx8IDEwLFxuICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiAzMDAwMCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dE1pbGxpczogY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0IHx8IDUwMDAsXG4gICAgICAgICAgICAgICAgYWxsb3dFeGl0T25JZGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBuZXcgUG9vbChwb29sQ29uZmlnKTtcblxuICAgICAgICAgICAgLy8gVGVzdCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcG9vbC5jb25uZWN0KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeSgnU0VMRUNUIHZlcnNpb24oKSBhcyB2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHJlc3VsdC5yb3dzWzBdPy52ZXJzaW9uIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHBvb2wgaW5mb1xuICAgICAgICAgICAgICAgIHRoaXMucG9vbHMuc2V0KGNvbm5lY3Rpb25JZCwge1xuICAgICAgICAgICAgICAgICAgICBwb29sLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVzZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCB0byBQb3N0Z3JlU1FMOiAke2Vycm9yLm1lc3NhZ2V9YCkgYXMgQ29ubmVjdGlvbkVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBwb29sSW5mbyA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgcG9vbEluZm8ucG9vbC5lbmQoKTtcbiAgICAgICAgdGhpcy5wb29scy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBQb29sKHtcbiAgICAgICAgICAgICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgICAgICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICAgICAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHNzbDogY29uZmlnLnNzbCA/IHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9IDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzOiBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5xdWVyeSgnU0VMRUNUIDEnKTtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKCk7XG4gICAgICAgICAgICBhd2FpdCBwb29sLmVuZCgpO1xuXG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3ksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgcG9vbEluZm8gPSB0aGlzLnBvb2xzLmdldChyZXF1ZXN0LmNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7cmVxdWVzdC5jb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb29sSW5mby5sYXN0VXNlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBjbGllbnQ6IFBvb2xDbGllbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xpZW50ID0gYXdhaXQgcG9vbEluZm8ucG9vbC5jb25uZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBxdWVyeSB0aW1lb3V0XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0IHx8IERFRkFVTFRfUVVFUllfVElNRU9VVDtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5xdWVyeShgU0VUIHN0YXRlbWVudF90aW1lb3V0ID0gJHt0aW1lb3V0fWApO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQucXVlcnkocmVxdWVzdC5xdWVyeSk7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgcm93IGxpbWl0IChoYW5kbGUgcXVlcmllcyB0aGF0IGRvbid0IHJldHVybiByb3dzKVxuICAgICAgICAgICAgY29uc3QgbWF4Um93cyA9IHJlcXVlc3QubWF4Um93cyB8fCBERUZBVUxUX01BWF9ST1dTO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IHJlc3VsdC5yb3dzID8gcmVzdWx0LnJvd3Muc2xpY2UoMCwgbWF4Um93cykgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXN1bHQucm93cyA/IHJlc3VsdC5yb3dzLmxlbmd0aCA+IG1heFJvd3MgOiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gTWFwIGZpZWxkcyAoaGFuZGxlIHF1ZXJpZXMgdGhhdCBkb24ndCByZXR1cm4gZmllbGRzKVxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBRdWVyeUZpZWxkW10gPSByZXN1bHQuZmllbGRzID8gcmVzdWx0LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRoaXMubWFwRGF0YVR5cGUoZmllbGQuZGF0YVR5cGVJRCksXG4gICAgICAgICAgICAgICAgdGFibGVJRDogZmllbGQudGFibGVJRCxcbiAgICAgICAgICAgICAgICBjb2x1bW5JRDogZmllbGQuY29sdW1uSUQsXG4gICAgICAgICAgICB9KSkgOiBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICByb3dDb3VudDogcmVzdWx0LnJvd0NvdW50IHx8IDAsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVGltZSxcbiAgICAgICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdWVyeSBleGVjdXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCkgYXMgUXVlcnlFeGVjdXRpb25FcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUIFxuICAgICAgICBzY2hlbWFfbmFtZSBhcyBuYW1lLFxuICAgICAgICBzY2hlbWFfb3duZXIgYXMgb3duZXIsXG4gICAgICAgIChTRUxFQ1QgQ09VTlQoKikgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFxuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gcy5zY2hlbWFfbmFtZSkgYXMgdGFibGVfY291bnRcbiAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhIHNcbiAgICAgIFdIRVJFIHNjaGVtYV9uYW1lIE5PVCBJTiAoJ3BnX2NhdGFsb2cnLCAnaW5mb3JtYXRpb25fc2NoZW1hJywgJ3BnX3RvYXN0JylcbiAgICAgIE9SREVSIEJZIHNjaGVtYV9uYW1lO1xuICAgIGA7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlUXVlcnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBtYXhSb3dzOiAxMDAwLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnJvd3MubWFwKChyb3cpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgIG93bmVyOiByb3cub3duZXIsXG4gICAgICAgICAgICB0YWJsZUNvdW50OiBwYXJzZUludChyb3cudGFibGVfY291bnQpIHx8IDAsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBsaXN0VGFibGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWE6IHN0cmluZyA9ICdwdWJsaWMnKTogUHJvbWlzZTxUYWJsZVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUIFxuICAgICAgICB0YWJsZV9zY2hlbWEgYXMgc2NoZW1hLFxuICAgICAgICB0YWJsZV9uYW1lIGFzIG5hbWUsXG4gICAgICAgIHRhYmxlX3R5cGUgYXMgdHlwZSxcbiAgICAgICAgKFNFTEVDVCByZWx0dXBsZXM6OmJpZ2ludCBcbiAgICAgICAgIEZST00gcGdfY2xhc3MgXG4gICAgICAgICBXSEVSRSBvaWQgPSAocXVvdGVfaWRlbnQodGFibGVfc2NoZW1hKSB8fCAnLicgfHwgcXVvdGVfaWRlbnQodGFibGVfbmFtZSkpOjpyZWdjbGFzc1xuICAgICAgICApIGFzIHJvd19jb3VudCxcbiAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfdG90YWxfcmVsYXRpb25fc2l6ZShcbiAgICAgICAgICAocXVvdGVfaWRlbnQodGFibGVfc2NoZW1hKSB8fCAnLicgfHwgcXVvdGVfaWRlbnQodGFibGVfbmFtZSkpOjpyZWdjbGFzc1xuICAgICAgICApKSBhcyBzaXplXG4gICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXNcbiAgICAgIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICQxXG4gICAgICBPUkRFUiBCWSB0YWJsZV9uYW1lO1xuICAgIGA7XG5cbiAgICAgICAgY29uc3QgcG9vbEluZm8gPSB0aGlzLnBvb2xzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIXBvb2xJbmZvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gbm90IGZvdW5kOiAke2Nvbm5lY3Rpb25JZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHBvb2xJbmZvLnBvb2wuY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHF1ZXJ5LCBbc2NoZW1hXSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucm93cy5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHJvdy5zY2hlbWEsXG4gICAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogcm93LnR5cGUgPT09ICdCQVNFIFRBQkxFJyA/ICd0YWJsZScgOiAndmlldycsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvdy5yb3dfY291bnQsXG4gICAgICAgICAgICAgICAgc2l6ZTogcm93LnNpemUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVzY3JpYmVUYWJsZShcbiAgICAgICAgY29ubmVjdGlvbklkOiBzdHJpbmcsXG4gICAgICAgIHNjaGVtYTogc3RyaW5nLFxuICAgICAgICB0YWJsZTogc3RyaW5nXG4gICAgKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBhd2FpdCB0aGlzLmdldENvbHVtbnMoY29ubmVjdGlvbklkLCBzY2hlbWEsIHRhYmxlKTtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQsIHNjaGVtYSwgdGFibGUpO1xuICAgICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleXMoY29ubmVjdGlvbklkLCBzY2hlbWEsIHRhYmxlKTtcblxuICAgICAgICAvLyBHZXQgcHJpbWFyeSBrZXlzXG4gICAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gY29sdW1ucy5maWx0ZXIoKGNvbCkgPT4gY29sLmlzUHJpbWFyeUtleSkubWFwKChjb2wpID0+IGNvbC5uYW1lKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgcHJpbWFyeUtleXMsXG4gICAgICAgICAgICBmb3JlaWduS2V5cyxcbiAgICAgICAgICAgIGluZGV4ZXMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICBTRUxFQ1RcbiAgICAgICAgaS5yZWxuYW1lIGFzIG5hbWUsXG4gICAgICAgIGFycmF5X2FnZyhhLmF0dG5hbWUgT1JERVIgQlkgYS5hdHRudW0pIGFzIGNvbHVtbnMsXG4gICAgICAgIGl4LmluZGlzdW5pcXVlIGFzIHVuaXF1ZSxcbiAgICAgICAgaXguaW5kaXNwcmltYXJ5IGFzIHByaW1hcnksXG4gICAgICAgIGFtLmFtbmFtZSBhcyB0eXBlXG4gICAgICBGUk9NIHBnX2NsYXNzIHRcbiAgICAgIEpPSU4gcGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSB0LnJlbG5hbWVzcGFjZVxuICAgICAgSk9JTiBwZ19pbmRleCBpeCBPTiB0Lm9pZCA9IGl4LmluZHJlbGlkXG4gICAgICBKT0lOIHBnX2NsYXNzIGkgT04gaS5vaWQgPSBpeC5pbmRleHJlbGlkXG4gICAgICBKT0lOIHBnX2FtIGFtIE9OIGkucmVsYW0gPSBhbS5vaWRcbiAgICAgIEpPSU4gcGdfYXR0cmlidXRlIGEgT04gYS5hdHRyZWxpZCA9IHQub2lkIEFORCBhLmF0dG51bSA9IEFOWShpeC5pbmRrZXkpXG4gICAgICBXSEVSRSBuLm5zcG5hbWUgPSAkMSBBTkQgdC5yZWxuYW1lID0gJDJcbiAgICAgIEdST1VQIEJZIGkucmVsbmFtZSwgaXguaW5kaXN1bmlxdWUsIGl4LmluZGlzcHJpbWFyeSwgYW0uYW1uYW1lXG4gICAgICBPUkRFUiBCWSBpLnJlbG5hbWU7XG4gICAgYDtcblxuICAgICAgICBjb25zdCBwb29sSW5mbyA9IHRoaXMucG9vbHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghcG9vbEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgZm91bmQ6ICR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcG9vbEluZm8ucG9vbC5jb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQucXVlcnkocXVlcnksIFtzY2hlbWEsIHRhYmxlXSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucm93cy5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiByb3cuY29sdW1ucyxcbiAgICAgICAgICAgICAgICB1bmlxdWU6IHJvdy51bmlxdWUsXG4gICAgICAgICAgICAgICAgcHJpbWFyeTogcm93LnByaW1hcnksXG4gICAgICAgICAgICAgICAgdHlwZTogcm93LnR5cGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZXhwbGFpblF1ZXJ5KGNvbm5lY3Rpb25JZDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxFeHBsYWluUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGV4cGxhaW5RdWVyeSA9IGBFWFBMQUlOIChBTkFMWVpFLCBCVUZGRVJTLCBGT1JNQVQgSlNPTikgJHtxdWVyeX1gO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVF1ZXJ5KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIHF1ZXJ5OiBleHBsYWluUXVlcnksXG4gICAgICAgICAgICBtYXhSb3dzOiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBwbGFuID0gcmVzdWx0LnJvd3NbMF0/LlsnUVVFUlkgUExBTiddO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbGFuLFxuICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogcGxhbj8uWzBdPy5bJ0V4ZWN1dGlvbiBUaW1lJ10sXG4gICAgICAgICAgICB0b3RhbENvc3Q6IHBsYW4/LlswXT8uWydQbGFuJ10/LlsnVG90YWwgQ29zdCddLFxuICAgICAgICAgICAgcGxhblRleHQ6IEpTT04uc3RyaW5naWZ5KHBsYW4sIG51bGwsIDIpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVRdWVyeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBxdWVyeTogJ1NFTEVDVCB2ZXJzaW9uKCkgYXMgdmVyc2lvbicsXG4gICAgICAgICAgICBtYXhSb3dzOiAxLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnJvd3NbMF0/LnZlcnNpb24gfHwgJ1Vua25vd24nO1xuICAgIH1cblxuICAgIGFzeW5jIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIHZlcnNpb24oKSBhcyB2ZXJzaW9uLFxuICAgICAgICBjdXJyZW50X2RhdGFiYXNlKCkgYXMgY3VycmVudF9kYXRhYmFzZSxcbiAgICAgICAgY3VycmVudF91c2VyIGFzIGN1cnJlbnRfdXNlcixcbiAgICAgICAgcGdfZW5jb2RpbmdfdG9fY2hhcihlbmNvZGluZykgYXMgZW5jb2RpbmdcbiAgICAgIEZST00gcGdfZGF0YWJhc2VcbiAgICAgIFdIRVJFIGRhdG5hbWUgPSBjdXJyZW50X2RhdGFiYXNlKCk7XG4gICAgYDtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVRdWVyeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1heFJvd3M6IDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IHJlc3VsdC5yb3dzWzBdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiByb3c/LnZlcnNpb24gfHwgJ1Vua25vd24nLFxuICAgICAgICAgICAgY3VycmVudERhdGFiYXNlOiByb3c/LmN1cnJlbnRfZGF0YWJhc2UsXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogcm93Py5jdXJyZW50X3VzZXIsXG4gICAgICAgICAgICBlbmNvZGluZzogcm93Py5lbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kc1xuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDb2x1bW5zKFxuICAgICAgICBjb25uZWN0aW9uSWQ6IHN0cmluZyxcbiAgICAgICAgc2NoZW1hOiBzdHJpbmcsXG4gICAgICAgIHRhYmxlOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPENvbHVtbltdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIGMuY29sdW1uX25hbWUgYXMgbmFtZSxcbiAgICAgICAgYy5kYXRhX3R5cGUgYXMgZGF0YV90eXBlLFxuICAgICAgICBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCBhcyBtYXhfbGVuZ3RoLFxuICAgICAgICBjLm51bWVyaWNfcHJlY2lzaW9uIGFzIHByZWNpc2lvbixcbiAgICAgICAgYy5udW1lcmljX3NjYWxlIGFzIHNjYWxlLFxuICAgICAgICBjLmlzX251bGxhYmxlID0gJ1lFUycgYXMgbnVsbGFibGUsXG4gICAgICAgIGMuY29sdW1uX2RlZmF1bHQgYXMgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgRVhJU1RTKFxuICAgICAgICAgIFNFTEVDVCAxIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmtleV9jb2x1bW5fdXNhZ2Uga2N1XG4gICAgICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVfY29uc3RyYWludHMgdGNcbiAgICAgICAgICAgIE9OIGtjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWVcbiAgICAgICAgICBXSEVSRSBrY3UudGFibGVfc2NoZW1hID0gYy50YWJsZV9zY2hlbWFcbiAgICAgICAgICAgIEFORCBrY3UudGFibGVfbmFtZSA9IGMudGFibGVfbmFtZVxuICAgICAgICAgICAgQU5EIGtjdS5jb2x1bW5fbmFtZSA9IGMuY29sdW1uX25hbWVcbiAgICAgICAgICAgIEFORCB0Yy5jb25zdHJhaW50X3R5cGUgPSAnUFJJTUFSWSBLRVknXG4gICAgICAgICkgYXMgaXNfcHJpbWFyeV9rZXksXG4gICAgICAgIEVYSVNUUyhcbiAgICAgICAgICBTRUxFQ1QgMSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5rZXlfY29sdW1uX3VzYWdlIGtjdVxuICAgICAgICAgIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlX2NvbnN0cmFpbnRzIHRjXG4gICAgICAgICAgICBPTiBrY3UuY29uc3RyYWludF9uYW1lID0gdGMuY29uc3RyYWludF9uYW1lXG4gICAgICAgICAgV0hFUkUga2N1LnRhYmxlX3NjaGVtYSA9IGMudGFibGVfc2NoZW1hXG4gICAgICAgICAgICBBTkQga2N1LnRhYmxlX25hbWUgPSBjLnRhYmxlX25hbWVcbiAgICAgICAgICAgIEFORCBrY3UuY29sdW1uX25hbWUgPSBjLmNvbHVtbl9uYW1lXG4gICAgICAgICAgICBBTkQgdGMuY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJ1xuICAgICAgICApIGFzIGlzX2ZvcmVpZ25fa2V5LFxuICAgICAgICBwZ2QuZGVzY3JpcHRpb24gYXMgY29tbWVudFxuICAgICAgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyBjXG4gICAgICBMRUZUIEpPSU4gcGdfY2F0YWxvZy5wZ19zdGF0aW9fYWxsX3RhYmxlcyBzdFxuICAgICAgICBPTiBjLnRhYmxlX3NjaGVtYSA9IHN0LnNjaGVtYW5hbWUgQU5EIGMudGFibGVfbmFtZSA9IHN0LnJlbG5hbWVcbiAgICAgIExFRlQgSk9JTiBwZ19jYXRhbG9nLnBnX2Rlc2NyaXB0aW9uIHBnZFxuICAgICAgICBPTiBwZ2Qub2Jqb2lkID0gc3QucmVsaWQgQU5EIHBnZC5vYmpzdWJpZCA9IGMub3JkaW5hbF9wb3NpdGlvblxuICAgICAgV0hFUkUgYy50YWJsZV9zY2hlbWEgPSAkMSBBTkQgYy50YWJsZV9uYW1lID0gJDJcbiAgICAgIE9SREVSIEJZIGMub3JkaW5hbF9wb3NpdGlvbjtcbiAgICBgO1xuXG4gICAgICAgIGNvbnN0IHBvb2xJbmZvID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sSW5mby5wb29sLmNvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeShxdWVyeSwgW3NjaGVtYSwgdGFibGVdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiByb3cuZGF0YV90eXBlLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aDogcm93Lm1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiByb3cucHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiByb3cuc2NhbGUsXG4gICAgICAgICAgICAgICAgbnVsbGFibGU6IHJvdy5udWxsYWJsZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHJvdy5kZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogcm93LmlzX3ByaW1hcnlfa2V5LFxuICAgICAgICAgICAgICAgIGlzRm9yZWlnbktleTogcm93LmlzX2ZvcmVpZ25fa2V5LFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHJvdy5jb21tZW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Rm9yZWlnbktleXMoXG4gICAgICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxuICAgICAgICBzY2hlbWE6IHN0cmluZyxcbiAgICAgICAgdGFibGU6IHN0cmluZ1xuICAgICk6IFByb21pc2U8Rm9yZWlnbktleVtdPiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgU0VMRUNUXG4gICAgICAgIHRjLmNvbnN0cmFpbnRfbmFtZSBhcyBuYW1lLFxuICAgICAgICBhcnJheV9hZ2coa2N1LmNvbHVtbl9uYW1lIE9SREVSIEJZIGtjdS5vcmRpbmFsX3Bvc2l0aW9uKSBhcyBjb2x1bW5zLFxuICAgICAgICBjY3UudGFibGVfbmFtZSBhcyByZWZlcmVuY2VkX3RhYmxlLFxuICAgICAgICBhcnJheV9hZ2coY2N1LmNvbHVtbl9uYW1lIE9SREVSIEJZIGtjdS5vcmRpbmFsX3Bvc2l0aW9uKSBhcyByZWZlcmVuY2VkX2NvbHVtbnMsXG4gICAgICAgIHJjLnVwZGF0ZV9ydWxlIGFzIG9uX3VwZGF0ZSxcbiAgICAgICAgcmMuZGVsZXRlX3J1bGUgYXMgb25fZGVsZXRlXG4gICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZV9jb25zdHJhaW50cyB0Y1xuICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEua2V5X2NvbHVtbl91c2FnZSBrY3VcbiAgICAgICAgT04gdGMuY29uc3RyYWludF9uYW1lID0ga2N1LmNvbnN0cmFpbnRfbmFtZVxuICAgICAgICBBTkQgdGMudGFibGVfc2NoZW1hID0ga2N1LnRhYmxlX3NjaGVtYVxuICAgICAgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuY29uc3RyYWludF9jb2x1bW5fdXNhZ2UgY2N1XG4gICAgICAgIE9OIGNjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWVcbiAgICAgICAgQU5EIGNjdS50YWJsZV9zY2hlbWEgPSB0Yy50YWJsZV9zY2hlbWFcbiAgICAgIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLnJlZmVyZW50aWFsX2NvbnN0cmFpbnRzIHJjXG4gICAgICAgIE9OIHRjLmNvbnN0cmFpbnRfbmFtZSA9IHJjLmNvbnN0cmFpbnRfbmFtZVxuICAgICAgICBBTkQgdGMudGFibGVfc2NoZW1hID0gcmMuY29uc3RyYWludF9zY2hlbWFcbiAgICAgIFdIRVJFIHRjLmNvbnN0cmFpbnRfdHlwZSA9ICdGT1JFSUdOIEtFWSdcbiAgICAgICAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICQxXG4gICAgICAgIEFORCB0Yy50YWJsZV9uYW1lID0gJDJcbiAgICAgIEdST1VQIEJZIHRjLmNvbnN0cmFpbnRfbmFtZSwgY2N1LnRhYmxlX25hbWUsIHJjLnVwZGF0ZV9ydWxlLCByYy5kZWxldGVfcnVsZTtcbiAgICBgO1xuXG4gICAgICAgIGNvbnN0IHBvb2xJbmZvID0gdGhpcy5wb29scy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFwb29sSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBwb29sSW5mby5wb29sLmNvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5xdWVyeShxdWVyeSwgW3NjaGVtYSwgdGFibGVdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yb3dzLm1hcCgocm93KSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJvdy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHJvdy5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRUYWJsZTogcm93LnJlZmVyZW5jZWRfdGFibGUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlZENvbHVtbnM6IHJvdy5yZWZlcmVuY2VkX2NvbHVtbnMsXG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IHJvdy5vbl91cGRhdGUsXG4gICAgICAgICAgICAgICAgb25EZWxldGU6IHJvdy5vbl9kZWxldGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXBEYXRhVHlwZShvaWQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIC8vIFBvc3RncmVTUUwgdHlwZSBPSUQgbWFwcGluZ1xuICAgICAgICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgMTY6ICdib29sZWFuJyxcbiAgICAgICAgICAgIDE3OiAnYnl0ZWEnLFxuICAgICAgICAgICAgMjA6ICdiaWdpbnQnLFxuICAgICAgICAgICAgMjE6ICdzbWFsbGludCcsXG4gICAgICAgICAgICAyMzogJ2ludGVnZXInLFxuICAgICAgICAgICAgMjU6ICd0ZXh0JyxcbiAgICAgICAgICAgIDExNDogJ2pzb24nLFxuICAgICAgICAgICAgMTQyOiAneG1sJyxcbiAgICAgICAgICAgIDcwMDogJ3JlYWwnLFxuICAgICAgICAgICAgNzAxOiAnZG91YmxlIHByZWNpc2lvbicsXG4gICAgICAgICAgICAxMDQzOiAndmFyY2hhcicsXG4gICAgICAgICAgICAxMDgyOiAnZGF0ZScsXG4gICAgICAgICAgICAxMDgzOiAndGltZScsXG4gICAgICAgICAgICAxMTE0OiAndGltZXN0YW1wJyxcbiAgICAgICAgICAgIDExODQ6ICd0aW1lc3RhbXB0eicsXG4gICAgICAgICAgICAxMTg2OiAnaW50ZXJ2YWwnLFxuICAgICAgICAgICAgMTcwMDogJ251bWVyaWMnLFxuICAgICAgICAgICAgMjk1MDogJ3V1aWQnLFxuICAgICAgICAgICAgMzgwMjogJ2pzb25iJyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHlwZU1hcFtvaWRdIHx8ICd1bmtub3duJztcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiUG9vbCIsIkJhc2VEQkFkYXB0ZXIiLCJERUZBVUxUX1FVRVJZX1RJTUVPVVQiLCJERUZBVUxUX01BWF9ST1dTIiwiUG9zdGdyZVNRTEFkYXB0ZXIiLCJjb25uZWN0IiwiY29uZmlnIiwiY29ubmVjdGlvbklkIiwiaWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInBvb2xDb25maWciLCJob3N0IiwicG9ydCIsImRhdGFiYXNlIiwidXNlciIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzc2wiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJtYXgiLCJtYXhQb29sU2l6ZSIsImlkbGVUaW1lb3V0TWlsbGlzIiwiY29ubmVjdGlvblRpbWVvdXRNaWxsaXMiLCJjb25uZWN0aW9uVGltZW91dCIsImFsbG93RXhpdE9uSWRsZSIsInBvb2wiLCJjbGllbnQiLCJyZXN1bHQiLCJxdWVyeSIsInZlcnNpb24iLCJyb3dzIiwicG9vbHMiLCJzZXQiLCJjcmVhdGVkQXQiLCJEYXRlIiwibGFzdFVzZWQiLCJzdWNjZXNzIiwicmVsZWFzZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZGlzY29ubmVjdCIsInBvb2xJbmZvIiwiZ2V0IiwiZW5kIiwiZGVsZXRlIiwidGVzdENvbm5lY3Rpb24iLCJzdGFydFRpbWUiLCJub3ciLCJsYXRlbmN5IiwiZXhlY3V0ZVF1ZXJ5IiwicmVxdWVzdCIsInRpbWVvdXQiLCJleGVjdXRpb25UaW1lIiwibWF4Um93cyIsInNsaWNlIiwiaGFzTW9yZSIsImxlbmd0aCIsImZpZWxkcyIsIm1hcCIsImZpZWxkIiwibmFtZSIsImRhdGFUeXBlIiwibWFwRGF0YVR5cGUiLCJkYXRhVHlwZUlEIiwidGFibGVJRCIsImNvbHVtbklEIiwicm93Q291bnQiLCJsaXN0U2NoZW1hcyIsInJvdyIsIm93bmVyIiwidGFibGVDb3VudCIsInBhcnNlSW50IiwidGFibGVfY291bnQiLCJsaXN0VGFibGVzIiwic2NoZW1hIiwidHlwZSIsInJvd19jb3VudCIsInNpemUiLCJkZXNjcmliZVRhYmxlIiwidGFibGUiLCJjb2x1bW5zIiwiZ2V0Q29sdW1ucyIsImluZGV4ZXMiLCJnZXRJbmRleGVzIiwiZm9yZWlnbktleXMiLCJnZXRGb3JlaWduS2V5cyIsInByaW1hcnlLZXlzIiwiZmlsdGVyIiwiY29sIiwiaXNQcmltYXJ5S2V5IiwidW5pcXVlIiwicHJpbWFyeSIsImV4cGxhaW5RdWVyeSIsInBsYW4iLCJ0b3RhbENvc3QiLCJwbGFuVGV4dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRWZXJzaW9uIiwiZ2V0RGF0YWJhc2VJbmZvIiwiY3VycmVudERhdGFiYXNlIiwiY3VycmVudF9kYXRhYmFzZSIsImN1cnJlbnRVc2VyIiwiY3VycmVudF91c2VyIiwiZW5jb2RpbmciLCJkYXRhX3R5cGUiLCJtYXhMZW5ndGgiLCJtYXhfbGVuZ3RoIiwicHJlY2lzaW9uIiwic2NhbGUiLCJudWxsYWJsZSIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRfdmFsdWUiLCJpc19wcmltYXJ5X2tleSIsImlzRm9yZWlnbktleSIsImlzX2ZvcmVpZ25fa2V5IiwiY29tbWVudCIsInJlZmVyZW5jZWRUYWJsZSIsInJlZmVyZW5jZWRfdGFibGUiLCJyZWZlcmVuY2VkQ29sdW1ucyIsInJlZmVyZW5jZWRfY29sdW1ucyIsIm9uVXBkYXRlIiwib25fdXBkYXRlIiwib25EZWxldGUiLCJvbl9kZWxldGUiLCJvaWQiLCJ0eXBlTWFwIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts":
/*!*********************************************************************!*\
  !*** ../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedisAdapter: () => (/* binding */ RedisAdapter)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"(rsc)/../../node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bosdb/utils */ \"(rsc)/../../packages/utils/src/index.ts\");\n\n\n\nconst logger = new _bosdb_utils__WEBPACK_IMPORTED_MODULE_2__.Logger(\"RedisAdapter\");\n/**\n * Redis Database Adapter\n * Redis is a key-value store, not a traditional SQL database\n * Query format: JSON with Redis commands\n * Example: {\"command\": \"GET\", \"args\": [\"key\"]}\n */ class RedisAdapter extends _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_1__.BaseDBAdapter {\n    async connect(config) {\n        const connectionId = this.generateConnectionId(\"redis\");\n        try {\n            const client = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n                host: config.host,\n                port: config.port || 6379,\n                password: config.password,\n                db: parseInt(config.database || \"0\"),\n                connectTimeout: config.connectionTimeout || 10000\n            });\n            // Test connection\n            await client.ping();\n            this.clients.set(connectionId, client);\n            logger.info(`Connected to Redis: ${config.host}:${config.port}`);\n            return {\n                connectionId,\n                success: true,\n                version: await client.info(\"server\").then((info)=>{\n                    const match = info.match(/redis_version:([^\\r\\n]+)/);\n                    return match ? match[1] : \"unknown\";\n                })\n            };\n        } catch (error) {\n            logger.error(`Redis connection failed: ${error.message}`, error);\n            return {\n                connectionId: \"\",\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async disconnect(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (client) {\n            await client.quit();\n            this.clients.delete(connectionId);\n            logger.info(`Disconnected from Redis: ${connectionId}`);\n        }\n    }\n    async testConnection(config) {\n        const startTime = Date.now();\n        try {\n            const client = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n                host: config.host,\n                port: config.port || 6379,\n                password: config.password,\n                db: parseInt(config.database || \"0\"),\n                connectTimeout: 5000\n            });\n            await client.ping();\n            await client.quit();\n            return {\n                success: true,\n                message: \"Redis connection successful\",\n                latency: Date.now() - startTime\n            };\n        } catch (error) {\n            logger.error(`Redis test connection failed: ${error.message}`, error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    async listSchemas(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Redis has databases 0-15 by default\n            const dbCount = 16;\n            const schemas = [];\n            for(let i = 0; i < dbCount; i++){\n                // Switch to database\n                await client.select(i);\n                const keyCount = await client.dbsize();\n                schemas.push({\n                    name: `db${i}`,\n                    tableCount: keyCount\n                });\n            }\n            // Return to original database\n            const originalDb = parseInt(client.options.db?.toString() || \"0\", 10) || 0;\n            await client.select(originalDb);\n            return schemas;\n        } catch (error) {\n            logger.error(`Failed to list Redis databases: ${error.message}`, error);\n            throw new Error(`Failed to list databases: ${error.message}`);\n        }\n    }\n    async listTables(connectionId, schemaName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            // Get all keys (limited to 1000 for performance)\n            const keys = await client.keys(\"*\");\n            const limitedKeys = keys.slice(0, 1000);\n            const tables = await Promise.all(limitedKeys.map(async (key)=>{\n                const type = await client.type(key);\n                return {\n                    schema: schemaName || \"db0\",\n                    name: key,\n                    type: type,\n                    rowCount: type === \"list\" ? await client.llen(key) : type === \"set\" ? await client.scard(key) : type === \"zset\" ? await client.zcard(key) : type === \"hash\" ? await client.hlen(key) : 1\n                };\n            }));\n            return tables;\n        } catch (error) {\n            logger.error(`Failed to list Redis keys: ${error.message}`, error);\n            throw new Error(`Failed to list keys: ${error.message}`);\n        }\n    }\n    async describeTable(connectionId, schemaName, tableName) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const type = await client.type(tableName);\n            const ttl = await client.ttl(tableName);\n            const columns = [\n                {\n                    name: \"key\",\n                    dataType: \"string\",\n                    nullable: false,\n                    isPrimaryKey: true,\n                    isForeignKey: false\n                },\n                {\n                    name: \"type\",\n                    dataType: type,\n                    nullable: false,\n                    isPrimaryKey: false,\n                    isForeignKey: false\n                },\n                {\n                    name: \"ttl\",\n                    dataType: \"integer\",\n                    nullable: true,\n                    defaultValue: ttl.toString(),\n                    isPrimaryKey: false,\n                    isForeignKey: false\n                }\n            ];\n            return {\n                schema: schemaName,\n                name: tableName,\n                columns,\n                primaryKeys: [\n                    \"key\"\n                ],\n                foreignKeys: [],\n                indexes: [],\n                rowCount: 1\n            };\n        } catch (error) {\n            logger.error(`Failed to describe Redis key: ${error.message}`, error);\n            throw new Error(`Failed to describe key: ${error.message}`);\n        }\n    }\n    async getIndexes(_connectionId, _schemaName, _tableName) {\n        // Redis doesn't have traditional indexes\n        return [];\n    }\n    async executeQuery(request) {\n        const client = this.clients.get(request.connectionId);\n        if (!client) {\n            throw new Error(`Connection ${request.connectionId} not found`);\n        }\n        const startTime = Date.now();\n        try {\n            // Parse Redis command (JSON format)\n            // Example: {\"command\": \"GET\", \"args\": [\"mykey\"]}\n            // Or: {\"command\": \"KEYS\", \"args\": [\"*\"]}\n            const queryObj = JSON.parse(request.query);\n            if (!queryObj.command) {\n                throw new Error('Query must have \"command\" field. Example: {\"command\": \"GET\", \"args\": [\"mykey\"]}');\n            }\n            const command = queryObj.command.toUpperCase();\n            const args = queryObj.args || [];\n            // Execute Redis command\n            const result = await client[command.toLowerCase()](...args);\n            // Format result for display\n            let rows = [];\n            let fields = [];\n            if (Array.isArray(result)) {\n                rows = result.map((value, index)=>({\n                        index,\n                        value\n                    }));\n                fields = [\n                    {\n                        name: \"index\"\n                    },\n                    {\n                        name: \"value\"\n                    }\n                ];\n            } else if (typeof result === \"object\" && result !== null) {\n                rows = [\n                    result\n                ];\n                fields = Object.keys(result).map((key)=>({\n                        name: key\n                    }));\n            } else {\n                rows = [\n                    {\n                        result\n                    }\n                ];\n                fields = [\n                    {\n                        name: \"result\"\n                    }\n                ];\n            }\n            const executionTime = Date.now() - startTime;\n            return {\n                rows,\n                fields,\n                rowCount: rows.length,\n                executionTime,\n                hasMore: false\n            };\n        } catch (error) {\n            logger.error(`Redis command execution failed: ${error.message}`, error);\n            throw new Error(`Command execution failed: ${error.message}`);\n        }\n    }\n    async explainQuery(_connectionId, _query) {\n        // Redis doesn't have EXPLAIN functionality\n        return {\n            plan: {\n                message: \"Redis does not support query plans\"\n            },\n            planText: \"Redis is a key-value store and does not have SQL-style query plans.\"\n        };\n    }\n    async getVersion(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const info = await client.info(\"server\");\n            const match = info.match(/redis_version:([^\\r\\n]+)/);\n            return match ? match[1] : \"unknown\";\n        } catch (error) {\n            logger.error(`Failed to get Redis version: ${error.message}`, error);\n            throw new Error(`Failed to get version: ${error.message}`);\n        }\n    }\n    async getDatabaseInfo(connectionId) {\n        const client = this.clients.get(connectionId);\n        if (!client) {\n            throw new Error(`Connection ${connectionId} not found`);\n        }\n        try {\n            const info = await client.info();\n            const serverInfo = await client.info(\"server\");\n            const versionMatch = serverInfo.match(/redis_version:([^\\r\\n]+)/);\n            const uptimeMatch = info.match(/uptime_in_seconds:(\\d+)/);\n            return {\n                version: versionMatch ? versionMatch[1] : \"unknown\",\n                serverVersion: versionMatch ? versionMatch[1] : \"unknown\",\n                uptime: uptimeMatch ? parseInt(uptimeMatch[1]) : 0,\n                currentDatabase: `db${client.options.db || 0}`\n            };\n        } catch (error) {\n            logger.error(`Failed to get Redis database info: ${error.message}`, error);\n            throw new Error(`Failed to get database info: ${error.message}`);\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.clients = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2FkYXB0ZXJzL3JlZGlzL1JlZGlzQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QjtBQUNnQztBQWV0QjtBQUV0QyxNQUFNRyxTQUFTLElBQUlELGdEQUFNQSxDQUFDO0FBRTFCOzs7OztDQUtDLEdBQ00sTUFBTUUscUJBQXFCSCxpRUFBYUE7SUFHM0MsTUFBTUksUUFBUUMsTUFBd0IsRUFBNkI7UUFDL0QsTUFBTUMsZUFBZSxJQUFJLENBQUNDLG9CQUFvQixDQUFDO1FBRS9DLElBQUk7WUFDQSxNQUFNQyxTQUFTLElBQUlULGdEQUFLQSxDQUFDO2dCQUNyQlUsTUFBTUosT0FBT0ksSUFBSTtnQkFDakJDLE1BQU1MLE9BQU9LLElBQUksSUFBSTtnQkFDckJDLFVBQVVOLE9BQU9NLFFBQVE7Z0JBQ3pCQyxJQUFJQyxTQUFTUixPQUFPUyxRQUFRLElBQUk7Z0JBQ2hDQyxnQkFBZ0JWLE9BQU9XLGlCQUFpQixJQUFJO1lBQ2hEO1lBRUEsa0JBQWtCO1lBQ2xCLE1BQU1SLE9BQU9TLElBQUk7WUFFakIsSUFBSSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ2IsY0FBY0U7WUFFL0JOLE9BQU9rQixJQUFJLENBQUMsQ0FBQyxvQkFBb0IsRUFBRWYsT0FBT0ksSUFBSSxDQUFDLENBQUMsRUFBRUosT0FBT0ssSUFBSSxDQUFDLENBQUM7WUFFL0QsT0FBTztnQkFDSEo7Z0JBQ0FlLFNBQVM7Z0JBQ1RDLFNBQVMsTUFBTWQsT0FBT1ksSUFBSSxDQUFDLFVBQVVHLElBQUksQ0FBQ0gsQ0FBQUE7b0JBQ3RDLE1BQU1JLFFBQVFKLEtBQUtJLEtBQUssQ0FBQztvQkFDekIsT0FBT0EsUUFBUUEsS0FBSyxDQUFDLEVBQUUsR0FBRztnQkFDOUI7WUFDSjtRQUNKLEVBQUUsT0FBT0MsT0FBWTtZQUNqQnZCLE9BQU91QixLQUFLLENBQUMsQ0FBQyx5QkFBeUIsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENB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QyxNQUFNMkYsZUFBZUQsV0FBV3RGLEtBQUssQ0FBQztZQUN0QyxNQUFNd0YsY0FBYzVGLEtBQUtJLEtBQUssQ0FBQztZQUUvQixPQUFPO2dCQUNIRixTQUFTeUYsZUFBZUEsWUFBWSxDQUFDLEVBQUUsR0FBRztnQkFDMUNFLGVBQWVGLGVBQWVBLFlBQVksQ0FBQyxFQUFFLEdBQUc7Z0JBQ2hERyxRQUFRRixjQUFjbkcsU0FBU21HLFdBQVcsQ0FBQyxFQUFFLElBQUk7Z0JBQ2pERyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUzRyxPQUFPd0MsT0FBTyxDQUFDcEMsRUFBRSxJQUFJLEVBQUUsQ0FBQztZQUNsRDtRQUNKLEVBQUUsT0FBT2EsT0FBWTtZQUNqQnZCLE9BQU91QixLQUFLLENBQUMsQ0FBQyxtQ0FBbUMsRUFBRUEsTUFBTUMsT0FBTyxDQUFDLENBQUMsRUFBRUQ7WUFDcEUsTUFBTSxJQUFJWSxNQUFNLENBQUMsNkJBQTZCLEVBQUVaLE1BQU1DLE9BQU8sQ0FBQyxDQUFDO1FBQ25FO0lBQ0o7OzthQXpTUVIsVUFBOEIsSUFBSWtHOztBQTBTOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3BhY2thZ2VzL2RiLWFkYXB0ZXJzL3NyYy9hZGFwdGVycy9yZWRpcy9SZWRpc0FkYXB0ZXIudHM/M2U5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XG5pbXBvcnQgeyBCYXNlREJBZGFwdGVyIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JREJBZGFwdGVyJztcbmltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgU2NoZW1hLFxuICAgIFRhYmxlLFxuICAgIFRhYmxlTWV0YWRhdGEsXG4gICAgQ29sdW1uLFxuICAgIEluZGV4LFxuICAgIERhdGFiYXNlSW5mbyxcbiAgICBFeHBsYWluUmVzdWx0LFxufSBmcm9tICdAYm9zZGIvY29yZSc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAYm9zZGIvdXRpbHMnO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdSZWRpc0FkYXB0ZXInKTtcblxuLyoqXG4gKiBSZWRpcyBEYXRhYmFzZSBBZGFwdGVyXG4gKiBSZWRpcyBpcyBhIGtleS12YWx1ZSBzdG9yZSwgbm90IGEgdHJhZGl0aW9uYWwgU1FMIGRhdGFiYXNlXG4gKiBRdWVyeSBmb3JtYXQ6IEpTT04gd2l0aCBSZWRpcyBjb21tYW5kc1xuICogRXhhbXBsZToge1wiY29tbWFuZFwiOiBcIkdFVFwiLCBcImFyZ3NcIjogW1wia2V5XCJdfVxuICovXG5leHBvcnQgY2xhc3MgUmVkaXNBZGFwdGVyIGV4dGVuZHMgQmFzZURCQWRhcHRlciB7XG4gICAgcHJpdmF0ZSBjbGllbnRzOiBNYXA8c3RyaW5nLCBSZWRpcz4gPSBuZXcgTWFwKCk7XG5cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8Q29ubmVjdGlvblJlc3VsdD4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmdlbmVyYXRlQ29ubmVjdGlvbklkKCdyZWRpcycpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgUmVkaXMoe1xuICAgICAgICAgICAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0IHx8IDYzNzksXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBkYjogcGFyc2VJbnQoY29uZmlnLmRhdGFiYXNlIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgY29ubmVjdFRpbWVvdXQ6IGNvbmZpZy5jb25uZWN0aW9uVGltZW91dCB8fCAxMDAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUZXN0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5waW5nKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xpZW50cy5zZXQoY29ubmVjdGlvbklkLCBjbGllbnQpO1xuXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgQ29ubmVjdGVkIHRvIFJlZGlzOiAke2NvbmZpZy5ob3N0fToke2NvbmZpZy5wb3J0fWApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGF3YWl0IGNsaWVudC5pbmZvKCdzZXJ2ZXInKS50aGVuKGluZm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGluZm8ubWF0Y2goL3JlZGlzX3ZlcnNpb246KFteXFxyXFxuXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJ3Vua25vd24nO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWRpcyBjb25uZWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiAnJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnF1aXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBEaXNjb25uZWN0ZWQgZnJvbSBSZWRpczogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRpcyh7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgNjM3OSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIGRiOiBwYXJzZUludChjb25maWcuZGF0YWJhc2UgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucGluZygpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnF1aXQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWRpcyBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlZGlzIHRlc3QgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxpc3RTY2hlbWFzKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxTY2hlbWFbXT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlZGlzIGhhcyBkYXRhYmFzZXMgMC0xNSBieSBkZWZhdWx0XG4gICAgICAgICAgICBjb25zdCBkYkNvdW50ID0gMTY7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFzOiBTY2hlbWFbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRiQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB0byBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5zZWxlY3QoaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5Q291bnQgPSBhd2FpdCBjbGllbnQuZGJzaXplKCk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgZGIke2l9YCxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDb3VudDoga2V5Q291bnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0byBvcmlnaW5hbCBkYXRhYmFzZVxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEYiA9IHBhcnNlSW50KGNsaWVudC5vcHRpb25zLmRiPy50b1N0cmluZygpIHx8ICcwJywgMTApIHx8IDA7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuc2VsZWN0KG9yaWdpbmFsRGIpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBSZWRpcyBkYXRhYmFzZXM6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IGRhdGFiYXNlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hTmFtZT86IHN0cmluZyk6IFByb21pc2U8VGFibGVbXT4ge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gJHtjb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwga2V5cyAobGltaXRlZCB0byAxMDAwIGZvciBwZXJmb3JtYW5jZSlcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBjbGllbnQua2V5cygnKicpO1xuICAgICAgICAgICAgY29uc3QgbGltaXRlZEtleXMgPSBrZXlzLnNsaWNlKDAsIDEwMDApO1xuXG4gICAgICAgICAgICBjb25zdCB0YWJsZXM6IFRhYmxlW10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBsaW1pdGVkS2V5cy5tYXAoYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gYXdhaXQgY2xpZW50LnR5cGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hTmFtZSB8fCAnZGIwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgYXMgYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQ6IHR5cGUgPT09ICdsaXN0JyA/IGF3YWl0IGNsaWVudC5sbGVuKGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnID8gYXdhaXQgY2xpZW50LnNjYXJkKGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnenNldCcgPyBhd2FpdCBjbGllbnQuemNhcmQoa2V5KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnaGFzaCcgPyBhd2FpdCBjbGllbnQuaGxlbihrZXkpIDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBSZWRpcyBrZXlzOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBrZXlzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZXNjcmliZVRhYmxlKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWFOYW1lOiBzdHJpbmcsIHRhYmxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUYWJsZU1ldGFkYXRhPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGF3YWl0IGNsaWVudC50eXBlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0dGwgPSBhd2FpdCBjbGllbnQudHRsKHRhYmxlTmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnM6IENvbHVtbltdID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2tleScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yZWlnbktleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3JlaWduS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3R0bCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHR0bC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcmVpZ25LZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5czogWydrZXknXSxcbiAgICAgICAgICAgICAgICBmb3JlaWduS2V5czogW10sXG4gICAgICAgICAgICAgICAgaW5kZXhlczogW10sXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSBSZWRpcyBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXNjcmliZSBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEluZGV4ZXMoX2Nvbm5lY3Rpb25JZDogc3RyaW5nLCBfc2NoZW1hTmFtZTogc3RyaW5nLCBfdGFibGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+IHtcbiAgICAgICAgLy8gUmVkaXMgZG9lc24ndCBoYXZlIHRyYWRpdGlvbmFsIGluZGV4ZXNcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGFzeW5jIGV4ZWN1dGVRdWVyeShyZXF1ZXN0OiBRdWVyeVJlcXVlc3QpOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQocmVxdWVzdC5jb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7cmVxdWVzdC5jb25uZWN0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUGFyc2UgUmVkaXMgY29tbWFuZCAoSlNPTiBmb3JtYXQpXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiB7XCJjb21tYW5kXCI6IFwiR0VUXCIsIFwiYXJnc1wiOiBbXCJteWtleVwiXX1cbiAgICAgICAgICAgIC8vIE9yOiB7XCJjb21tYW5kXCI6IFwiS0VZU1wiLCBcImFyZ3NcIjogW1wiKlwiXX1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5T2JqID0gSlNPTi5wYXJzZShyZXF1ZXN0LnF1ZXJ5KTtcblxuICAgICAgICAgICAgaWYgKCFxdWVyeU9iai5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBtdXN0IGhhdmUgXCJjb21tYW5kXCIgZmllbGQuIEV4YW1wbGU6IHtcImNvbW1hbmRcIjogXCJHRVRcIiwgXCJhcmdzXCI6IFtcIm15a2V5XCJdfScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gcXVlcnlPYmouY29tbWFuZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHF1ZXJ5T2JqLmFyZ3MgfHwgW107XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgUmVkaXMgY29tbWFuZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGNsaWVudCBhcyBhbnkpW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0oLi4uYXJncyk7XG5cbiAgICAgICAgICAgIC8vIEZvcm1hdCByZXN1bHQgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgIGxldCByb3dzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgbGV0IGZpZWxkczogYW55W10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSByZXN1bHQubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7IGluZGV4LCB2YWx1ZSB9KSk7XG4gICAgICAgICAgICAgICAgZmllbGRzID0gW3sgbmFtZTogJ2luZGV4JyB9LCB7IG5hbWU6ICd2YWx1ZScgfV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBbcmVzdWx0XTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZXN1bHQpLm1hcChrZXkgPT4gKHsgbmFtZToga2V5IH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IFt7IHJlc3VsdCB9XTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBbeyBuYW1lOiAncmVzdWx0JyB9XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgICAgICAgaGFzTW9yZTogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlZGlzIGNvbW1hbmQgZXhlY3V0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tbWFuZCBleGVjdXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBleHBsYWluUXVlcnkoX2Nvbm5lY3Rpb25JZDogc3RyaW5nLCBfcXVlcnk6IHN0cmluZyk6IFByb21pc2U8RXhwbGFpblJlc3VsdD4ge1xuICAgICAgICAvLyBSZWRpcyBkb2Vzbid0IGhhdmUgRVhQTEFJTiBmdW5jdGlvbmFsaXR5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbGFuOiB7IG1lc3NhZ2U6ICdSZWRpcyBkb2VzIG5vdCBzdXBwb3J0IHF1ZXJ5IHBsYW5zJyB9LFxuICAgICAgICAgICAgcGxhblRleHQ6ICdSZWRpcyBpcyBhIGtleS12YWx1ZSBzdG9yZSBhbmQgZG9lcyBub3QgaGF2ZSBTUUwtc3R5bGUgcXVlcnkgcGxhbnMuJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRWZXJzaW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uICR7Y29ubmVjdGlvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgY2xpZW50LmluZm8oJ3NlcnZlcicpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBpbmZvLm1hdGNoKC9yZWRpc192ZXJzaW9uOihbXlxcclxcbl0rKS8pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAndW5rbm93bic7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGdldCBSZWRpcyB2ZXJzaW9uOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHZlcnNpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPiB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50cy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IGNsaWVudC5pbmZvKCk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgY2xpZW50LmluZm8oJ3NlcnZlcicpO1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID0gc2VydmVySW5mby5tYXRjaCgvcmVkaXNfdmVyc2lvbjooW15cXHJcXG5dKykvKTtcbiAgICAgICAgICAgIGNvbnN0IHVwdGltZU1hdGNoID0gaW5mby5tYXRjaCgvdXB0aW1lX2luX3NlY29uZHM6KFxcZCspLyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk1hdGNoID8gdmVyc2lvbk1hdGNoWzFdIDogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgIHNlcnZlclZlcnNpb246IHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXSA6ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICB1cHRpbWU6IHVwdGltZU1hdGNoID8gcGFyc2VJbnQodXB0aW1lTWF0Y2hbMV0pIDogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YWJhc2U6IGBkYiR7Y2xpZW50Lm9wdGlvbnMuZGIgfHwgMH1gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IFJlZGlzIGRhdGFiYXNlIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZGF0YWJhc2UgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlJlZGlzIiwiQmFzZURCQWRhcHRlciIsIkxvZ2dlciIsImxvZ2dlciIsIlJlZGlzQWRhcHRlciIsImNvbm5lY3QiLCJjb25maWciLCJjb25uZWN0aW9uSWQiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsImNsaWVudCIsImhvc3QiLCJwb3J0IiwicGFzc3dvcmQiLCJkYiIsInBhcnNlSW50IiwiZGF0YWJhc2UiLCJjb25uZWN0VGltZW91dCIsImNvbm5lY3Rpb25UaW1lb3V0IiwicGluZyIsImNsaWVudHMiLCJzZXQiLCJpbmZvIiwic3VjY2VzcyIsInZlcnNpb24iLCJ0aGVuIiwibWF0Y2giLCJlcnJvciIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0IiwiZ2V0IiwicXVpdCIsImRlbGV0ZSIsInRlc3RDb25uZWN0aW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImxhdGVuY3kiLCJsaXN0U2NoZW1hcyIsIkVycm9yIiwiZGJDb3VudCIsInNjaGVtYXMiLCJpIiwic2VsZWN0Iiwia2V5Q291bnQiLCJkYnNpemUiLCJwdXNoIiwibmFtZSIsInRhYmxlQ291bnQiLCJvcmlnaW5hbERiIiwib3B0aW9ucyIsInRvU3RyaW5nIiwibGlzdFRhYmxlcyIsInNjaGVtYU5hbWUiLCJrZXlzIiwibGltaXRlZEtleXMiLCJzbGljZSIsInRhYmxlcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJrZXkiLCJ0eXBlIiwic2NoZW1hIiwicm93Q291bnQiLCJsbGVuIiwic2NhcmQiLCJ6Y2FyZCIsImhsZW4iLCJkZXNjcmliZVRhYmxlIiwidGFibGVOYW1lIiwidHRsIiwiY29sdW1ucyIsImRhdGFUeXBlIiwibnVsbGFibGUiLCJpc1ByaW1hcnlLZXkiLCJpc0ZvcmVpZ25LZXkiLCJkZWZhdWx0VmFsdWUiLCJwcmltYXJ5S2V5cyIsImZvcmVpZ25LZXlzIiwiaW5kZXhlcyIsImdldEluZGV4ZXMiLCJfY29ubmVjdGlvbklkIiwiX3NjaGVtYU5hbWUiLCJfdGFibGVOYW1lIiwiZXhlY3V0ZVF1ZXJ5IiwicmVxdWVzdCIsInF1ZXJ5T2JqIiwiSlNPTiIsInBhcnNlIiwicXVlcnkiLCJjb21tYW5kIiwidG9VcHBlckNhc2UiLCJhcmdzIiwicmVzdWx0IiwidG9Mb3dlckNhc2UiLCJyb3dzIiwiZmllbGRzIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsdWUiLCJpbmRleCIsIk9iamVjdCIsImV4ZWN1dGlvblRpbWUiLCJsZW5ndGgiLCJoYXNNb3JlIiwiZXhwbGFpblF1ZXJ5IiwiX3F1ZXJ5IiwicGxhbiIsInBsYW5UZXh0IiwiZ2V0VmVyc2lvbiIsImdldERhdGFiYXNlSW5mbyIsInNlcnZlckluZm8iLCJ2ZXJzaW9uTWF0Y2giLCJ1cHRpbWVNYXRjaCIsInNlcnZlclZlcnNpb24iLCJ1cHRpbWUiLCJjdXJyZW50RGF0YWJhc2UiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/adapters/redis/RedisAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/index.ts":
/*!***********************************************!*\
  !*** ../../packages/db-adapters/src/index.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterFactory: () => (/* reexport safe */ _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__.AdapterFactory),\n/* harmony export */   BaseDBAdapter: () => (/* reexport safe */ _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_0__.BaseDBAdapter),\n/* harmony export */   PostgreSQLAdapter: () => (/* reexport safe */ _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__.PostgreSQLAdapter)\n/* harmony export */ });\n/* harmony import */ var _interfaces_IDBAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces/IDBAdapter */ \"(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\");\n/* harmony import */ var _adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/postgresql/PostgreSQLAdapter */ \"(rsc)/../../packages/db-adapters/src/adapters/postgresql/PostgreSQLAdapter.ts\");\n/* harmony import */ var _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AdapterFactory */ \"(rsc)/../../packages/db-adapters/src/AdapterFactory.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__, _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__]);\n([_adapters_postgresql_PostgreSQLAdapter__WEBPACK_IMPORTED_MODULE_1__, _AdapterFactory__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QztBQUNnQjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2luZGV4LnRzPzVmMDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzL0lEQkFkYXB0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9hZGFwdGVycy9wb3N0Z3Jlc3FsL1Bvc3RncmVTUUxBZGFwdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vQWRhcHRlckZhY3RvcnknO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts":
/*!***************************************************************!*\
  !*** ../../packages/db-adapters/src/interfaces/IDBAdapter.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDBAdapter: () => (/* binding */ BaseDBAdapter)\n/* harmony export */ });\n/**\n * Base adapter class with common functionality\n */ class BaseDBAdapter {\n    /**\n     * Generate a unique connection ID\n     */ generateConnectionId(prefix) {\n        return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Get connection from map\n     */ getConnection(connectionId) {\n        const connection = this.connectionMap.get(connectionId);\n        if (!connection) {\n            throw new Error(`Connection not found: ${connectionId}`);\n        }\n        return connection;\n    }\n    /**\n     * Check if connection exists\n     */ hasConnection(connectionId) {\n        return this.connectionMap.has(connectionId);\n    }\n    constructor(){\n        this.connectionMap = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2ludGVyZmFjZXMvSURCQWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBc0dBOztDQUVDLEdBQ00sTUFBZUE7SUFtQmxCOztLQUVDLEdBQ0QscUJBQStCRSxNQUFjLEVBQVU7UUFDbkQsT0FBTyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxFQUFFQyxLQUFLQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDL0U7SUFFQTs7S0FFQyxHQUNELGNBQTJCRSxZQUFvQixFQUFLO1FBQ2hELE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0g7UUFDMUMsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsTUFBTSxJQUFJRyxNQUFNLENBQUMsc0JBQXNCLEVBQUVKLGFBQWEsQ0FBQztRQUMzRDtRQUNBLE9BQU9DO0lBQ1g7SUFFQTs7S0FFQyxHQUNELGNBQXdCRCxZQUFvQixFQUFXO1FBQ25ELE9BQU8sSUFBSSxDQUFDRSxhQUFhLENBQUNJLEdBQUcsQ0FBQ047SUFDbEM7O2FBekNVRSxnQkFBa0MsSUFBSUs7O0FBMENwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvZGItYWRhcHRlcnMvc3JjL2ludGVyZmFjZXMvSURCQWRhcHRlci50cz8yZGQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgICBDb25uZWN0aW9uQ29uZmlnLFxuICAgIENvbm5lY3Rpb25SZXN1bHQsXG4gICAgVGVzdFJlc3VsdCxcbiAgICBRdWVyeVJlcXVlc3QsXG4gICAgUXVlcnlSZXN1bHQsXG4gICAgRXhwbGFpblJlc3VsdCxcbiAgICBTY2hlbWEsXG4gICAgVGFibGUsXG4gICAgVGFibGVNZXRhZGF0YSxcbiAgICBJbmRleCxcbiAgICBEYXRhYmFzZUluZm8sXG59IGZyb20gJ0Bib3NkYi9jb3JlJztcblxuLyoqXG4gKiBDb3JlIGRhdGFiYXNlIGFkYXB0ZXIgaW50ZXJmYWNlXG4gKiBBbGwgZGF0YWJhc2Utc3BlY2lmaWMgYWRhcHRlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJREJBZGFwdGVyIHtcbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSBjb25maWcgQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgQ29ubmVjdGlvbiByZXN1bHQgd2l0aCBjb25uZWN0aW9uIElEXG4gICAgICovXG4gICAgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYSBkYXRhYmFzZSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEIHRvIGNsb3NlXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGRhdGFiYXNlIGNvbm5lY3Rpb24gd2l0aG91dCBlc3RhYmxpc2hpbmcgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbm5lY3Rpb24gY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIFRlc3QgcmVzdWx0IHdpdGggc3VjY2VzcyBzdGF0dXNcbiAgICAgKi9cbiAgICB0ZXN0Q29ubmVjdGlvbihjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPFRlc3RSZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgc2NoZW1hcyBpbiB0aGUgZGF0YWJhc2VcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBzY2hlbWFzXG4gICAgICovXG4gICAgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPjtcblxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHRhYmxlcyBpbiBhIHNjaGVtYVxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgQ29ubmVjdGlvbiBJRFxuICAgICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIG5hbWUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBwdWJsaWMvZGVmYXVsdCBzY2hlbWEpXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdGFibGVzXG4gICAgICovXG4gICAgbGlzdFRhYmxlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hPzogc3RyaW5nKTogUHJvbWlzZTxUYWJsZVtdPjtcblxuICAgIC8qKlxuICAgICAqIEdldCBkZXRhaWxlZCBtZXRhZGF0YSBhYm91dCBhIHRhYmxlXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEXG4gICAgICogQHBhcmFtIHNjaGVtYSBTY2hlbWEgbmFtZVxuICAgICAqIEBwYXJhbSB0YWJsZSBUYWJsZSBuYW1lXG4gICAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIGNvbHVtbnMsIGtleXMsIGFuZCBpbmRleGVzXG4gICAgICovXG4gICAgZGVzY3JpYmVUYWJsZShjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlTWV0YWRhdGE+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4ZXMgZm9yIGEgdGFibGVcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0gc2NoZW1hIFNjaGVtYSBuYW1lXG4gICAgICogQHBhcmFtIHRhYmxlIFRhYmxlIG5hbWVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBpbmRleGVzXG4gICAgICovXG4gICAgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHF1ZXJ5IGFnYWluc3QgdGhlIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIHJlcXVlc3QgUXVlcnkgcmVxdWVzdCB3aXRoIHF1ZXJ5IHN0cmluZyBhbmQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFF1ZXJ5IHJlc3VsdCB3aXRoIHJvd3MgYW5kIG1ldGFkYXRhXG4gICAgICovXG4gICAgZXhlY3V0ZVF1ZXJ5KHJlcXVlc3Q6IFF1ZXJ5UmVxdWVzdCk6IFByb21pc2U8UXVlcnlSZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXJ5IGV4ZWN1dGlvbiBwbGFuIChmb3Igc3VwcG9ydGVkIGRhdGFiYXNlcylcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMgUXVlcnkgZXhlY3V0aW9uIHBsYW5cbiAgICAgKi9cbiAgICBleHBsYWluUXVlcnkoY29ubmVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEV4cGxhaW5SZXN1bHQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFiYXNlIHZlcnNpb25cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIENvbm5lY3Rpb24gSURcbiAgICAgKiBAcmV0dXJucyBEYXRhYmFzZSB2ZXJzaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2UgaW5mb3JtYXRpb24gYW5kIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCBDb25uZWN0aW9uIElEXG4gICAgICogQHJldHVybnMgRGF0YWJhc2UgaW5mb1xuICAgICAqL1xuICAgIGdldERhdGFiYXNlSW5mbyhjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8RGF0YWJhc2VJbmZvPjtcbn1cblxuLyoqXG4gKiBCYXNlIGFkYXB0ZXIgY2xhc3Mgd2l0aCBjb21tb24gZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZURCQWRhcHRlciBpbXBsZW1lbnRzIElEQkFkYXB0ZXIge1xuICAgIHByb3RlY3RlZCBjb25uZWN0aW9uTWFwOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xuXG4gICAgYWJzdHJhY3QgY29ubmVjdChjb25maWc6IENvbm5lY3Rpb25Db25maWcpOiBQcm9taXNlPENvbm5lY3Rpb25SZXN1bHQ+O1xuICAgIGFic3RyYWN0IGRpc2Nvbm5lY3QoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICAgIGFic3RyYWN0IHRlc3RDb25uZWN0aW9uKGNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyk6IFByb21pc2U8VGVzdFJlc3VsdD47XG4gICAgYWJzdHJhY3QgbGlzdFNjaGVtYXMoY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPFNjaGVtYVtdPjtcbiAgICBhYnN0cmFjdCBsaXN0VGFibGVzKGNvbm5lY3Rpb25JZDogc3RyaW5nLCBzY2hlbWE/OiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlW10+O1xuICAgIGFic3RyYWN0IGRlc2NyaWJlVGFibGUoXG4gICAgICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nLFxuICAgICAgICBzY2hlbWE6IHN0cmluZyxcbiAgICAgICAgdGFibGU6IHN0cmluZ1xuICAgICk6IFByb21pc2U8VGFibGVNZXRhZGF0YT47XG4gICAgYWJzdHJhY3QgZ2V0SW5kZXhlcyhjb25uZWN0aW9uSWQ6IHN0cmluZywgc2NoZW1hOiBzdHJpbmcsIHRhYmxlOiBzdHJpbmcpOiBQcm9taXNlPEluZGV4W10+O1xuICAgIGFic3RyYWN0IGV4ZWN1dGVRdWVyeShyZXF1ZXN0OiBRdWVyeVJlcXVlc3QpOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PjtcbiAgICBhYnN0cmFjdCBleHBsYWluUXVlcnkoY29ubmVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEV4cGxhaW5SZXN1bHQ+O1xuICAgIGFic3RyYWN0IGdldFZlcnNpb24oY29ubmVjdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG4gICAgYWJzdHJhY3QgZ2V0RGF0YWJhc2VJbmZvKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxEYXRhYmFzZUluZm8+O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB1bmlxdWUgY29ubmVjdGlvbiBJRFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZW5lcmF0ZUNvbm5lY3Rpb25JZChwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29ubmVjdGlvbiBmcm9tIG1hcFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb25uZWN0aW9uPFQ+KGNvbm5lY3Rpb25JZDogc3RyaW5nKTogVCB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25NYXAuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIG5vdCBmb3VuZDogJHtjb25uZWN0aW9uSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gYXMgVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb25uZWN0aW9uIGV4aXN0c1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBoYXNDb25uZWN0aW9uKGNvbm5lY3Rpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYXAuaGFzKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkJhc2VEQkFkYXB0ZXIiLCJnZW5lcmF0ZUNvbm5lY3Rpb25JZCIsInByZWZpeCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJnZXRDb25uZWN0aW9uIiwiY29ubmVjdGlvbklkIiwiY29ubmVjdGlvbiIsImNvbm5lY3Rpb25NYXAiLCJnZXQiLCJFcnJvciIsImhhc0Nvbm5lY3Rpb24iLCJoYXMiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/db-adapters/src/interfaces/IDBAdapter.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/security/src/encryption/encryption.ts":
/*!************************************************************!*\
  !*** ../../packages/security/src/encryption/encryption.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialEncryption: () => (/* binding */ CredentialEncryption),\n/* harmony export */   decryptCredentials: () => (/* binding */ decryptCredentials),\n/* harmony export */   encryptCredentials: () => (/* binding */ encryptCredentials),\n/* harmony export */   getEncryptionInstance: () => (/* binding */ getEncryptionInstance)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ALGORITHM = \"aes-256-gcm\";\nconst KEY_LENGTH = 32;\nconst IV_LENGTH = 16;\nconst TAG_LENGTH = 16;\nconst SALT = \"bosdb-salt-v1\"; // In production, use a secure random salt\n/**\n * Credential encryption service using AES-256-GCM\n * Provides authenticated encryption for sensitive database credentials\n */ class CredentialEncryption {\n    constructor(masterKey){\n        // In production, this should come from environment variable or secret manager\n        const keySource = masterKey || process.env.ENCRYPTION_MASTER_KEY;\n        if (!keySource) {\n            throw new Error(\"Encryption master key not configured. Set ENCRYPTION_MASTER_KEY environment variable.\");\n        }\n        // Derive encryption key from master key using scrypt\n        this.key = crypto__WEBPACK_IMPORTED_MODULE_0___default().scryptSync(keySource, SALT, KEY_LENGTH);\n    }\n    /**\n     * Encrypt credentials data\n     * @param data Credentials object to encrypt\n     * @returns Base64-encoded encrypted string\n     */ encrypt(data) {\n        const iv = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(IV_LENGTH);\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(ALGORITHM, this.key, iv);\n        const plaintext = JSON.stringify(data);\n        let encrypted = cipher.update(plaintext, \"utf8\", \"hex\");\n        encrypted += cipher.final(\"hex\");\n        const tag = cipher.getAuthTag();\n        // Combine IV + encrypted data + auth tag\n        const combined = Buffer.concat([\n            iv,\n            Buffer.from(encrypted, \"hex\"),\n            tag\n        ]);\n        return combined.toString(\"base64\");\n    }\n    /**\n     * Decrypt credentials data\n     * @param encryptedData Base64-encoded encrypted string\n     * @returns Decrypted credentials object\n     */ decrypt(encryptedData) {\n        try {\n            const buffer = Buffer.from(encryptedData, \"base64\");\n            const iv = buffer.subarray(0, IV_LENGTH);\n            const tag = buffer.subarray(buffer.length - TAG_LENGTH);\n            const encrypted = buffer.subarray(IV_LENGTH, buffer.length - TAG_LENGTH);\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(ALGORITHM, this.key, iv);\n            decipher.setAuthTag(tag);\n            let decrypted = decipher.update(encrypted);\n            decrypted = Buffer.concat([\n                decrypted,\n                decipher.final()\n            ]);\n            return JSON.parse(decrypted.toString(\"utf8\"));\n        } catch (error) {\n            throw new Error(`Decryption failed: ${error.message}`);\n        }\n    }\n    /**\n     * Hash a password or sensitive string (one-way)\n     * @param value Value to hash\n     * @returns Hex-encoded hash\n     */ hash(value) {\n        return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha256\").update(value).digest(\"hex\");\n    }\n    /**\n     * Generate a secure random token\n     * @param length Token length in bytes (default: 32)\n     * @returns Hex-encoded random token\n     */ static generateToken(length = 32) {\n        return crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(length).toString(\"hex\");\n    }\n}\n/**\n * Helper functions for credential encryption\n */ let encryptionInstance = null;\nfunction getEncryptionInstance() {\n    if (!encryptionInstance) {\n        encryptionInstance = new CredentialEncryption();\n    }\n    return encryptionInstance;\n}\nfunction encryptCredentials(credentials) {\n    return getEncryptionInstance().encrypt(credentials);\n}\nfunction decryptCredentials(encryptedData) {\n    return getEncryptionInstance().decrypt(encryptedData);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvc2VjdXJpdHkvc3JjL2VuY3J5cHRpb24vZW5jcnlwdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEI7QUFFNUIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxPQUFPLGlCQUFpQiwwQ0FBMEM7QUFFeEU7OztDQUdDLEdBQ00sTUFBTUM7SUFHVEMsWUFBWUMsU0FBa0IsQ0FBRTtRQUM1Qiw4RUFBOEU7UUFDOUUsTUFBTUMsWUFBWUQsYUFBYUUsUUFBUUMsR0FBRyxDQUFDQyxxQkFBcUI7UUFDaEUsSUFBSSxDQUFDSCxXQUFXO1lBQ1osTUFBTSxJQUFJSSxNQUFNO1FBQ3BCO1FBRUEscURBQXFEO1FBQ3JELElBQUksQ0FBQ0MsR0FBRyxHQUFHZCx3REFBaUIsQ0FBQ1MsV0FBV0osTUFBTUg7SUFDbEQ7SUFFQTs7OztLQUlDLEdBQ0RjLFFBQVFDLElBQVMsRUFBVTtRQUN2QixNQUFNQyxLQUFLbEIseURBQWtCLENBQUNHO1FBQzlCLE1BQU1pQixTQUFTcEIsNERBQXFCLENBQUNDLFdBQVcsSUFBSSxDQUFDYSxHQUFHLEVBQUVJO1FBRTFELE1BQU1JLFlBQVlDLEtBQUtDLFNBQVMsQ0FBQ1A7UUFDakMsSUFBSVEsWUFBWUwsT0FBT00sTUFBTSxDQUFDSixXQUFXLFFBQVE7UUFDakRHLGFBQWFMLE9BQU9PLEtBQUssQ0FBQztRQUUxQixNQUFNQyxNQUFNUixPQUFPUyxVQUFVO1FBRTdCLHlDQUF5QztRQUN6QyxNQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUM7WUFBQ2Q7WUFBSWEsT0FBT0UsSUFBSSxDQUFDUixXQUFXO1lBQVFHO1NBQUk7UUFFdkUsT0FBT0UsU0FBU0ksUUFBUSxDQUFDO0lBQzdCO0lBRUE7Ozs7S0FJQyxHQUNEQyxRQUFRQyxhQUFxQixFQUFPO1FBQ2hDLElBQUk7WUFDQSxNQUFNQyxTQUFTTixPQUFPRSxJQUFJLENBQUNHLGVBQWU7WUFFMUMsTUFBTWxCLEtBQUttQixPQUFPQyxRQUFRLENBQUMsR0FBR25DO1lBQzlCLE1BQU15QixNQUFNUyxPQUFPQyxRQUFRLENBQUNELE9BQU9FLE1BQU0sR0FBR25DO1lBQzVDLE1BQU1xQixZQUFZWSxPQUFPQyxRQUFRLENBQUNuQyxXQUFXa0MsT0FBT0UsTUFBTSxHQUFHbkM7WUFFN0QsTUFBTW9DLFdBQVd4Qyw4REFBdUIsQ0FBQ0MsV0FBVyxJQUFJLENBQUNhLEdBQUcsRUFBRUk7WUFDOURzQixTQUFTRSxVQUFVLENBQUNkO1lBRXBCLElBQUllLFlBQVlILFNBQVNkLE1BQU0sQ0FBQ0Q7WUFDaENrQixZQUFZWixPQUFPQyxNQUFNLENBQUM7Z0JBQUNXO2dCQUFXSCxTQUFTYixLQUFLO2FBQUc7WUFFdkQsT0FBT0osS0FBS3FCLEtBQUssQ0FBQ0QsVUFBVVQsUUFBUSxDQUFDO1FBQ3pDLEVBQUUsT0FBT1csT0FBWTtZQUNqQixNQUFNLElBQUloQyxNQUFNLENBQUMsbUJBQW1CLEVBQUVnQyxNQUFNQyxPQUFPLENBQUMsQ0FBQztRQUN6RDtJQUNKO0lBRUE7Ozs7S0FJQyxHQUNEQyxLQUFLQyxLQUFhLEVBQVU7UUFDeEIsT0FBT2hELHdEQUFpQixDQUFDLFVBQVUwQixNQUFNLENBQUNzQixPQUFPRSxNQUFNLENBQUM7SUFDNUQ7SUFFQTs7OztLQUlDLEdBQ0QsT0FBT0MsY0FBY1osU0FBaUIsRUFBRSxFQUFVO1FBQzlDLE9BQU92Qyx5REFBa0IsQ0FBQ3VDLFFBQVFMLFFBQVEsQ0FBQztJQUMvQztBQUNKO0FBRUE7O0NBRUMsR0FFRCxJQUFJa0IscUJBQWtEO0FBRS9DLFNBQVNDO0lBQ1osSUFBSSxDQUFDRCxvQkFBb0I7UUFDckJBLHFCQUFxQixJQUFJOUM7SUFDN0I7SUFDQSxPQUFPOEM7QUFDWDtBQUVPLFNBQVNFLG1CQUFtQkMsV0FBZ0I7SUFDL0MsT0FBT0Ysd0JBQXdCckMsT0FBTyxDQUFDdUM7QUFDM0M7QUFFTyxTQUFTQyxtQkFBbUJwQixhQUFxQjtJQUNwRCxPQUFPaUIsd0JBQXdCbEIsT0FBTyxDQUFDQztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvc2VjdXJpdHkvc3JjL2VuY3J5cHRpb24vZW5jcnlwdGlvbi50cz9jMTdjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuY29uc3QgQUxHT1JJVEhNID0gJ2Flcy0yNTYtZ2NtJztcbmNvbnN0IEtFWV9MRU5HVEggPSAzMjtcbmNvbnN0IElWX0xFTkdUSCA9IDE2O1xuY29uc3QgVEFHX0xFTkdUSCA9IDE2O1xuY29uc3QgU0FMVCA9ICdib3NkYi1zYWx0LXYxJzsgLy8gSW4gcHJvZHVjdGlvbiwgdXNlIGEgc2VjdXJlIHJhbmRvbSBzYWx0XG5cbi8qKlxuICogQ3JlZGVudGlhbCBlbmNyeXB0aW9uIHNlcnZpY2UgdXNpbmcgQUVTLTI1Ni1HQ01cbiAqIFByb3ZpZGVzIGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvbiBmb3Igc2Vuc2l0aXZlIGRhdGFiYXNlIGNyZWRlbnRpYWxzXG4gKi9cbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsRW5jcnlwdGlvbiB7XG4gICAgcHJpdmF0ZSBrZXk6IEJ1ZmZlcjtcblxuICAgIGNvbnN0cnVjdG9yKG1hc3RlcktleT86IHN0cmluZykge1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHNob3VsZCBjb21lIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGUgb3Igc2VjcmV0IG1hbmFnZXJcbiAgICAgICAgY29uc3Qga2V5U291cmNlID0gbWFzdGVyS2V5IHx8IHByb2Nlc3MuZW52LkVOQ1JZUFRJT05fTUFTVEVSX0tFWTtcbiAgICAgICAgaWYgKCFrZXlTb3VyY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBtYXN0ZXIga2V5IG5vdCBjb25maWd1cmVkLiBTZXQgRU5DUllQVElPTl9NQVNURVJfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVyaXZlIGVuY3J5cHRpb24ga2V5IGZyb20gbWFzdGVyIGtleSB1c2luZyBzY3J5cHRcbiAgICAgICAgdGhpcy5rZXkgPSBjcnlwdG8uc2NyeXB0U3luYyhrZXlTb3VyY2UsIFNBTFQsIEtFWV9MRU5HVEgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgY3JlZGVudGlhbHMgZGF0YVxuICAgICAqIEBwYXJhbSBkYXRhIENyZWRlbnRpYWxzIG9iamVjdCB0byBlbmNyeXB0XG4gICAgICogQHJldHVybnMgQmFzZTY0LWVuY29kZWQgZW5jcnlwdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGVuY3J5cHQoZGF0YTogYW55KTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgaXYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoSVZfTEVOR1RIKTtcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFMR09SSVRITSwgdGhpcy5rZXksIGl2KTtcblxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgbGV0IGVuY3J5cHRlZCA9IGNpcGhlci51cGRhdGUocGxhaW50ZXh0LCAndXRmOCcsICdoZXgnKTtcbiAgICAgICAgZW5jcnlwdGVkICs9IGNpcGhlci5maW5hbCgnaGV4Jyk7XG5cbiAgICAgICAgY29uc3QgdGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcblxuICAgICAgICAvLyBDb21iaW5lIElWICsgZW5jcnlwdGVkIGRhdGEgKyBhdXRoIHRhZ1xuICAgICAgICBjb25zdCBjb21iaW5lZCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBCdWZmZXIuZnJvbShlbmNyeXB0ZWQsICdoZXgnKSwgdGFnXSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGNyZWRlbnRpYWxzIGRhdGFcbiAgICAgKiBAcGFyYW0gZW5jcnlwdGVkRGF0YSBCYXNlNjQtZW5jb2RlZCBlbmNyeXB0ZWQgc3RyaW5nXG4gICAgICogQHJldHVybnMgRGVjcnlwdGVkIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgICAqL1xuICAgIGRlY3J5cHQoZW5jcnlwdGVkRGF0YTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZERhdGEsICdiYXNlNjQnKTtcblxuICAgICAgICAgICAgY29uc3QgaXYgPSBidWZmZXIuc3ViYXJyYXkoMCwgSVZfTEVOR1RIKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGJ1ZmZlci5zdWJhcnJheShidWZmZXIubGVuZ3RoIC0gVEFHX0xFTkdUSCk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBidWZmZXIuc3ViYXJyYXkoSVZfTEVOR1RILCBidWZmZXIubGVuZ3RoIC0gVEFHX0xFTkdUSCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUxHT1JJVEhNLCB0aGlzLmtleSwgaXYpO1xuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyh0YWcpO1xuXG4gICAgICAgICAgICBsZXQgZGVjcnlwdGVkID0gZGVjaXBoZXIudXBkYXRlKGVuY3J5cHRlZCk7XG4gICAgICAgICAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KFtkZWNyeXB0ZWQsIGRlY2lwaGVyLmZpbmFsKCldKTtcblxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY3J5cHRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYXNoIGEgcGFzc3dvcmQgb3Igc2Vuc2l0aXZlIHN0cmluZyAob25lLXdheSlcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gaGFzaFxuICAgICAqIEByZXR1cm5zIEhleC1lbmNvZGVkIGhhc2hcbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZSh2YWx1ZSkuZGlnZXN0KCdoZXgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHNlY3VyZSByYW5kb20gdG9rZW5cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRva2VuIGxlbmd0aCBpbiBieXRlcyAoZGVmYXVsdDogMzIpXG4gICAgICogQHJldHVybnMgSGV4LWVuY29kZWQgcmFuZG9tIHRva2VuXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlVG9rZW4obGVuZ3RoOiBudW1iZXIgPSAzMik6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNyZWRlbnRpYWwgZW5jcnlwdGlvblxuICovXG5cbmxldCBlbmNyeXB0aW9uSW5zdGFuY2U6IENyZWRlbnRpYWxFbmNyeXB0aW9uIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmNyeXB0aW9uSW5zdGFuY2UoKTogQ3JlZGVudGlhbEVuY3J5cHRpb24ge1xuICAgIGlmICghZW5jcnlwdGlvbkluc3RhbmNlKSB7XG4gICAgICAgIGVuY3J5cHRpb25JbnN0YW5jZSA9IG5ldyBDcmVkZW50aWFsRW5jcnlwdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGlvbkluc3RhbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzOiBhbnkpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRFbmNyeXB0aW9uSW5zdGFuY2UoKS5lbmNyeXB0KGNyZWRlbnRpYWxzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRDcmVkZW50aWFscyhlbmNyeXB0ZWREYXRhOiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiBnZXRFbmNyeXB0aW9uSW5zdGFuY2UoKS5kZWNyeXB0KGVuY3J5cHRlZERhdGEpO1xufVxuIl0sIm5hbWVzIjpbImNyeXB0byIsIkFMR09SSVRITSIsIktFWV9MRU5HVEgiLCJJVl9MRU5HVEgiLCJUQUdfTEVOR1RIIiwiU0FMVCIsIkNyZWRlbnRpYWxFbmNyeXB0aW9uIiwiY29uc3RydWN0b3IiLCJtYXN0ZXJLZXkiLCJrZXlTb3VyY2UiLCJwcm9jZXNzIiwiZW52IiwiRU5DUllQVElPTl9NQVNURVJfS0VZIiwiRXJyb3IiLCJrZXkiLCJzY3J5cHRTeW5jIiwiZW5jcnlwdCIsImRhdGEiLCJpdiIsInJhbmRvbUJ5dGVzIiwiY2lwaGVyIiwiY3JlYXRlQ2lwaGVyaXYiLCJwbGFpbnRleHQiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5jcnlwdGVkIiwidXBkYXRlIiwiZmluYWwiLCJ0YWciLCJnZXRBdXRoVGFnIiwiY29tYmluZWQiLCJCdWZmZXIiLCJjb25jYXQiLCJmcm9tIiwidG9TdHJpbmciLCJkZWNyeXB0IiwiZW5jcnlwdGVkRGF0YSIsImJ1ZmZlciIsInN1YmFycmF5IiwibGVuZ3RoIiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2Iiwic2V0QXV0aFRhZyIsImRlY3J5cHRlZCIsInBhcnNlIiwiZXJyb3IiLCJtZXNzYWdlIiwiaGFzaCIsInZhbHVlIiwiY3JlYXRlSGFzaCIsImRpZ2VzdCIsImdlbmVyYXRlVG9rZW4iLCJlbmNyeXB0aW9uSW5zdGFuY2UiLCJnZXRFbmNyeXB0aW9uSW5zdGFuY2UiLCJlbmNyeXB0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImRlY3J5cHRDcmVkZW50aWFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/security/src/encryption/encryption.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/security/src/index.ts":
/*!********************************************!*\
  !*** ../../packages/security/src/index.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialEncryption: () => (/* reexport safe */ _encryption_encryption__WEBPACK_IMPORTED_MODULE_0__.CredentialEncryption),\n/* harmony export */   decryptCredentials: () => (/* reexport safe */ _encryption_encryption__WEBPACK_IMPORTED_MODULE_0__.decryptCredentials),\n/* harmony export */   encryptCredentials: () => (/* reexport safe */ _encryption_encryption__WEBPACK_IMPORTED_MODULE_0__.encryptCredentials),\n/* harmony export */   escapeString: () => (/* reexport safe */ _sql_guard_sql_guard__WEBPACK_IMPORTED_MODULE_1__.escapeString),\n/* harmony export */   getEncryptionInstance: () => (/* reexport safe */ _encryption_encryption__WEBPACK_IMPORTED_MODULE_0__.getEncryptionInstance),\n/* harmony export */   isReadOnlyQuery: () => (/* reexport safe */ _sql_guard_sql_guard__WEBPACK_IMPORTED_MODULE_1__.isReadOnlyQuery),\n/* harmony export */   sanitizeIdentifier: () => (/* reexport safe */ _sql_guard_sql_guard__WEBPACK_IMPORTED_MODULE_1__.sanitizeIdentifier),\n/* harmony export */   validateQuery: () => (/* reexport safe */ _sql_guard_sql_guard__WEBPACK_IMPORTED_MODULE_1__.validateQuery)\n/* harmony export */ });\n/* harmony import */ var _encryption_encryption__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encryption/encryption */ \"(rsc)/../../packages/security/src/encryption/encryption.ts\");\n/* harmony import */ var _sql_guard_sql_guard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sql-guard/sql-guard */ \"(rsc)/../../packages/security/src/sql-guard/sql-guard.ts\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvc2VjdXJpdHkvc3JjL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvc2VjdXJpdHkvc3JjL2luZGV4LnRzPzA5ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9lbmNyeXB0aW9uL2VuY3J5cHRpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9zcWwtZ3VhcmQvc3FsLWd1YXJkJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/security/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/security/src/sql-guard/sql-guard.ts":
/*!**********************************************************!*\
  !*** ../../packages/security/src/sql-guard/sql-guard.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeString: () => (/* binding */ escapeString),\n/* harmony export */   isReadOnlyQuery: () => (/* binding */ isReadOnlyQuery),\n/* harmony export */   sanitizeIdentifier: () => (/* binding */ sanitizeIdentifier),\n/* harmony export */   validateQuery: () => (/* binding */ validateQuery)\n/* harmony export */ });\n/**\n * SQL injection detection and query validation\n */ /**\n * Validate a SQL query for potentially dangerous patterns\n * This is a defense-in-depth measure, not a replacement for parameterized queries\n */ function validateQuery(query) {\n    // Normalize query\n    const normalized = query.replace(/--.*$/gm, \"\") // Remove single-line comments\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Remove multi-line comments\n    .replace(/\\s+/g, \" \") // Normalize whitespace\n    .trim().toLowerCase();\n    // Check for multiple statements (SQL injection attempts)\n    const statements = normalized.split(\";\").filter((s)=>s.trim().length > 0);\n    const hasMultipleStatements = statements.length > 1;\n    // Highly dangerous patterns (blocking level)\n    const blockedPatterns = [\n        {\n            pattern: /xp_cmdshell/i,\n            severity: \"high\",\n            desc: \"Command execution attempt\"\n        },\n        {\n            pattern: /exec\\s*\\(/i,\n            severity: \"high\",\n            desc: \"Dynamic SQL execution\"\n        },\n        {\n            pattern: /into\\s+outfile/i,\n            severity: \"high\",\n            desc: \"File write attempt\"\n        },\n        {\n            pattern: /load_file/i,\n            severity: \"high\",\n            desc: \"File read attempt\"\n        }\n    ];\n    // Multi-statement attacks (only block if multiple statements detected)\n    const multiStatementPatterns = [\n        {\n            pattern: /;\\s*drop\\s+(table|database|schema)/i,\n            severity: \"high\",\n            desc: \"DROP in multi-statement\"\n        },\n        {\n            pattern: /;\\s*truncate\\s+/i,\n            severity: \"high\",\n            desc: \"TRUNCATE in multi-statement\"\n        },\n        {\n            pattern: /;\\s*delete\\s+from/i,\n            severity: \"high\",\n            desc: \"DELETE in multi-statement\"\n        },\n        {\n            pattern: /;\\s*shutdown/i,\n            severity: \"high\",\n            desc: \"Shutdown command\"\n        }\n    ];\n    // Suspicious patterns (warning level) - only for multi-statement queries\n    const suspiciousPatterns = [\n        {\n            pattern: /union\\s+select/i,\n            severity: \"medium\",\n            desc: \"UNION-based injection\"\n        }\n    ];\n    const detectedPatterns = [];\n    let maxSeverity = \"low\";\n    // Check blocked patterns\n    for (const { pattern, severity, desc } of blockedPatterns){\n        if (pattern.test(normalized)) {\n            detectedPatterns.push(desc);\n            if (severity === \"high\") {\n                maxSeverity = \"high\";\n            }\n        }\n    }\n    // Check multi-statement patterns only if multiple statements detected\n    if (hasMultipleStatements) {\n        for (const { pattern, severity, desc } of multiStatementPatterns){\n            if (pattern.test(normalized)) {\n                detectedPatterns.push(desc);\n                if (severity === \"high\") {\n                    maxSeverity = \"high\";\n                }\n            }\n        }\n    }\n    // If high severity patterns found, block immediately\n    if (maxSeverity === \"high\") {\n        return {\n            safe: false,\n            reason: \"Dangerous SQL patterns detected\",\n            patterns: detectedPatterns,\n            severity: \"high\"\n        };\n    }\n    // Check suspicious patterns only for multi-statement queries\n    if (hasMultipleStatements) {\n        for (const { pattern, desc } of suspiciousPatterns){\n            if (pattern.test(normalized)) {\n                detectedPatterns.push(desc);\n                if (maxSeverity === \"low\") {\n                    maxSeverity = \"medium\";\n                }\n            }\n        }\n    }\n    if (detectedPatterns.length > 0) {\n        return {\n            safe: false,\n            reason: \"Suspicious SQL patterns detected\",\n            patterns: detectedPatterns,\n            severity: maxSeverity\n        };\n    }\n    return {\n        safe: true\n    };\n}\n/**\n * Sanitize table/column names (prevent SQL injection in identifiers)\n */ function sanitizeIdentifier(identifier) {\n    // Only allow alphanumeric, underscore, and hyphen\n    if (!/^[a-zA-Z0-9_-]+$/.test(identifier)) {\n        throw new Error(`Invalid identifier: ${identifier}`);\n    }\n    return identifier;\n}\n/**\n * Escape string values for SQL (use parameterized queries instead when possible)\n */ function escapeString(value) {\n    return value.replace(/'/g, \"''\");\n}\n/**\n * Check if query is read-only (safe for read-only connections)\n */ function isReadOnlyQuery(query) {\n    const normalized = query.trim().toLowerCase();\n    // Allow SELECT, EXPLAIN, SHOW, DESCRIBE\n    const readOnlyKeywords = [\n        \"select\",\n        \"explain\",\n        \"show\",\n        \"describe\",\n        \"with\"\n    ];\n    return readOnlyKeywords.some((keyword)=>normalized.startsWith(keyword));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvc2VjdXJpdHkvc3JjL3NxbC1ndWFyZC9zcWwtZ3VhcmQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztDQUVDLEdBU0Q7OztDQUdDLEdBQ00sU0FBU0EsY0FBY0MsS0FBYTtJQUN2QyxrQkFBa0I7SUFDbEIsTUFBTUMsYUFBYUQsTUFDZEUsT0FBTyxDQUFDLFdBQVcsSUFBSSw4QkFBOEI7S0FDckRBLE9BQU8sQ0FBQyxxQkFBcUIsSUFBSSw2QkFBNkI7S0FDOURBLE9BQU8sQ0FBQyxRQUFRLEtBQUssdUJBQXVCO0tBQzVDQyxJQUFJLEdBQ0pDLFdBQVc7SUFFaEIseURBQXlEO0lBQ3pELE1BQU1DLGFBQWFKLFdBQVdLLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVMLElBQUksR0FBR00sTUFBTSxHQUFHO0lBQ3ZFLE1BQU1DLHdCQUF3QkwsV0FBV0ksTUFBTSxHQUFHO0lBRWxELDZDQUE2QztJQUM3QyxNQUFNRSxrQkFBa0I7UUFDcEI7WUFBRUMsU0FBUztZQUFnQkMsVUFBVTtZQUFRQyxNQUFNO1FBQTRCO1FBQy9FO1lBQUVGLFNBQVM7WUFBY0MsVUFBVTtZQUFRQyxNQUFNO1FBQXdCO1FBQ3pFO1lBQUVGLFNBQVM7WUFBbUJDLFVBQVU7WUFBUUMsTUFBTTtRQUFxQjtRQUMzRTtZQUFFRixTQUFTO1lBQWNDLFVBQVU7WUFBUUMsTUFBTTtRQUFvQjtLQUN4RTtJQUVELHVFQUF1RTtJQUN2RSxNQUFNQyx5QkFBeUI7UUFDM0I7WUFBRUgsU0FBUztZQUF1Q0MsVUFBVTtZQUFRQyxNQUFNO1FBQTBCO1FBQ3BHO1lBQUVGLFNBQVM7WUFBb0JDLFVBQVU7WUFBUUMsTUFBTTtRQUE4QjtRQUNyRjtZQUFFRixTQUFTO1lBQXNCQyxVQUFVO1lBQVFDLE1BQU07UUFBNEI7UUFDckY7WUFBRUYsU0FBUztZQUFpQkMsVUFBVTtZQUFRQyxNQUFNO1FBQW1CO0tBQzFFO0lBRUQseUVBQXlFO0lBQ3pFLE1BQU1FLHFCQUFxQjtRQUN2QjtZQUFFSixTQUFTO1lBQW1CQyxVQUFVO1lBQVVDLE1BQU07UUFBd0I7S0FDbkY7SUFFRCxNQUFNRyxtQkFBNkIsRUFBRTtJQUNyQyxJQUFJQyxjQUF5QztJQUU3Qyx5QkFBeUI7SUFDekIsS0FBSyxNQUFNLEVBQUVOLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUUsSUFBSUgsZ0JBQWlCO1FBQ3ZELElBQUlDLFFBQVFPLElBQUksQ0FBQ2xCLGFBQWE7WUFDMUJnQixpQkFBaUJHLElBQUksQ0FBQ047WUFDdEIsSUFBSUQsYUFBYSxRQUFRO2dCQUNyQkssY0FBYztZQUNsQjtRQUNKO0lBQ0o7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSVIsdUJBQXVCO1FBQ3ZCLEtBQUssTUFBTSxFQUFFRSxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFLElBQUlDLHVCQUF3QjtZQUM5RCxJQUFJSCxRQUFRTyxJQUFJLENBQUNsQixhQUFhO2dCQUMxQmdCLGlCQUFpQkcsSUFBSSxDQUFDTjtnQkFDdEIsSUFBSUQsYUFBYSxRQUFRO29CQUNyQkssY0FBYztnQkFDbEI7WUFDSjtRQUNKO0lBQ0o7SUFFQSxxREFBcUQ7SUFDckQsSUFBSUEsZ0JBQWdCLFFBQVE7UUFDeEIsT0FBTztZQUNIRyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsVUFBVU47WUFDVkosVUFBVTtRQUNkO0lBQ0o7SUFFQSw2REFBNkQ7SUFDN0QsSUFBSUgsdUJBQXVCO1FBQ3ZCLEtBQUssTUFBTSxFQUFFRSxPQUFPLEVBQUVFLElBQUksRUFBRSxJQUFJRSxtQkFBb0I7WUFDaEQsSUFBSUosUUFBUU8sSUFBSSxDQUFDbEIsYUFBYTtnQkFDMUJnQixpQkFBaUJHLElBQUksQ0FBQ047Z0JBQ3RCLElBQUlJLGdCQUFnQixPQUFPO29CQUN2QkEsY0FBYztnQkFDbEI7WUFDSjtRQUNKO0lBQ0o7SUFFQSxJQUFJRCxpQkFBaUJSLE1BQU0sR0FBRyxHQUFHO1FBQzdCLE9BQU87WUFDSFksTUFBTTtZQUNOQyxRQUFRO1lBQ1JDLFVBQVVOO1lBQ1ZKLFVBQVVLO1FBQ2Q7SUFDSjtJQUVBLE9BQU87UUFBRUcsTUFBTTtJQUFLO0FBQ3hCO0FBRUE7O0NBRUMsR0FDTSxTQUFTRyxtQkFBbUJDLFVBQWtCO0lBQ2pELGtEQUFrRDtJQUNsRCxJQUFJLENBQUMsbUJBQW1CTixJQUFJLENBQUNNLGFBQWE7UUFDdEMsTUFBTSxJQUFJQyxNQUFNLENBQUMsb0JBQW9CLEVBQUVELFdBQVcsQ0FBQztJQUN2RDtJQUNBLE9BQU9BO0FBQ1g7QUFFQTs7Q0FFQyxHQUNNLFNBQVNFLGFBQWFDLEtBQWE7SUFDdEMsT0FBT0EsTUFBTTFCLE9BQU8sQ0FBQyxNQUFNO0FBQy9CO0FBRUE7O0NBRUMsR0FDTSxTQUFTMkIsZ0JBQWdCN0IsS0FBYTtJQUN6QyxNQUFNQyxhQUFhRCxNQUFNRyxJQUFJLEdBQUdDLFdBQVc7SUFFM0Msd0NBQXdDO0lBQ3hDLE1BQU0wQixtQkFBbUI7UUFBQztRQUFVO1FBQVc7UUFBUTtRQUFZO0tBQU87SUFFMUUsT0FBT0EsaUJBQWlCQyxJQUFJLENBQUMsQ0FBQ0MsVUFBWS9CLFdBQVdnQyxVQUFVLENBQUNEO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9wYWNrYWdlcy9zZWN1cml0eS9zcmMvc3FsLWd1YXJkL3NxbC1ndWFyZC50cz8zNDFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU1FMIGluamVjdGlvbiBkZXRlY3Rpb24gYW5kIHF1ZXJ5IHZhbGlkYXRpb25cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICAgIHNhZmU6IGJvb2xlYW47XG4gICAgcmVhc29uPzogc3RyaW5nO1xuICAgIHBhdHRlcm5zPzogc3RyaW5nW107XG4gICAgc2V2ZXJpdHk/OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgU1FMIHF1ZXJ5IGZvciBwb3RlbnRpYWxseSBkYW5nZXJvdXMgcGF0dGVybnNcbiAqIFRoaXMgaXMgYSBkZWZlbnNlLWluLWRlcHRoIG1lYXN1cmUsIG5vdCBhIHJlcGxhY2VtZW50IGZvciBwYXJhbWV0ZXJpemVkIHF1ZXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUXVlcnkocXVlcnk6IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIC8vIE5vcm1hbGl6ZSBxdWVyeVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBxdWVyeVxuICAgICAgICAucmVwbGFjZSgvLS0uKiQvZ20sICcnKSAvLyBSZW1vdmUgc2luZ2xlLWxpbmUgY29tbWVudHNcbiAgICAgICAgLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZywgJycpIC8vIFJlbW92ZSBtdWx0aS1saW5lIGNvbW1lbnRzXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENoZWNrIGZvciBtdWx0aXBsZSBzdGF0ZW1lbnRzIChTUUwgaW5qZWN0aW9uIGF0dGVtcHRzKVxuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBub3JtYWxpemVkLnNwbGl0KCc7JykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gc3RhdGVtZW50cy5sZW5ndGggPiAxO1xuXG4gICAgLy8gSGlnaGx5IGRhbmdlcm91cyBwYXR0ZXJucyAoYmxvY2tpbmcgbGV2ZWwpXG4gICAgY29uc3QgYmxvY2tlZFBhdHRlcm5zID0gW1xuICAgICAgICB7IHBhdHRlcm46IC94cF9jbWRzaGVsbC9pLCBzZXZlcml0eTogJ2hpZ2gnLCBkZXNjOiAnQ29tbWFuZCBleGVjdXRpb24gYXR0ZW1wdCcgfSxcbiAgICAgICAgeyBwYXR0ZXJuOiAvZXhlY1xccypcXCgvaSwgc2V2ZXJpdHk6ICdoaWdoJywgZGVzYzogJ0R5bmFtaWMgU1FMIGV4ZWN1dGlvbicgfSxcbiAgICAgICAgeyBwYXR0ZXJuOiAvaW50b1xccytvdXRmaWxlL2ksIHNldmVyaXR5OiAnaGlnaCcsIGRlc2M6ICdGaWxlIHdyaXRlIGF0dGVtcHQnIH0sXG4gICAgICAgIHsgcGF0dGVybjogL2xvYWRfZmlsZS9pLCBzZXZlcml0eTogJ2hpZ2gnLCBkZXNjOiAnRmlsZSByZWFkIGF0dGVtcHQnIH0sXG4gICAgXTtcblxuICAgIC8vIE11bHRpLXN0YXRlbWVudCBhdHRhY2tzIChvbmx5IGJsb2NrIGlmIG11bHRpcGxlIHN0YXRlbWVudHMgZGV0ZWN0ZWQpXG4gICAgY29uc3QgbXVsdGlTdGF0ZW1lbnRQYXR0ZXJucyA9IFtcbiAgICAgICAgeyBwYXR0ZXJuOiAvO1xccypkcm9wXFxzKyh0YWJsZXxkYXRhYmFzZXxzY2hlbWEpL2ksIHNldmVyaXR5OiAnaGlnaCcsIGRlc2M6ICdEUk9QIGluIG11bHRpLXN0YXRlbWVudCcgfSxcbiAgICAgICAgeyBwYXR0ZXJuOiAvO1xccyp0cnVuY2F0ZVxccysvaSwgc2V2ZXJpdHk6ICdoaWdoJywgZGVzYzogJ1RSVU5DQVRFIGluIG11bHRpLXN0YXRlbWVudCcgfSxcbiAgICAgICAgeyBwYXR0ZXJuOiAvO1xccypkZWxldGVcXHMrZnJvbS9pLCBzZXZlcml0eTogJ2hpZ2gnLCBkZXNjOiAnREVMRVRFIGluIG11bHRpLXN0YXRlbWVudCcgfSxcbiAgICAgICAgeyBwYXR0ZXJuOiAvO1xccypzaHV0ZG93bi9pLCBzZXZlcml0eTogJ2hpZ2gnLCBkZXNjOiAnU2h1dGRvd24gY29tbWFuZCcgfSxcbiAgICBdO1xuXG4gICAgLy8gU3VzcGljaW91cyBwYXR0ZXJucyAod2FybmluZyBsZXZlbCkgLSBvbmx5IGZvciBtdWx0aS1zdGF0ZW1lbnQgcXVlcmllc1xuICAgIGNvbnN0IHN1c3BpY2lvdXNQYXR0ZXJucyA9IFtcbiAgICAgICAgeyBwYXR0ZXJuOiAvdW5pb25cXHMrc2VsZWN0L2ksIHNldmVyaXR5OiAnbWVkaXVtJywgZGVzYzogJ1VOSU9OLWJhc2VkIGluamVjdGlvbicgfSxcbiAgICBdO1xuXG4gICAgY29uc3QgZGV0ZWN0ZWRQYXR0ZXJuczogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgbWF4U2V2ZXJpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgPSAnbG93JztcblxuICAgIC8vIENoZWNrIGJsb2NrZWQgcGF0dGVybnNcbiAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgc2V2ZXJpdHksIGRlc2MgfSBvZiBibG9ja2VkUGF0dGVybnMpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdChub3JtYWxpemVkKSkge1xuICAgICAgICAgICAgZGV0ZWN0ZWRQYXR0ZXJucy5wdXNoKGRlc2MpO1xuICAgICAgICAgICAgaWYgKHNldmVyaXR5ID09PSAnaGlnaCcpIHtcbiAgICAgICAgICAgICAgICBtYXhTZXZlcml0eSA9ICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIG11bHRpLXN0YXRlbWVudCBwYXR0ZXJucyBvbmx5IGlmIG11bHRpcGxlIHN0YXRlbWVudHMgZGV0ZWN0ZWRcbiAgICBpZiAoaGFzTXVsdGlwbGVTdGF0ZW1lbnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCBzZXZlcml0eSwgZGVzYyB9IG9mIG11bHRpU3RhdGVtZW50UGF0dGVybnMpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3Qobm9ybWFsaXplZCkpIHtcbiAgICAgICAgICAgICAgICBkZXRlY3RlZFBhdHRlcm5zLnB1c2goZGVzYyk7XG4gICAgICAgICAgICAgICAgaWYgKHNldmVyaXR5ID09PSAnaGlnaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4U2V2ZXJpdHkgPSAnaGlnaCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgaGlnaCBzZXZlcml0eSBwYXR0ZXJucyBmb3VuZCwgYmxvY2sgaW1tZWRpYXRlbHlcbiAgICBpZiAobWF4U2V2ZXJpdHkgPT09ICdoaWdoJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2FmZTogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246ICdEYW5nZXJvdXMgU1FMIHBhdHRlcm5zIGRldGVjdGVkJyxcbiAgICAgICAgICAgIHBhdHRlcm5zOiBkZXRlY3RlZFBhdHRlcm5zLFxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzdXNwaWNpb3VzIHBhdHRlcm5zIG9ubHkgZm9yIG11bHRpLXN0YXRlbWVudCBxdWVyaWVzXG4gICAgaWYgKGhhc011bHRpcGxlU3RhdGVtZW50cykge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgZGVzYyB9IG9mIHN1c3BpY2lvdXNQYXR0ZXJucykge1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChub3JtYWxpemVkKSkge1xuICAgICAgICAgICAgICAgIGRldGVjdGVkUGF0dGVybnMucHVzaChkZXNjKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4U2V2ZXJpdHkgPT09ICdsb3cnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFNldmVyaXR5ID0gJ21lZGl1bSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRldGVjdGVkUGF0dGVybnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2FmZTogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246ICdTdXNwaWNpb3VzIFNRTCBwYXR0ZXJucyBkZXRlY3RlZCcsXG4gICAgICAgICAgICBwYXR0ZXJuczogZGV0ZWN0ZWRQYXR0ZXJucyxcbiAgICAgICAgICAgIHNldmVyaXR5OiBtYXhTZXZlcml0eSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzYWZlOiB0cnVlIH07XG59XG5cbi8qKlxuICogU2FuaXRpemUgdGFibGUvY29sdW1uIG5hbWVzIChwcmV2ZW50IFNRTCBpbmplY3Rpb24gaW4gaWRlbnRpZmllcnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBPbmx5IGFsbG93IGFscGhhbnVtZXJpYywgdW5kZXJzY29yZSwgYW5kIGh5cGhlblxuICAgIGlmICghL15bYS16QS1aMC05Xy1dKyQvLnRlc3QoaWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXI6ICR7aWRlbnRpZmllcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG59XG5cbi8qKlxuICogRXNjYXBlIHN0cmluZyB2YWx1ZXMgZm9yIFNRTCAodXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllcyBpbnN0ZWFkIHdoZW4gcG9zc2libGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVTdHJpbmcodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBxdWVyeSBpcyByZWFkLW9ubHkgKHNhZmUgZm9yIHJlYWQtb25seSBjb25uZWN0aW9ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhZE9ubHlRdWVyeShxdWVyeTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQWxsb3cgU0VMRUNULCBFWFBMQUlOLCBTSE9XLCBERVNDUklCRVxuICAgIGNvbnN0IHJlYWRPbmx5S2V5d29yZHMgPSBbJ3NlbGVjdCcsICdleHBsYWluJywgJ3Nob3cnLCAnZGVzY3JpYmUnLCAnd2l0aCddO1xuXG4gICAgcmV0dXJuIHJlYWRPbmx5S2V5d29yZHMuc29tZSgoa2V5d29yZCkgPT4gbm9ybWFsaXplZC5zdGFydHNXaXRoKGtleXdvcmQpKTtcbn1cbiJdLCJuYW1lcyI6WyJ2YWxpZGF0ZVF1ZXJ5IiwicXVlcnkiLCJub3JtYWxpemVkIiwicmVwbGFjZSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInN0YXRlbWVudHMiLCJzcGxpdCIsImZpbHRlciIsInMiLCJsZW5ndGgiLCJoYXNNdWx0aXBsZVN0YXRlbWVudHMiLCJibG9ja2VkUGF0dGVybnMiLCJwYXR0ZXJuIiwic2V2ZXJpdHkiLCJkZXNjIiwibXVsdGlTdGF0ZW1lbnRQYXR0ZXJucyIsInN1c3BpY2lvdXNQYXR0ZXJucyIsImRldGVjdGVkUGF0dGVybnMiLCJtYXhTZXZlcml0eSIsInRlc3QiLCJwdXNoIiwic2FmZSIsInJlYXNvbiIsInBhdHRlcm5zIiwic2FuaXRpemVJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsIkVycm9yIiwiZXNjYXBlU3RyaW5nIiwidmFsdWUiLCJpc1JlYWRPbmx5UXVlcnkiLCJyZWFkT25seUtleXdvcmRzIiwic29tZSIsImtleXdvcmQiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../packages/security/src/sql-guard/sql-guard.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/utils/src/index.ts":
/*!*****************************************!*\
  !*** ../../packages/utils/src/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* reexport safe */ _logger__WEBPACK_IMPORTED_MODULE_0__.LogLevel),\n/* harmony export */   Logger: () => (/* reexport safe */ _logger__WEBPACK_IMPORTED_MODULE_0__.Logger)\n/* harmony export */ });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"(rsc)/../../packages/utils/src/logger/index.ts\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL2luZGV4LnRzPzI3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9sb2dnZXInO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/utils/src/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/utils/src/logger/index.ts":
/*!************************************************!*\
  !*** ../../packages/utils/src/logger/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/**\n * Simple logger utility\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\nclass Logger {\n    constructor(context, level = 1){\n        this.context = context;\n        this.level = level;\n    }\n    debug(message, ...args) {\n        if (this.level <= 0) {\n            console.debug(`[${new Date().toISOString()}] [DEBUG] [${this.context}]`, message, ...args);\n        }\n    }\n    info(message, ...args) {\n        if (this.level <= 1) {\n            console.log(`[${new Date().toISOString()}] [INFO] [${this.context}]`, message, ...args);\n        }\n    }\n    warn(message, ...args) {\n        if (this.level <= 2) {\n            console.warn(`[${new Date().toISOString()}] [WARN] [${this.context}]`, message, ...args);\n        }\n    }\n    error(message, ...args) {\n        if (this.level <= 3) {\n            console.error(`[${new Date().toISOString()}] [ERROR] [${this.context}]`, message, ...args);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL2xvZ2dlci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDO1VBRVdBOzs7OztHQUFBQSxhQUFBQTtBQU9MLE1BQU1DO0lBSVRDLFlBQVlDLE9BQWUsRUFBRUMsU0FBK0IsQ0FBRTtRQUMxRCxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFFQUMsTUFBTUMsT0FBZSxFQUFFLEdBQUdDLElBQVcsRUFBUTtRQUN6QyxJQUFJLElBQUksQ0FBQ0gsS0FBSyxPQUFvQjtZQUM5QkksUUFBUUgsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUlJLE9BQU9DLFdBQVcsR0FBRyxXQUFXLEVBQUUsSUFBSSxDQUFDUCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVHLFlBQVlDO1FBQ3pGO0lBQ0o7SUFFQUksS0FBS0wsT0FBZSxFQUFFLEdBQUdDLElBQVcsRUFBUTtRQUN4QyxJQUFJLElBQUksQ0FBQ0gsS0FBSyxPQUFtQjtZQUM3QkksUUFBUUksR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUlILE9BQU9DLFdBQVcsR0FBRyxVQUFVLEVBQUUsSUFBSSxDQUFDUCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVHLFlBQVlDO1FBQ3RGO0lBQ0o7SUFFQU0sS0FBS1AsT0FBZSxFQUFFLEdBQUdDLElBQVcsRUFBUTtRQUN4QyxJQUFJLElBQUksQ0FBQ0gsS0FBSyxPQUFtQjtZQUM3QkksUUFBUUssSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUlKLE9BQU9DLFdBQVcsR0FBRyxVQUFVLEVBQUUsSUFBSSxDQUFDUCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVHLFlBQVlDO1FBQ3ZGO0lBQ0o7SUFFQU8sTUFBTVIsT0FBZSxFQUFFLEdBQUdDLElBQVcsRUFBUTtRQUN6QyxJQUFJLElBQUksQ0FBQ0gsS0FBSyxPQUFvQjtZQUM5QkksUUFBUU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUlMLE9BQU9DLFdBQVcsR0FBRyxXQUFXLEVBQUUsSUFBSSxDQUFDUCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVHLFlBQVlDO1FBQ3pGO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vLi4vcGFja2FnZXMvdXRpbHMvc3JjL2xvZ2dlci9pbmRleC50cz8wMTFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltcGxlIGxvZ2dlciB1dGlsaXR5XG4gKi9cblxuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xuICAgIERFQlVHID0gMCxcbiAgICBJTkZPID0gMSxcbiAgICBXQVJOID0gMixcbiAgICBFUlJPUiA9IDMsXG59XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIHByaXZhdGUgY29udGV4dDogc3RyaW5nO1xuICAgIHByaXZhdGUgbGV2ZWw6IExvZ0xldmVsO1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dDogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG5cbiAgICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSBbREVCVUddIFske3RoaXMuY29udGV4dH1dYCwgbWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgPD0gTG9nTGV2ZWwuSU5GTykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFske25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dIFtJTkZPXSBbJHt0aGlzLmNvbnRleHR9XWAsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2FybihtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0gW1dBUk5dIFske3RoaXMuY29udGV4dH1dYCwgbWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSBbRVJST1JdIFske3RoaXMuY29udGV4dH1dYCwgbWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiTG9nTGV2ZWwiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJsZXZlbCIsImRlYnVnIiwibWVzc2FnZSIsImFyZ3MiLCJjb25zb2xlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiaW5mbyIsImxvZyIsIndhcm4iLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/utils/src/logger/index.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/BisectService.js":
/*!*****************************************************************!*\
  !*** ../../packages/version-control/dist/core/BisectService.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BisectService = void 0;\n/**\n * Bisect Service - Binary search to find when a bug was introduced\n */ class BisectService {\n    constructor(storage){\n        this.currentSession = null;\n        this.storage = storage;\n    }\n    /**\n     * Start a bisect session\n     */ async start(goodCommitId, badCommitId) {\n        try {\n            if (this.currentSession) {\n                return {\n                    success: false,\n                    error: \"Bisect session already active\"\n                };\n            }\n            // Get all commits between good and bad\n            const commits = await this.getCommitRange(goodCommitId, badCommitId);\n            if (commits.length === 0) {\n                return {\n                    success: false,\n                    error: \"No commits between good and bad\"\n                };\n            }\n            // Start in the middle\n            const middleIndex = Math.floor(commits.length / 2);\n            this.currentSession = {\n                id: this.generateBisectId(),\n                goodCommits: [\n                    goodCommitId\n                ],\n                badCommits: [\n                    badCommitId\n                ],\n                currentCommit: commits[middleIndex].id,\n                remainingCommits: commits.map((c)=>c.id),\n                status: \"ACTIVE\"\n            };\n            return {\n                success: true,\n                data: this.currentSession\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Bisect start failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Mark current commit as good\n     */ async markGood() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.goodCommits.push(this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Mark good failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Mark current commit as bad\n     */ async markBad() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.badCommits.push(this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Mark bad failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Skip current commit\n     */ async skip() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            // Remove current commit from consideration\n            this.currentSession.remainingCommits = this.currentSession.remainingCommits.filter((id)=>id !== this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Skip failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Reset/abort bisect session\n     */ async reset() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.status = \"ABORTED\";\n            this.currentSession = null;\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Reset failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Get current bisect session\n     */ getSession() {\n        return this.currentSession;\n    }\n    async nextStep() {\n        if (!this.currentSession) {\n            return {\n                success: false,\n                error: \"No active session\"\n            };\n        }\n        // Filter remaining commits based on good/bad commits\n        const remaining = await this.filterCommits(this.currentSession.remainingCommits, this.currentSession.goodCommits, this.currentSession.badCommits);\n        if (remaining.length === 0) {\n            // Found the first bad commit\n            this.currentSession.status = \"FOUND\";\n            this.currentSession.firstBadCommit = this.currentSession.badCommits[this.currentSession.badCommits.length - 1];\n            const session = {\n                ...this.currentSession\n            };\n            this.currentSession = null;\n            return {\n                success: true,\n                data: session\n            };\n        }\n        if (remaining.length === 1) {\n            // Only one commit left - this is the culprit\n            this.currentSession.status = \"FOUND\";\n            this.currentSession.firstBadCommit = remaining[0];\n            const session = {\n                ...this.currentSession\n            };\n            this.currentSession = null;\n            return {\n                success: true,\n                data: session\n            };\n        }\n        // Continue bisecting - choose middle commit\n        const middleIndex = Math.floor(remaining.length / 2);\n        this.currentSession.currentCommit = remaining[middleIndex];\n        this.currentSession.remainingCommits = remaining;\n        return {\n            success: true,\n            data: this.currentSession\n        };\n    }\n    async getCommitRange(goodCommitId, badCommitId) {\n        const commits = [];\n        let currentId = badCommitId;\n        while(currentId && currentId !== goodCommitId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.push(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async filterCommits(allCommits, goodCommits, badCommits) {\n        // Simplified filtering - in production would use commit graph analysis\n        return allCommits.filter((id)=>!goodCommits.includes(id) && !badCommits.includes(id));\n    }\n    generateBisectId() {\n        return `bisect-${Date.now()}`;\n    }\n    /**\n     * Estimate remaining steps\n     */ getRemainingSteps() {\n        if (!this.currentSession) return 0;\n        return Math.ceil(Math.log2(this.currentSession.remainingCommits.length));\n    }\n}\nexports.BisectService = BisectService;\nexports[\"default\"] = BisectService; //# sourceMappingURL=BisectService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9CaXNlY3RTZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBUUE7O0lBR0EsTUFBYUE7SUFJVEMsWUFBWUMsT0FBOEI7UUFGbEMsS0FBQUMsY0FBYyxHQUF5QjtRQUczQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNRSxNQUFNQyxZQUFvQixFQUFFQyxXQUFtQjtRQUNqRCxJQUFJO1lBQ0EsSUFBSSxJQUFJLENBQUNILGNBQWMsRUFBRTtnQkFDckIsT0FBTztvQkFBRUksU0FBUztvQkFBT0MsT0FBTztnQkFBK0I7WUFDbkU7WUFFQSx1Q0FBdUM7WUFDdkMsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDTCxjQUFjQztZQUV4RCxJQUFJRyxRQUFRRSxNQUFNLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFBRUosU0FBUztvQkFBT0MsT0FBTztnQkFBaUM7WUFDckU7WUFFQSxzQkFBc0I7WUFDdEIsTUFBTUksY0FBY0MsS0FBS0MsS0FBSyxDQUFDTCxRQUFRRSxNQUFNLEdBQUc7WUFFaEQsSUFBSSxDQUFDUixjQUFjLEdBQUc7Z0JBQ2xCWSxJQUFJLElBQUksQ0FBQ0MsZ0JBQWdCO2dCQUN6QkMsYUFBYTtvQkFBQ1o7aUJBQWE7Z0JBQzNCYSxZQUFZO29CQUFDWjtpQkFBWTtnQkFDekJhLGVBQWVWLE9BQU8sQ0FBQ0csWUFBWSxDQUFDRyxFQUFFO2dCQUN0Q0ssa0JBQWtCWCxRQUFRWSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRVAsRUFBRTtnQkFDekNRLFFBQVE7O1lBR1osT0FBTztnQkFBRWhCLFNBQVM7Z0JBQU1pQixNQUFNLElBQUksQ0FBQ3JCLGNBQWM7WUFBQTtRQUNyRCxFQUFFLE9BQU9LLE9BQU87WUFDWixPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPLHdCQUF3QkEsTUFBSyxDQUFFO1lBQUE7UUFDbkU7SUFD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LFNBQVMsQ0FBQyxFQUFFLElBQUk7UUFDdkM7UUFFQSxPQUFPaEMsUUFBUWlDLE9BQU87SUFDMUI7SUFFUSxNQUFNUCxjQUNWUSxVQUFvQixFQUNwQjFCLFdBQXFCLEVBQ3JCQyxVQUFvQjtRQUVwQix1RUFBdUU7UUFDdkUsT0FBT3lCLFdBQVdiLE1BQU0sQ0FDcEIsQ0FBQ2YsS0FBTyxDQUFDRSxZQUFZMkIsUUFBUSxDQUFDN0IsT0FBTyxDQUFDRyxXQUFXMEIsUUFBUSxDQUFDN0I7SUFFbEU7SUFFUUMsbUJBQWdCO1FBQ3BCLE9BQU8sVUFBVTZCLEtBQUtDLEdBQUcsR0FBRSxDQUFFO0lBQ2pDO0lBRUE7O1FBR0FDLG9CQUFpQjtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUM1QyxjQUFjLEVBQUUsT0FBTztRQUNqQyxPQUFPVSxLQUFLbUMsSUFBSSxDQUFDbkMsS0FBS29DLElBQUksQ0FBQyxJQUFJLENBQUM5QyxjQUFjLENBQUNpQixnQkFBZ0IsQ0FBQ1QsTUFBTTtJQUMxRTs7QUF2TUp1QyxxQkFBQSxHQUFBbEQ7QUEwTUFrRCxrQkFBQSxHQUFlbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9jb3JlL0Jpc2VjdFNlcnZpY2UudHM/NzFmNiJdLCJuYW1lcyI6WyJCaXNlY3RTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJzdG9yYWdlIiwiY3VycmVudFNlc3Npb24iLCJzdGFydCIsImdvb2RDb21taXRJZCIsImJhZENvbW1pdElkIiwic3VjY2VzcyIsImVycm9yIiwiY29tbWl0cyIsImdldENvbW1pdFJhbmdlIiwibGVuZ3RoIiwibWlkZGxlSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJpZCIsImdlbmVyYXRlQmlzZWN0SWQiLCJnb29kQ29tbWl0cyIsImJhZENvbW1pdHMiLCJjdXJyZW50Q29tbWl0IiwicmVtYWluaW5nQ29tbWl0cyIsIm1hcCIsImMiLCJzdGF0dXMiLCJkYXRhIiwibWFya0dvb2QiLCJwdXNoIiwibmV4dFN0ZXAiLCJtYXJrQmFkIiwic2tpcCIsImZpbHRlciIsInJlc2V0IiwidW5kZWZpbmVkIiwiZ2V0U2Vzc2lvbiIsInJlbWFpbmluZyIsImZpbHRlckNvbW1pdHMiLCJmaXJzdEJhZENvbW1pdCIsInNlc3Npb24iLCJjdXJyZW50SWQiLCJjb21taXQiLCJnZXRDb21taXQiLCJwYXJlbnRJZHMiLCJyZXZlcnNlIiwiYWxsQ29tbWl0cyIsImluY2x1ZGVzIiwiRGF0ZSIsIm5vdyIsImdldFJlbWFpbmluZ1N0ZXBzIiwiY2VpbCIsImxvZzIiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/BisectService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/BlameService.js":
/*!****************************************************************!*\
  !*** ../../packages/version-control/dist/core/BlameService.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BlameService = void 0;\n/**\n * Blame Service - Track who changed each part of the database\n */ class BlameService {\n    constructor(storage){\n        this.storage = storage;\n    }\n    /**\n     * Get blame information for a table\n     */ async blameTable(tableName, commitId, options) {\n        try {\n            const commits = await this.getCommitsAffectingTable(tableName, commitId);\n            const lines = await this.buildBlameLines(tableName, commits);\n            const blameInfo = {\n                table: tableName,\n                lines\n            };\n            return {\n                success: true,\n                data: blameInfo\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Blame failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Get blame information for a specific column\n     */ async blameColumn(tableName, columnName, commitId) {\n        try {\n            const commits = await this.getCommitsAffectingColumn(tableName, columnName, commitId);\n            const lines = await this.buildBlameLines(`${tableName}.${columnName}`, commits);\n            const blameInfo = {\n                table: tableName,\n                column: columnName,\n                lines\n            };\n            return {\n                success: true,\n                data: blameInfo\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Blame failed: ${error}`\n            };\n        }\n    }\n    async getCommitsAffectingTable(tableName, commitId) {\n        const commits = [];\n        let currentId = commitId;\n        while(currentId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Check if this commit affects the table\n            const affectsTable = commit.changes.some((change)=>change.type === \"SCHEMA\" && change.target === tableName || change.type === \"DATA\" && change.tableName === tableName);\n            if (affectsTable) {\n                commits.push(commit);\n            }\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async getCommitsAffectingColumn(tableName, columnName, commitId) {\n        const commits = [];\n        let currentId = commitId;\n        while(currentId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Check if this commit affects the column\n            const affectsColumn = commit.changes.some((change)=>{\n                if (change.type === \"SCHEMA\" && change.target === tableName) {\n                    const schemaChange = change;\n                    return schemaChange.columnChanges?.some((cc)=>cc.columnName === columnName);\n                }\n                return false;\n            });\n            if (affectsColumn) {\n                commits.push(commit);\n            }\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async buildBlameLines(target, commits) {\n        const lines = [];\n        for(let i = 0; i < commits.length; i++){\n            const commit = commits[i];\n            const age = Math.floor((Date.now() - commit.timestamp.getTime()) / (1000 * 60 * 60 * 24));\n            const line = {\n                lineNumber: i + 1,\n                content: commit.changes[0]?.description || \"\",\n                commit,\n                author: commit.author,\n                age\n            };\n            lines.push(line);\n        }\n        return lines;\n    }\n    /**\n     * Get summary of who contributed to a table\n     */ async getContributors(tableName, commitId) {\n        try {\n            const commits = await this.getCommitsAffectingTable(tableName, commitId);\n            const contributorMap = new Map();\n            for (const commit of commits){\n                const authorKey = `${commit.author.name} <${commit.author.email}>`;\n                contributorMap.set(authorKey, (contributorMap.get(authorKey) || 0) + 1);\n            }\n            return {\n                success: true,\n                data: contributorMap\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get contributors: ${error}`\n            };\n        }\n    }\n}\nexports.BlameService = BlameService;\nexports[\"default\"] = BlameService; //# sourceMappingURL=BlameService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9CbGFtZVNlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFVQTs7SUFHQSxNQUFhQTtJQUdUQyxZQUFZQyxPQUE4QjtRQUN0QyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNQyxXQUNGQyxTQUFpQixFQUNqQkMsUUFBZ0IsRUFDaEJDLE9BQXNCO1FBRXRCLElBQUk7WUFDQSxNQUFNQyxVQUFVLE1BQU0sSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQ0osV0FBV0M7WUFFL0QsTUFBTUksUUFBcUIsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ04sV0FBV0c7WUFFakUsTUFBTUksWUFBdUI7Z0JBQ3pCQyxPQUFPUjtnQkFDUEs7O1lBR0osT0FBTztnQkFBRUksU0FBUztnQkFBTUMsTUFBTUg7WUFBUztRQUMzQyxFQUFFLE9BQU9JLE9BQU87WUFDWixPQUFPO2dCQUFFRixTQUFTO2dCQUFPRSxPQUFPLGlCQUFpQkEsTUFBSyxDQUFFO1lBQUE7UUFDNUQ7SUFDSjtJQUVBOztRQUdBLE1BQU1DLFlBQ0ZaLFNBQWlCLEVBQ2pCYSxVQUFrQixFQUNsQlosUUFBZ0I7UUFFaEIsSUFBSTtZQUNBLE1BQU1FLFVBQVUsTUFBTSxJQUFJLENBQUNXLHlCQUF5QixDQUFDZCxXQUFXYSxZQUFZWjtZQUU1RSxNQUFNSSxRQUFxQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDLEdBQUdOLFVBQVMsR0FBSWEsV0FBVSxDQUFFLEVBQUVWO1lBRXBGLE1BQU1JLFlBQXVCO2dCQUN6QkMsT0FBT1I7Z0JBQ1BlLFFBQVFGO2dCQUNSUjs7WUFHSixPQUFPO2dCQUFFSSxTQUFTO2dCQUFNQyxNQUFNSDtZQUFTO1FBQzNDLEVBQUUsT0FBT0ksT0FBTztZQUNaLE9BQU87Z0JBQUVGLFNBQVM7Z0JBQU9FLE9BQU8saUJBQWlCQSxNQUFLLENBQUU7WUFBQTtRQUM1RDtJQUNKO0lBRVEsTUFB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O1lBQ1osT0FBTztnQkFBRUYsU0FBUztnQkFBT0UsT0FBTywrQkFBK0JBLE1BQUssQ0FBRTtZQUFBO1FBQzFFO0lBQ0o7O0FBaEtKMkMsb0JBQUEsR0FBQTFEO0FBbUtBMEQsa0JBQUEsR0FBZTFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9CbGFtZVNlcnZpY2UudHM/NzA3ZiJdLCJuYW1lcyI6WyJCbGFtZVNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInN0b3JhZ2UiLCJibGFtZVRhYmxlIiwidGFibGVOYW1lIiwiY29tbWl0SWQiLCJvcHRpb25zIiwiY29tbWl0cyIsImdldENvbW1pdHNBZmZlY3RpbmdUYWJsZSIsImxpbmVzIiwiYnVpbGRCbGFtZUxpbmVzIiwiYmxhbWVJbmZvIiwidGFibGUiLCJzdWNjZXNzIiwiZGF0YSIsImVycm9yIiwiYmxhbWVDb2x1bW4iLCJjb2x1bW5OYW1lIiwiZ2V0Q29tbWl0c0FmZmVjdGluZ0NvbHVtbiIsImNvbHVtbiIsImN1cnJlbnRJZCIsImNvbW1pdCIsImdldENvbW1pdCIsImFmZmVjdHNUYWJsZSIsImNoYW5nZXMiLCJzb21lIiwiY2hhbmdlIiwidHlwZSIsInRhcmdldCIsInB1c2giLCJwYXJlbnRJZHMiLCJyZXZlcnNlIiwiYWZmZWN0c0NvbHVtbiIsInNjaGVtYUNoYW5nZSIsImNvbHVtbkNoYW5nZXMiLCJjYyIsImkiLCJsZW5ndGgiLCJhZ2UiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwiZ2V0VGltZSIsImxpbmUiLCJsaW5lTnVtYmVyIiwiY29udGVudCIsImRlc2NyaXB0aW9uIiwiYXV0aG9yIiwiZ2V0Q29udHJpYnV0b3JzIiwiY29udHJpYnV0b3JNYXAiLCJNYXAiLCJhdXRob3JLZXkiLCJuYW1lIiwiZW1haWwiLCJzZXQiLCJnZXQiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/BlameService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/PatchService.js":
/*!****************************************************************!*\
  !*** ../../packages/version-control/dist/core/PatchService.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PatchService = void 0;\n/**\n * Patch Service - Export and import changesets\n */ class PatchService {\n    constructor(storage){\n        this.storage = storage;\n    }\n    /**\n     * Generate a patch from a commit\n     */ async generatePatch(commitId) {\n        try {\n            const commit = await this.storage.getCommit(commitId);\n            if (!commit) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const patch = await this.createPatchFromCommit(commit);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Generate patch failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Generate a patch from a range of commits\n     */ async generatePatchRange(fromCommit, toCommit) {\n        try {\n            const commits = await this.getCommitRange(fromCommit, toCommit);\n            if (commits.length === 0) {\n                return {\n                    success: false,\n                    error: \"No commits in range\"\n                };\n            }\n            const patch = await this.createPatchFromCommits(commits);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Generate patch range failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Apply a patch\n     */ async applyPatch(patch, options) {\n        try {\n            if (options?.check) {\n                // Dry run - just check if patch can be applied\n                const canApply = await this.checkPatch(patch);\n                return {\n                    success: true,\n                    data: {\n                        success: canApply,\n                        appliedPatches: canApply ? patch.commits.length : 0,\n                        failedPatches: canApply ? 0 : patch.commits.length,\n                        conflicts: []\n                    }\n                };\n            }\n            const result = await this.applyPatchInternal(patch, options);\n            return {\n                success: true,\n                data: result\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Apply patch failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Export patch to formatted string\n     */ exportPatch(patch) {\n        const lines = [];\n        // Header\n        lines.push(`From ${patch.metadata?.baseCommitId || \"unknown\"} ${new Date().toISOString()}`);\n        lines.push(`From: ${patch.metadata?.createdBy || \"unknown\"}`);\n        lines.push(`Date: ${patch.metadata?.createdAt.toISOString() || new Date().toISOString()}`);\n        lines.push(`Subject: ${patch.metadata?.description || \"No description\"}`);\n        lines.push(\"\");\n        // Commits\n        for (const commit of patch.commits){\n            lines.push(`commit ${commit.id}`);\n            lines.push(`Author: ${commit.author.name} <${commit.author.email}>`);\n            lines.push(`Date: ${commit.timestamp.toISOString()}`);\n            lines.push(\"\");\n            lines.push(`    ${commit.message}`);\n            lines.push(\"\");\n            // Changes\n            for (const change of commit.changes){\n                lines.push(`    ${change.type}: ${change.description}`);\n            }\n            lines.push(\"\");\n        }\n        // Diffs\n        for (const diff of patch.diffs){\n            lines.push(`diff --git a/${diff.fromCommitId} b/${diff.toCommitId}`);\n            lines.push(`--- a/${diff.fromCommitId}`);\n            lines.push(`+++ b/${diff.toCommitId}`);\n            for (const change of diff.schemaChanges){\n                const prefix = change.operation === \"CREATE\" ? \"+\" : change.operation === \"DROP\" ? \"-\" : \" \";\n                lines.push(`${prefix} ${change.description}`);\n            }\n            for (const change of diff.dataChanges){\n                const prefix = change.operation === \"INSERT\" ? \"+\" : change.operation === \"DELETE\" ? \"-\" : \" \";\n                lines.push(`${prefix} ${change.description}`);\n            }\n            lines.push(\"\");\n        }\n        return lines.join(\"\\n\");\n    }\n    /**\n     * Import patch from formatted string\n     */ async importPatch(patchContent) {\n        try {\n            const patch = await this.parsePatch(patchContent);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Import patch failed: ${error}`\n            };\n        }\n    }\n    async createPatchFromCommit(commit) {\n        const patch = {\n            id: `patch-${commit.id}`,\n            commits: [\n                commit\n            ],\n            diffs: [],\n            format: \"UNIFIED\",\n            content: \"\",\n            metadata: {\n                createdAt: new Date(),\n                createdBy: commit.author.name,\n                description: commit.message,\n                baseCommitId: commit.parentIds[0] || \"\"\n            }\n        };\n        patch.content = this.exportPatch(patch);\n        return patch;\n    }\n    async createPatchFromCommits(commits) {\n        const patch = {\n            id: `patch-${Date.now()}`,\n            commits,\n            diffs: [],\n            format: \"UNIFIED\",\n            content: \"\",\n            metadata: {\n                createdAt: new Date(),\n                createdBy: commits[0]?.author.name || \"unknown\",\n                description: `Patch from ${commits.length} commits`,\n                baseCommitId: commits[0]?.parentIds[0] || \"\"\n            }\n        };\n        patch.content = this.exportPatch(patch);\n        return patch;\n    }\n    async getCommitRange(fromCommit, toCommit) {\n        const commits = [];\n        let currentId = toCommit;\n        while(currentId && currentId !== fromCommit){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.unshift(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n    async checkPatch(patch) {\n        // Simplified check - in production would verify all changes can be applied\n        return true;\n    }\n    async applyPatchInternal(patch, options) {\n        let appliedPatches = 0;\n        let failedPatches = 0;\n        const conflicts = [];\n        for (const commit of patch.commits){\n            try {\n                // Apply commit changes\n                await this.storage.saveCommit(commit);\n                appliedPatches++;\n            } catch (error) {\n                failedPatches++;\n            }\n        }\n        return {\n            success: failedPatches === 0,\n            appliedPatches,\n            failedPatches,\n            conflicts\n        };\n    }\n    async parsePatch(content) {\n        // Simplified parser - in production would parse Git patch format\n        const lines = content.split(\"\\n\");\n        const patch = {\n            id: `patch-${Date.now()}`,\n            commits: [],\n            diffs: [],\n            format: \"UNIFIED\",\n            content\n        };\n        return patch;\n    }\n    /**\n     * Generate patch statistics\n     */ getPatchStats(patch) {\n        const affectedTables = new Set();\n        let changeCount = 0;\n        for (const commit of patch.commits){\n            changeCount += commit.changes.length;\n            for (const change of commit.changes){\n                affectedTables.add(change.target);\n            }\n        }\n        return {\n            commitCount: patch.commits.length,\n            changeCount,\n            affectedTables\n        };\n    }\n}\nexports.PatchService = PatchService;\nexports[\"default\"] = PatchService; //# sourceMappingURL=PatchService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9QYXRjaFNlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFXQTs7SUFHQSxNQUFhQTtJQUdUQyxZQUFZQyxPQUE4QjtRQUN0QyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNQyxjQUFjQyxRQUFnQjtRQUNoQyxJQUFJO1lBQ0EsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLENBQUNGO1lBQzVDLElBQUksQ0FBQ0MsUUFBUTtnQkFDVCxPQUFPO29CQUFFRSxTQUFTO29CQUFPQyxPQUFPO2dCQUFrQjtZQUN0RDtZQUVBLE1BQU1DLFFBQVEsTUFBTSxJQUFJLENBQUNDLHFCQUFxQixDQUFDTDtZQUMvQyxPQUFPO2dCQUFFRSxTQUFTO2dCQUFNSSxNQUFNRjtZQUFLO1FBQ3ZDLEVBQUUsT0FBT0QsT0FBTztZQUNaLE9BQU87Z0JBQUVELFNBQVM7Z0JBQU9DLE9BQU8sMEJBQTBCQSxNQUFLLENBQUU7WUFBQTtRQUNyRTtJQUNKO0lBRUE7O1FBR0EsTUFBTUksbUJBQW1CQyxVQUFrQixFQUFFQyxRQUFnQjtRQUN6RCxJQUFJO1lBQ0EsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDSCxZQUFZQztZQUN0RCxJQUFJQyxRQUFRRSxNQUFNLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFBRVYsU0FBUztvQkFBT0MsT0FBTztnQkFBcUI7WUFDekQ7WUFFQSxNQUFNQyxRQUFRLE1BQU0sSUFBSSxDQUFDUyxzQkFBc0IsQ0FBQ0g7WUFDaEQsT0FBTztnQkFBRVIsU0FBUztnQkFBTUksTUFBTUY7WUFBSztRQUN2QyxFQUFFLE9BQU9ELE9BQU87WUFDWixPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPLGdDQUFnQ0EsTUFBSyxDQUFFO1lBQUE7UUFDM0U7SUFDSjtJQUVBOztRQUdBLE1BQU1XLFdBQ0ZWLEtBQVks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LENBQUM7UUFFNUIsTUFBTTFELFFBQWU7WUFDakI4QixJQUFJLFNBQVNMLEtBQUs2QixHQUFHLEdBQUUsQ0FBRTtZQUN6QmhELFNBQVMsRUFBRTtZQUNYa0MsT0FBTyxFQUFFO1lBQ1RXLFFBQVE7WUFDUkM7O1FBR0osT0FBT3BEO0lBQ1g7SUFFQTs7UUFHQTJELGNBQWMzRCxLQUFZO1FBS3RCLE1BQU00RCxpQkFBaUIsSUFBSUM7UUFDM0IsSUFBSUMsY0FBYztRQUVsQixLQUFLLE1BQU1sRSxVQUFVSSxNQUFNTSxPQUFPLENBQUU7WUFDaEN3RCxlQUFlbEUsT0FBT3lDLE9BQU8sQ0FBQzdCLE1BQU07WUFDcEMsS0FBSyxNQUFNNEIsVUFBVXhDLE9BQU95QyxPQUFPLENBQUU7Z0JBQ2pDdUIsZUFBZUcsR0FBRyxDQUFDM0IsT0FBTzRCLE1BQU07WUFDcEM7UUFDSjtRQUVBLE9BQU87WUFDSEMsYUFBYWpFLE1BQU1NLE9BQU8sQ0FBQ0UsTUFBTTtZQUNqQ3NEO1lBQ0FGOztJQUVSOztBQTlQSk0sb0JBQUEsR0FBQTNFO0FBaVFBMkUsa0JBQUEsR0FBZTNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9QYXRjaFNlcnZpY2UudHM/NmE2ZCJdLCJuYW1lcyI6WyJQYXRjaFNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInN0b3JhZ2UiLCJnZW5lcmF0ZVBhdGNoIiwiY29tbWl0SWQiLCJjb21taXQiLCJnZXRDb21taXQiLCJzdWNjZXNzIiwiZXJyb3IiLCJwYXRjaCIsImNyZWF0ZVBhdGNoRnJvbUNvbW1pdCIsImRhdGEiLCJnZW5lcmF0ZVBhdGNoUmFuZ2UiLCJmcm9tQ29tbWl0IiwidG9Db21taXQiLCJjb21taXRzIiwiZ2V0Q29tbWl0UmFuZ2UiLCJsZW5ndGgiLCJjcmVhdGVQYXRjaEZyb21Db21taXRzIiwiYXBwbHlQYXRjaCIsIm9wdGlvbnMiLCJjaGVjayIsImNhbkFwcGx5IiwiY2hlY2tQYXRjaCIsImFwcGxpZWRQYXRjaGVzIiwiZmFpbGVkUGF0Y2hlcyIsImNvbmZsaWN0cyIsInJlc3VsdCIsImFwcGx5UGF0Y2hJbnRlcm5hbCIsImV4cG9ydFBhdGNoIiwibGluZXMiLCJwdXNoIiwibWV0YWRhdGEiLCJiYXNlQ29tbWl0SWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVkQnkiLCJjcmVhdGVkQXQiLCJkZXNjcmlwdGlvbiIsImlkIiwiYXV0aG9yIiwibmFtZSIsImVtYWlsIiwidGltZXN0YW1wIiwibWVzc2FnZSIsImNoYW5nZSIsImNoYW5nZXMiLCJ0eXBlIiwiZGlmZiIsImRpZmZzIiwiZnJvbUNvbW1pdElkIiwidG9Db21taXRJZCIsInNjaGVtYUNoYW5nZXMiLCJwcmVmaXgiLCJvcGVyYXRpb24iLCJkYXRhQ2hhbmdlcyIsImpvaW4iLCJpbXBvcnRQYXRjaCIsInBhdGNoQ29udGVudCIsInBhcnNlUGF0Y2giLCJmb3JtYXQiLCJjb250ZW50IiwicGFyZW50SWRzIiwibm93IiwiY3VycmVudElkIiwidW5zaGlmdCIsInNhdmVDb21taXQiLCJzcGxpdCIsImdldFBhdGNoU3RhdHMiLCJhZmZlY3RlZFRhYmxlcyIsIlNldCIsImNoYW5nZUNvdW50IiwiYWRkIiwidGFyZ2V0IiwiY29tbWl0Q291bnQiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/PatchService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/VersionControlManager.js":
/*!*************************************************************************!*\
  !*** ../../packages/version-control/dist/core/VersionControlManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.VersionControlManager = void 0;\n/**\n * Main Version Control Manager\n * Implements all Git-like operations for database version control\n */ class VersionControlManager {\n    constructor(database, storage){\n        this.currentBranch = \"main\";\n        this.database = database;\n        this.storage = storage;\n    }\n    // ============ Initialization ============\n    async initialize() {\n        try {\n            // Check if already initialized by trying to get branches\n            const existingBranches = await this.storage.listBranches();\n            if (existingBranches.length > 0) {\n                await this.loadHEAD();\n                return {\n                    success: true,\n                    data: undefined\n                };\n            }\n            // Initialize repository\n            const config = {\n                HEAD: \"main\",\n                branches: {\n                    main: {\n                        name: \"main\",\n                        commitId: \"\",\n                        protected: true\n                    }\n                },\n                tags: {},\n                config: {\n                    core: {\n                        autoGc: true,\n                        logAllRefUpdates: true\n                    }\n                }\n            };\n            await this.storage.saveConfig(config);\n            // Explicitly save the main branch object to the branches directory\n            await this.storage.saveBranch({\n                name: \"main\",\n                commitId: \"\",\n                protected: true\n            });\n            this.currentBranch = \"main\"; // Sync instance state\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to initialize repository: ${error}`\n            };\n        }\n    }\n    /**\n     * Load the current branch from storage config\n     * Call this after getting an existing repo to sync instance state\n     */ async loadHEAD() {\n        try {\n            const config = await this.storage.getConfig();\n            this.currentBranch = config.HEAD || \"main\";\n        } catch  {\n            this.currentBranch = \"main\";\n        }\n    }\n    // ============ Core Commit Operations ============\n    async commit(message, author, changes, snapshot) {\n        try {\n            const config = await this.storage.getConfig();\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            const parentIds = branch.commitId ? [\n                branch.commitId\n            ] : [];\n            const commitId = this.generateCommitId();\n            const commit = {\n                id: commitId,\n                message,\n                author,\n                timestamp: new Date(),\n                parentIds,\n                treeId: commitId,\n                changes,\n                branchName: this.currentBranch\n            };\n            // Save commit and snapshot\n            await this.storage.saveCommit(commit);\n            await this.storage.saveSnapshot(commitId, snapshot);\n            // Update branch\n            branch.commitId = commitId;\n            await this.storage.saveBranch(branch);\n            // Add reflog entry\n            await this.addReflogEntry(\"COMMIT\", branch.name, parentIds[0] || \"\", commitId, `commit: ${message}`);\n            return {\n                success: true,\n                data: commit\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Commit failed: ${error}`\n            };\n        }\n    }\n    // ============ Branch Operations ============\n    async createBranch(name, fromCommit) {\n        try {\n            const branches = await this.storage.listBranches();\n            if (branches.find((b)=>b.name === name)) {\n                return {\n                    success: false,\n                    error: `Branch ${name} already exists`\n                };\n            }\n            const currentBranch = await this.storage.getBranch(this.currentBranch);\n            const commitId = fromCommit || currentBranch?.commitId || \"\";\n            const branch = {\n                name,\n                commitId,\n                protected: false\n            };\n            await this.storage.saveBranch(branch);\n            return {\n                success: true,\n                data: branch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to create branch: ${error}`\n            };\n        }\n    }\n    async checkout(branchName) {\n        try {\n            const branch = await this.storage.getBranch(branchName);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: `Branch ${branchName} not found`\n                };\n            }\n            const oldBranch = this.currentBranch;\n            const oldCommit = (await this.storage.getBranch(oldBranch))?.commitId || \"\";\n            this.currentBranch = branchName;\n            const config = await this.storage.getConfig();\n            config.HEAD = branchName;\n            await this.storage.saveConfig(config);\n            await this.addReflogEntry(\"CHECKOUT\", branchName, oldCommit, branch.commitId, `checkout: moving from ${oldBranch} to ${branchName}`);\n            // Handle branches with no commits yet (empty commitId)\n            if (!branch.commitId) {\n                return {\n                    success: true,\n                    data: null\n                }; // No snapshot, but checkout succeeded\n            }\n            const snapshot = await this.storage.getSnapshot(branch.commitId);\n            // Snapshot might not exist for new branches - that's OK\n            return {\n                success: true,\n                data: snapshot || null\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Checkout failed: ${error}`\n            };\n        }\n    }\n    async deleteBranch(name, force = false) {\n        try {\n            if (name === this.currentBranch) {\n                return {\n                    success: false,\n                    error: \"Cannot delete current branch\"\n                };\n            }\n            const branch = await this.storage.getBranch(name);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: `Branch ${name} not found`\n                };\n            }\n            if (branch.protected && !force) {\n                return {\n                    success: false,\n                    error: `Branch ${name} is protected`\n                };\n            }\n            await this.storage.deleteBranch(name);\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to delete branch: ${error}`\n            };\n        }\n    }\n    async listBranches() {\n        try {\n            const branches = await this.storage.listBranches();\n            return {\n                success: true,\n                data: branches\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list branches: ${error}`\n            };\n        }\n    }\n    // ============ Tag Operations ============\n    async createTag(name, commitId, message, tagger) {\n        try {\n            const existingTag = await this.storage.getTag(name);\n            if (existingTag) {\n                return {\n                    success: false,\n                    error: `Tag ${name} already exists`\n                };\n            }\n            const tag = {\n                name,\n                commitId,\n                type: message ? \"ANNOTATED\" : \"LIGHTWEIGHT\",\n                message,\n                tagger,\n                createdAt: new Date()\n            };\n            await this.storage.saveTag(tag);\n            return {\n                success: true,\n                data: tag\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to create tag: ${error}`\n            };\n        }\n    }\n    async deleteTag(name) {\n        try {\n            await this.storage.deleteTag(name);\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to delete tag: ${error}`\n            };\n        }\n    }\n    async listTags(filter) {\n        try {\n            const tags = await this.storage.listTags(filter);\n            return {\n                success: true,\n                data: tags\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list tags: ${error}`\n            };\n        }\n    }\n    async checkoutTag(tagName) {\n        try {\n            const tag = await this.storage.getTag(tagName);\n            if (!tag) {\n                return {\n                    success: false,\n                    error: `Tag ${tagName} not found`\n                };\n            }\n            const snapshot = await this.storage.getSnapshot(tag.commitId);\n            if (!snapshot) {\n                return {\n                    success: false,\n                    error: \"Snapshot not found\"\n                };\n            }\n            await this.addReflogEntry(\"CHECKOUT\", \"HEAD\", \"\", tag.commitId, `checkout: checking out tag ${tagName}`);\n            return {\n                success: true,\n                data: snapshot\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to checkout tag: ${error}`\n            };\n        }\n    }\n    // ============ Stash Operations ============\n    async stash(message, author, changes, options) {\n        try {\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            const stash = {\n                id: this.generateStashId(),\n                message: message || `WIP on ${this.currentBranch}`,\n                branchName: this.currentBranch,\n                parentCommitId: branch.commitId,\n                changes,\n                author,\n                createdAt: new Date()\n            };\n            await this.storage.saveStash(stash);\n            return {\n                success: true,\n                data: stash\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash failed: ${error}`\n            };\n        }\n    }\n    async stashPop() {\n        try {\n            const stashes = await this.storage.listStashes();\n            if (stashes.length === 0) {\n                return {\n                    success: false,\n                    error: \"No stashes found\"\n                };\n            }\n            const latestStash = stashes[stashes.length - 1];\n            await this.storage.deleteStash(latestStash.id);\n            return {\n                success: true,\n                data: latestStash.changes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash pop failed: ${error}`\n            };\n        }\n    }\n    async stashApply(stashId) {\n        try {\n            let stash;\n            if (stashId) {\n                stash = await this.storage.getStash(stashId);\n            } else {\n                const stashes = await this.storage.listStashes();\n                stash = stashes[stashes.length - 1] || null;\n            }\n            if (!stash) {\n                return {\n                    success: false,\n                    error: \"Stash not found\"\n                };\n            }\n            return {\n                success: true,\n                data: stash.changes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash apply failed: ${error}`\n            };\n        }\n    }\n    async listStashes() {\n        try {\n            const stashes = await this.storage.listStashes();\n            return {\n                success: true,\n                data: stashes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list stashes: ${error}`\n            };\n        }\n    }\n    // ============ Merge Operations ============\n    async merge(sourceBranch, options) {\n        try {\n            const source = await this.storage.getBranch(sourceBranch);\n            const target = await this.storage.getBranch(this.currentBranch);\n            if (!source || !target) {\n                return {\n                    success: false,\n                    error: \"Branch not found\"\n                };\n            }\n            // Get commits\n            const sourceCommit = await this.storage.getCommit(source.commitId);\n            const targetCommit = target.commitId ? await this.storage.getCommit(target.commitId) : null;\n            if (!sourceCommit) {\n                return {\n                    success: false,\n                    error: \"Source commit not found\"\n                };\n            }\n            // Check for fast-forward\n            if (options?.noFastForward !== true) {\n                const canFastForward = await this.canFastForward(target.commitId, source.commitId);\n                if (canFastForward) {\n                    target.commitId = source.commitId;\n                    await this.storage.saveBranch(target);\n                    return {\n                        success: true,\n                        data: {\n                            success: true,\n                            commitId: source.commitId,\n                            conflicts: [],\n                            strategy: \"FAST_FORWARD\",\n                            message: \"Fast-forward merge\"\n                        }\n                    };\n                }\n            }\n            // Perform 3-way merge\n            const mergeResult = await this.performMerge(targetCommit, sourceCommit, options);\n            await this.addReflogEntry(\"MERGE\", this.currentBranch, target.commitId, mergeResult.commitId || \"\", `merge ${sourceBranch}: ${mergeResult.message}`);\n            return {\n                success: true,\n                data: mergeResult\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Merge failed: ${error}`\n            };\n        }\n    }\n    async performMerge(targetCommit, sourceCommit, options) {\n        // Simplified merge implementation\n        // In production, would implement proper 3-way merge algorithm\n        const conflicts = await this.detectConflicts(targetCommit, sourceCommit);\n        if (conflicts.length > 0 && !options?.allowConflicts) {\n            return {\n                success: false,\n                conflicts,\n                strategy: options?.strategy || \"RECURSIVE\",\n                message: \"Merge conflicts detected\"\n            };\n        }\n        // Create merge commit\n        const mergeCommit = {\n            id: this.generateCommitId(),\n            message: options?.message || `Merge branch '${sourceCommit.id}'`,\n            author: sourceCommit.author,\n            timestamp: new Date(),\n            parentIds: [\n                targetCommit?.id || \"\",\n                sourceCommit.id\n            ],\n            treeId: sourceCommit.treeId,\n            changes: sourceCommit.changes\n        };\n        await this.storage.saveCommit(mergeCommit);\n        return {\n            success: true,\n            commitId: mergeCommit.id,\n            conflicts: [],\n            strategy: options?.strategy || \"RECURSIVE\",\n            message: \"Merge successful\"\n        };\n    }\n    async detectConflicts(commit1, commit2) {\n        // Simplified conflict detection\n        return [];\n    }\n    async canFastForward(baseCommitId, targetCommitId) {\n        if (!baseCommitId) return true;\n        // Simplified: in production, would check if target is descendant of base\n        return false;\n    }\n    // ============ Cherry-Pick Operation ============\n    async cherryPick(commitId, options) {\n        try {\n            const commit = await this.storage.getCommit(commitId);\n            if (!commit) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const currentBranch = await this.storage.getBranch(this.currentBranch);\n            if (!currentBranch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            // Create new commit with same changes\n            const newCommit = {\n                id: this.generateCommitId(),\n                message: commit.message,\n                author: commit.author,\n                timestamp: new Date(),\n                parentIds: [\n                    currentBranch.commitId\n                ],\n                treeId: commit.treeId,\n                changes: commit.changes\n            };\n            await this.storage.saveCommit(newCommit);\n            if (!options?.noCommit) {\n                currentBranch.commitId = newCommit.id;\n                await this.storage.saveBranch(currentBranch);\n            }\n            await this.addReflogEntry(\"CHERRY_PICK\", this.currentBranch, currentBranch.commitId, newCommit.id, `cherry-pick: ${commit.message}`);\n            return {\n                success: true,\n                data: {\n                    success: true,\n                    newCommitId: newCommit.id,\n                    conflicts: [],\n                    skipped: false\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Cherry-pick failed: ${error}`\n            };\n        }\n    }\n    // ============ Rebase Operation ============\n    async rebase(upstreamBranch, options) {\n        try {\n            const upstream = await this.storage.getBranch(upstreamBranch);\n            const current = await this.storage.getBranch(this.currentBranch);\n            if (!upstream || !current) {\n                return {\n                    success: false,\n                    error: \"Branch not found\"\n                };\n            }\n            const commits = await this.getCommitsBetween(upstream.commitId, current.commitId);\n            const rebasedCommits = [];\n            for (const commit of commits){\n                const result = await this.cherryPick(commit.id, {\n                    noCommit: false\n                });\n                if (!result.success || !result.data.newCommitId) {\n                    return {\n                        success: false,\n                        error: \"Rebase failed during cherry-pick\"\n                    };\n                }\n                rebasedCommits.push(result.data.newCommitId);\n            }\n            await this.addReflogEntry(\"REBASE\", this.currentBranch, current.commitId, rebasedCommits[rebasedCommits.length - 1] || \"\", `rebase: onto ${upstreamBranch}`);\n            return {\n                success: true,\n                data: {\n                    success: true,\n                    newHeadCommitId: rebasedCommits[rebasedCommits.length - 1],\n                    rebasedCommits,\n                    conflicts: [],\n                    aborted: false\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Rebase failed: ${error}`\n            };\n        }\n    }\n    async getCommitsBetween(baseCommitId, headCommitId) {\n        // Simplified: in production would traverse commit graph\n        const commits = [];\n        let currentId = headCommitId;\n        while(currentId && currentId !== baseCommitId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.unshift(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n    // ============ Diff Operation ============\n    async diff(fromCommit, toCommit, options) {\n        try {\n            const from = await this.storage.getCommit(fromCommit);\n            const to = await this.storage.getCommit(toCommit);\n            if (!from || !to) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const fromSnapshot = await this.storage.getSnapshot(from.treeId);\n            const toSnapshot = await this.storage.getSnapshot(to.treeId);\n            if (!fromSnapshot || !toSnapshot) {\n                return {\n                    success: false,\n                    error: \"Snapshot not found\"\n                };\n            }\n            const diff = this.computeDiff(fromSnapshot, toSnapshot);\n            return {\n                success: true,\n                data: diff\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Diff failed: ${error}`\n            };\n        }\n    }\n    computeDiff(from, to) {\n        const schemaChanges = [];\n        const dataChanges = [];\n        // Simplified diff computation\n        // In production would compare schemas and data in detail\n        return {\n            fromCommitId: \"\",\n            toCommitId: \"\",\n            schemaChanges,\n            dataChanges,\n            viewChanges: [],\n            indexChanges: [],\n            summary: {\n                filesChanged: 0,\n                insertions: 0,\n                deletions: 0,\n                modifications: 0\n            }\n        };\n    }\n    // ============ Reflog Operations ============\n    async getReflog(options) {\n        try {\n            const entries = await this.storage.getReflog(options);\n            return {\n                success: true,\n                data: entries\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get reflog: ${error}`\n            };\n        }\n    }\n    async addReflogEntry(action, ref, oldCommitId, newCommitId, message) {\n        const config = await this.storage.getConfig();\n        if (config.config.core?.logAllRefUpdates !== false) {\n            const userAuthor = config.config.user ? {\n                ...config.config.user,\n                timestamp: new Date()\n            } : {\n                name: \"System\",\n                email: \"\",\n                timestamp: new Date()\n            };\n            const entry = {\n                id: Date.now(),\n                ref,\n                oldCommitId,\n                newCommitId,\n                action,\n                message,\n                author: userAuthor,\n                timestamp: new Date()\n            };\n            await this.storage.addReflogEntry(entry);\n        }\n    }\n    // ============ Helper Methods ============\n    generateCommitId() {\n        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    generateStashId() {\n        return `stash@{${Date.now()}}`;\n    }\n    async getCurrentBranch() {\n        // Always read from storage to be accurate across requests\n        try {\n            const config = await this.storage.getConfig();\n            this.currentBranch = config.HEAD || \"main\";\n        } catch  {\n        // Keep current value if storage fails\n        }\n        return this.currentBranch;\n    }\n    async getHEAD() {\n        try {\n            const config = await this.storage.getConfig();\n            return {\n                success: true,\n                data: config.HEAD\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get HEAD: ${error}`\n            };\n        }\n    }\n    async log(options) {\n        try {\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch || !branch.commitId) {\n                return {\n                    success: true,\n                    data: []\n                };\n            }\n            const commits = await this.getCommitHistory(branch.commitId, options);\n            return {\n                success: true,\n                data: commits\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Log failed: ${error}`\n            };\n        }\n    }\n    async getCommitHistory(commitId, options) {\n        const commits = [];\n        let currentId = commitId;\n        let count = 0;\n        const maxCount = options?.maxCount || 100;\n        while(currentId && count < maxCount){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Apply filters\n            if (options?.author && commit.author.name !== options.author) {\n                currentId = commit.parentIds[0] || \"\";\n                continue;\n            }\n            if (options?.since && commit.timestamp < options.since) break;\n            if (options?.until && commit.timestamp > options.until) {\n                currentId = commit.parentIds[0] || \"\";\n                continue;\n            }\n            commits.push(commit);\n            count++;\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n}\nexports.VersionControlManager = VersionControlManager;\nexports[\"default\"] = VersionControlManager; //# sourceMappingURL=VersionControlManager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9WZXJzaW9uQ29udHJvbE1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFrQ0E7OztJQUlBLE1BQWFBO0lBS1RDLFlBQVlDLFFBQWdCLEVBQUVDLE9BQThCO1FBRnBELEtBQUFDLGFBQWEsR0FBVztRQUc1QixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ25CO0lBRUEsMkNBQTJDO0lBRTNDLE1BQU1FLGFBQVU7UUFDWixJQUFJO1lBQ0EseURBQXlEO1lBQ3pELE1BQU1DLG1CQUFtQixNQUFNLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxZQUFZO1lBQ3hELElBQUlELGlCQUFpQkUsTUFBTSxHQUFHLEdBQUc7Z0JBQzdCLE1BQU0sSUFBSSxDQUFDQyxRQUFRO2dCQUNuQixPQUFPO29CQUFFQyxTQUFTO29CQUFNQyxNQUFNQztnQkFBUztZQUMzQztZQUVBLHdCQUF3QjtZQUN4QixNQUFNQyxTQUErQjtnQkFDakNDLE1BQU07Z0JBQ05DLFVBQVU7b0JBQ05DLE1BQU07d0JBQ0ZDLE1BQU07d0JBQ05DLFVBQVU7d0JBQ1ZDLFdBQVc7OztnQkFHbkJDLE1BQU07Z0JBQ05QLFFBQVE7b0JBQ0pRLE1BQU07d0JBQ0ZDLFFBQVE7d0JBQ1JDLGtCQUFrQjs7OztZQUs5QixNQUFNLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ3FCLFVBQVUsQ0FBQ1g7WUFFOUIsbUVBQW1FO1lBQ25FLE1BQU0sSUFBSSxDQUFDVixPQUFPLENBQUNzQixVQUFVLENBQUM7Z0JBQzFCUixNQUFNO2dCQUNOQyxVQUFVO2dCQUNWQyxXQUFXOztZQUdmLElBQUksQ0FBQ2YsYUFBYSxHQUFHLFFBQVEsc0JBQXNCO1lBQ25ELE9BQU87Z0JBQUVNLFNBQVM7Z0JBQU1DLE1BQU1DO1lBQVM7UUFDM0MsRUFBRSxPQUFPYyxPQUFPO1lBQ1osT0FBTztnQkFDSGhCLFNBQVM7Z0JBQ1Rn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Z0ssa0JBQUEsR0FBZWhLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9WZXJzaW9uQ29udHJvbE1hbmFnZXIudHM/YWYzMiJdLCJuYW1lcyI6WyJWZXJzaW9uQ29udHJvbE1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsImRhdGFiYXNlIiwic3RvcmFnZSIsImN1cnJlbnRCcmFuY2giLCJpbml0aWFsaXplIiwiZXhpc3RpbmdCcmFuY2hlcyIsImxpc3RCcmFuY2hlcyIsImxlbmd0aCIsImxvYWRIRUFEIiwic3VjY2VzcyIsImRhdGEiLCJ1bmRlZmluZWQiLCJjb25maWciLCJIRUFEIiwiYnJhbmNoZXMiLCJtYWluIiwibmFtZSIsImNvbW1pdElkIiwicHJvdGVjdGVkIiwidGFncyIsImNvcmUiLCJhdXRvR2MiLCJsb2dBbGxSZWZVcGRhdGVzIiwic2F2ZUNvbmZpZyIsInNhdmVCcmFuY2giLCJlcnJvciIsImdldENvbmZpZyIsImNvbW1pdCIsIm1lc3NhZ2UiLCJhdXRob3IiLCJjaGFuZ2VzIiwic25hcHNob3QiLCJicmFuY2giLCJnZXRCcmFuY2giLCJwYXJlbnRJZHMiLCJnZW5lcmF0ZUNvbW1pdElkIiwiaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidHJlZUlkIiwiYnJhbmNoTmFtZSIsInNhdmVDb21taXQiLCJzYXZlU25hcHNob3QiLCJhZGRSZWZsb2dFbnRyeSIsImNyZWF0ZUJyYW5jaCIsImZyb21Db21taXQiLCJmaW5kIiwiYiIsImNoZWNrb3V0Iiwib2xkQnJhbmNoIiwib2xkQ29tbWl0IiwiZ2V0U25hcHNob3QiLCJkZWxldGVCcmFuY2giLCJmb3JjZSIsImNyZWF0ZVRhZyIsInRhZ2dlciIsImV4aXN0aW5nVGFnIiwiZ2V0VGFnIiwidGFnIiwidHlwZSIsImNyZWF0ZWRBdCIsInNhdmVUYWciLCJkZWxldGVUYWciLCJsaXN0VGFncyIsImZpbHRlciIsImNoZWNrb3V0VGFnIiwidGFnTmFtZSIsInN0YXNoIiwib3B0aW9ucyIsImdlbmVyYXRlU3Rhc2hJZCIsInBhcmVudENvbW1pdElkIiwic2F2ZVN0YXNoIiwic3Rhc2hQb3AiLCJzdGFzaGVzIiwibGlzdFN0YXNoZXMiLCJsYXRlc3RTdGFzaCIsImRlbGV0ZVN0YXNoIiwic3Rhc2hBcHBseSIsInN0YXNoSWQiLCJnZXRTdGFzaCIsIm1lcmdlIiwic291cmNlQnJhbmNoIiwic291cmNlIiwidGFyZ2V0Iiwic291cmNlQ29tbWl0IiwiZ2V0Q29tbWl0IiwidGFyZ2V0Q29tbWl0Iiwibm9GYXN0Rm9yd2FyZCIsImNhbkZhc3RGb3J3YXJkIiwiY29uZmxpY3RzIiwic3RyYXRlZ3kiLCJtZXJnZVJlc3VsdCIsInBlcmZvcm1NZXJnZSIsImRldGVjdENvbmZsaWN0cyIsImFsbG93Q29uZmxpY3RzIiwibWVyZ2VDb21taXQiLCJjb21taXQxIiwiY29tbWl0MiIsImJhc2VDb21taXRJZCIsInRhcmdldENvbW1pdElkIiwiY2hlcnJ5UGljayIsIm5ld0NvbW1pdCIsIm5vQ29tbWl0IiwibmV3Q29tbWl0SWQiLCJza2lwcGVkIiwicmViYXNlIiwidXBzdHJlYW1CcmFuY2giLCJ1cHN0cmVhbSIsImN1cnJlbnQiLCJjb21taXRzIiwiZ2V0Q29tbWl0c0JldHdlZW4iLCJyZWJhc2VkQ29tbWl0cyIsInJlc3VsdCIsInB1c2giLCJuZXdIZWFkQ29tbWl0SWQiLCJhYm9ydGVkIiwiaGVhZENvbW1pdElkIiwiY3VycmVudElkIiwidW5zaGlmdCIsImRpZmYiLCJ0b0NvbW1pdCIsImZyb20iLCJ0byIsImZyb21TbmFwc2hvdCIsInRvU25hcHNob3QiLCJjb21wdXRlRGlmZiIsInNjaGVtYUNoYW5nZXMiLCJkYXRhQ2hhbmdlcyIsImZyb21Db21taXRJZCIsInRvQ29tbWl0SWQiLCJ2aWV3Q2hhbmdlcyIsImluZGV4Q2hhbmdlcyIsInN1bW1hcnkiLCJmaWxlc0NoYW5nZWQiLCJpbnNlcnRpb25zIiwiZGVsZXRpb25zIiwibW9kaWZpY2F0aW9ucyIsImdldFJlZmxvZyIsImVudHJpZXMiLCJhY3Rpb24iLCJyZWYiLCJvbGRDb21taXRJZCIsInVzZXJBdXRob3IiLCJ1c2VyIiwiZW1haWwiLCJlbnRyeSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImdldEN1cnJlbnRCcmFuY2giLCJnZXRIRUFEIiwibG9nIiwiZ2V0Q29tbWl0SGlzdG9yeSIsImNvdW50IiwibWF4Q291bnQiLCJzaW5jZSIsInVudGlsIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/types.js":
/*!*********************************************************!*\
  !*** ../../packages/version-control/dist/core/types.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Core types for database version control system\n * Implements all Git-like operations for databases\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9jb3JlL3R5cGVzLnRzPzZiMjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/types.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/index.js":
/*!****************************************************!*\
  !*** ../../packages/version-control/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * BosDB Version Control System\n * Advanced Git-like version control for databases\n *\n * @module @bosdb/version-control\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FEATURES = exports.VERSION = exports.VersionControl = exports.FileStorage = exports.PatchService = exports.BisectService = exports.BlameService = exports.VersionControlManager = void 0;\nexports.createVersionControl = createVersionControl;\n// Export all types\n__exportStar(__webpack_require__(/*! ./core/types */ \"(rsc)/../../packages/version-control/dist/core/types.js\"), exports);\n// Export core manager\nvar VersionControlManager_1 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nObject.defineProperty(exports, \"VersionControlManager\", ({\n    enumerable: true,\n    get: function() {\n        return VersionControlManager_1.VersionControlManager;\n    }\n}));\n// Export specialized services\nvar BlameService_1 = __webpack_require__(/*! ./core/BlameService */ \"(rsc)/../../packages/version-control/dist/core/BlameService.js\");\nObject.defineProperty(exports, \"BlameService\", ({\n    enumerable: true,\n    get: function() {\n        return BlameService_1.BlameService;\n    }\n}));\nvar BisectService_1 = __webpack_require__(/*! ./core/BisectService */ \"(rsc)/../../packages/version-control/dist/core/BisectService.js\");\nObject.defineProperty(exports, \"BisectService\", ({\n    enumerable: true,\n    get: function() {\n        return BisectService_1.BisectService;\n    }\n}));\nvar PatchService_1 = __webpack_require__(/*! ./core/PatchService */ \"(rsc)/../../packages/version-control/dist/core/PatchService.js\");\nObject.defineProperty(exports, \"PatchService\", ({\n    enumerable: true,\n    get: function() {\n        return PatchService_1.PatchService;\n    }\n}));\n// Export storage implementations\nvar FileStorage_1 = __webpack_require__(/*! ./storage/FileStorage */ \"(rsc)/../../packages/version-control/dist/storage/FileStorage.js\");\nObject.defineProperty(exports, \"FileStorage\", ({\n    enumerable: true,\n    get: function() {\n        return FileStorage_1.FileStorage;\n    }\n}));\n// Re-export default\nvar VersionControlManager_2 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nObject.defineProperty(exports, \"VersionControl\", ({\n    enumerable: true,\n    get: function() {\n        return __importDefault(VersionControlManager_2).default;\n    }\n}));\n/**\n * Create a new version control instance\n */ const VersionControlManager_3 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nfunction createVersionControl(database, storage) {\n    return new VersionControlManager_3.VersionControlManager(database, storage);\n}\n/**\n * Version information\n */ exports.VERSION = \"1.0.0\";\nexports.FEATURES = [\n    \"commits\",\n    \"branches\",\n    \"tags\",\n    \"stash\",\n    \"merge\",\n    \"cherry-pick\",\n    \"rebase\",\n    \"diff\",\n    \"blame\",\n    \"bisect\",\n    \"reflog\",\n    \"patches\"\n]; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkFBLDRCQUFBLEdBQUFDO0FBdkJBLG1CQUFtQjtBQUNuQkMsYUFBQUMsbUJBQUFBLENBQUEsZ0ZBQUFIO0FBRUEsc0JBQXNCO0FBQ3RCLElBQUFJLDBCQUFBRCxtQkFBQUEsQ0FBQTtBQUFTRSx5REFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBSix3QkFBQUsscUJBQXFCO0lBQUE7QUFBQTtBQUU5Qiw4QkFBOEI7QUFDOUIsSUFBQUMsaUJBQUFQLG1CQUFBQSxDQUFBO0FBQVNFLGdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BQUFFLGVBQUFDLFlBQVk7SUFBQTtBQUFBO0FBQ3JCLElBQUFDLGtCQUFBVCxtQkFBQUEsQ0FBQTtBQUFTRSxpREFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBSSxnQkFBQUMsYUFBYTtJQUFBO0FBQUE7QUFDdEIsSUFBQUMsaUJBQUFYLG1CQUFBQSxDQUFBO0FBQVNFLGdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BQUFNLGVBQUFDLFlBQVk7SUFBQTtBQUFBO0FBRXJCLGlDQUFpQztBQUNqQyxJQUFBQyxnQkFBQWIsbUJBQUFBLENBQUE7QUFBU0UsK0NBQUE7SUFBQUUsWUFBQTtJQUFBQyxLQUFBO1FBQUEsT0FBQVEsY0FBQUMsV0FBVztJQUFBO0FBQUE7QUFFcEIsb0JBQW9CO0FBQ3BCLElBQUFDLDBCQUFBZixtQkFBQUEsQ0FBQTtBQUFTRSxrREFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBVyxnQkFBQUQseUJBQUFFLE9BQU87SUFBQTtBQUFBO0FBRWhCOztJQUdBLE1BQUFDLDBCQUFBbEIsbUJBQUFBLENBQUE7QUFHQSxTQUFnQkYscUJBQ1pxQixRQUFnQixFQUNoQkMsT0FBOEI7SUFFOUIsT0FBTyxJQUFJRix3QkFBQVoscUJBQXFCLENBQUNhLFVBQVVDO0FBQy9DO0FBRUE7O0lBR2F2QixlQUFPLEdBQUc7QUFDVkEsZ0JBQVEsR0FBRztJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDTSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vc3JjL2luZGV4LnRzPzUyZDUiXSwibmFtZXMiOlsiZXhwb3J0cyIsImNyZWF0ZVZlcnNpb25Db250cm9sIiwiX19leHBvcnRTdGFyIiwicmVxdWlyZSIsIlZlcnNpb25Db250cm9sTWFuYWdlcl8xIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiVmVyc2lvbkNvbnRyb2xNYW5hZ2VyIiwiQmxhbWVTZXJ2aWNlXzEiLCJCbGFtZVNlcnZpY2UiLCJCaXNlY3RTZXJ2aWNlXzEiLCJCaXNlY3RTZXJ2aWNlIiwiUGF0Y2hTZXJ2aWNlXzEiLCJQYXRjaFNlcnZpY2UiLCJGaWxlU3RvcmFnZV8xIiwiRmlsZVN0b3JhZ2UiLCJWZXJzaW9uQ29udHJvbE1hbmFnZXJfMiIsIl9faW1wb3J0RGVmYXVsdCIsImRlZmF1bHQiLCJWZXJzaW9uQ29udHJvbE1hbmFnZXJfMyIsImRhdGFiYXNlIiwic3RvcmFnZSIsIlZFUlNJT04iLCJGRUFUVVJFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/storage/FileStorage.js":
/*!******************************************************************!*\
  !*** ../../packages/version-control/dist/storage/FileStorage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function() {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function(o) {\n            var ar = [];\n            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function(mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) {\n            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FileStorage = void 0;\nconst fs = __importStar(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\n/**\n * File-based storage implementation for version control\n */ class FileStorage {\n    constructor(baseDir){\n        this.baseDir = baseDir;\n        this.commitsDir = path.join(baseDir, \"commits\");\n        this.branchesDir = path.join(baseDir, \"branches\");\n        this.tagsDir = path.join(baseDir, \"tags\");\n        this.stashDir = path.join(baseDir, \"stash\");\n        this.reflogDir = path.join(baseDir, \"reflog\");\n        this.snapshotsDir = path.join(baseDir, \"snapshots\");\n        this.configFile = path.join(baseDir, \"config.json\");\n    }\n    async initialize() {\n        await fs.mkdir(this.commitsDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.branchesDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.tagsDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.stashDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.reflogDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.snapshotsDir, {\n            recursive: true\n        });\n        // Only create default config if it doesn't already exist\n        try {\n            await fs.access(this.configFile);\n        } catch  {\n            const defaultConfig = {\n                HEAD: \"main\",\n                branches: {},\n                tags: {},\n                config: {}\n            };\n            await this.saveConfig(defaultConfig);\n        }\n    }\n    // Commit operations\n    async saveCommit(commit) {\n        const filePath = path.join(this.commitsDir, `${commit.id}.json`);\n        await fs.writeFile(filePath, JSON.stringify(commit, null, 2));\n    }\n    async getCommit(id) {\n        try {\n            const filePath = path.join(this.commitsDir, `${id}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const commit = JSON.parse(content);\n            // Convert timestamp strings back to Date objects\n            commit.timestamp = new Date(commit.timestamp);\n            commit.author.timestamp = new Date(commit.author.timestamp);\n            return commit;\n        } catch  {\n            return null;\n        }\n    }\n    async getCommits(ids) {\n        const commits = [];\n        for (const id of ids){\n            const commit = await this.getCommit(id);\n            if (commit) commits.push(commit);\n        }\n        return commits;\n    }\n    // Branch operations\n    async saveBranch(branch) {\n        const filePath = path.join(this.branchesDir, `${branch.name}.json`);\n        await fs.writeFile(filePath, JSON.stringify(branch, null, 2));\n    }\n    async getBranch(name) {\n        try {\n            const filePath = path.join(this.branchesDir, `${name}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            return JSON.parse(content);\n        } catch  {\n            return null;\n        }\n    }\n    async listBranches() {\n        try {\n            const files = await fs.readdir(this.branchesDir);\n            const branches = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const name = file.replace(\".json\", \"\");\n                    const branch = await this.getBranch(name);\n                    if (branch) branches.push(branch);\n                }\n            }\n            return branches;\n        } catch  {\n            return [];\n        }\n    }\n    async deleteBranch(name) {\n        const filePath = path.join(this.branchesDir, `${name}.json`);\n        await fs.unlink(filePath);\n    }\n    // Tag operations\n    async saveTag(tag) {\n        const filePath = path.join(this.tagsDir, `${tag.name}.json`);\n        await fs.writeFile(filePath, JSON.stringify(tag, null, 2));\n    }\n    async getTag(name) {\n        try {\n            const filePath = path.join(this.tagsDir, `${name}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const tag = JSON.parse(content);\n            tag.createdAt = new Date(tag.createdAt);\n            if (tag.tagger) tag.tagger.timestamp = new Date(tag.tagger.timestamp);\n            return tag;\n        } catch  {\n            return null;\n        }\n    }\n    async listTags(filter) {\n        try {\n            const files = await fs.readdir(this.tagsDir);\n            const tags = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const name = file.replace(\".json\", \"\");\n                    const tag = await this.getTag(name);\n                    if (tag && this.matchesTagFilter(tag, filter)) {\n                        tags.push(tag);\n                    }\n                }\n            }\n            return tags.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n        } catch  {\n            return [];\n        }\n    }\n    async deleteTag(name) {\n        const filePath = path.join(this.tagsDir, `${name}.json`);\n        await fs.unlink(filePath);\n    }\n    matchesTagFilter(tag, filter) {\n        if (!filter) return true;\n        if (filter.pattern && !tag.name.includes(filter.pattern)) return false;\n        if (filter.afterDate && tag.createdAt < filter.afterDate) return false;\n        if (filter.beforeDate && tag.createdAt > filter.beforeDate) return false;\n        if (filter.annotatedOnly && tag.type !== \"ANNOTATED\") return false;\n        return true;\n    }\n    // Stash operations\n    async saveStash(stash) {\n        const filePath = path.join(this.stashDir, `${stash.id}.json`);\n        await fs.writeFile(filePath, JSON.stringify(stash, null, 2));\n    }\n    async getStash(id) {\n        try {\n            const filePath = path.join(this.stashDir, `${id}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const stash = JSON.parse(content);\n            stash.createdAt = new Date(stash.createdAt);\n            stash.author.timestamp = new Date(stash.author.timestamp);\n            return stash;\n        } catch  {\n            return null;\n        }\n    }\n    async listStashes() {\n        try {\n            const files = await fs.readdir(this.stashDir);\n            const stashes = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const id = file.replace(\".json\", \"\");\n                    const stash = await this.getStash(id);\n                    if (stash) stashes.push(stash);\n                }\n            }\n            return stashes.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n        } catch  {\n            return [];\n        }\n    }\n    async deleteStash(id) {\n        const filePath = path.join(this.stashDir, `${id}.json`);\n        await fs.unlink(filePath);\n    }\n    // Reflog operations\n    async addReflogEntry(entry) {\n        const filePath = path.join(this.reflogDir, `reflog.jsonl`);\n        const line = JSON.stringify(entry) + \"\\n\";\n        await fs.appendFile(filePath, line);\n    }\n    async getReflog(options) {\n        try {\n            const filePath = path.join(this.reflogDir, `reflog.jsonl`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const lines = content.trim().split(\"\\n\").filter((l)=>l);\n            let entries = lines.map((line)=>{\n                const entry = JSON.parse(line);\n                entry.timestamp = new Date(entry.timestamp);\n                entry.author.timestamp = new Date(entry.author.timestamp);\n                return entry;\n            });\n            // Apply filters\n            if (options?.refName) {\n                entries = entries.filter((e)=>e.ref === options.refName);\n            }\n            if (options?.since) {\n                entries = entries.filter((e)=>e.timestamp >= options.since);\n            }\n            if (options?.until) {\n                entries = entries.filter((e)=>e.timestamp <= options.until);\n            }\n            if (options?.maxCount) {\n                entries = entries.slice(-options.maxCount);\n            }\n            return entries.reverse();\n        } catch  {\n            return [];\n        }\n    }\n    // Snapshot operations\n    async saveSnapshot(commitId, snapshot) {\n        const filePath = path.join(this.snapshotsDir, `${commitId}.json`);\n        await fs.writeFile(filePath, JSON.stringify(snapshot, null, 2));\n    }\n    async getSnapshot(commitId) {\n        try {\n            const filePath = path.join(this.snapshotsDir, `${commitId}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const snapshot = JSON.parse(content);\n            snapshot.timestamp = new Date(snapshot.timestamp);\n            return snapshot;\n        } catch  {\n            return null;\n        }\n    }\n    // Config operations\n    async getConfig() {\n        try {\n            const content = await fs.readFile(this.configFile, \"utf-8\");\n            return JSON.parse(content);\n        } catch  {\n            return {\n                HEAD: \"main\",\n                branches: {},\n                tags: {},\n                config: {}\n            };\n        }\n    }\n    async saveConfig(config) {\n        await fs.writeFile(this.configFile, JSON.stringify(config, null, 2));\n    }\n}\nexports.FileStorage = FileStorage;\nexports[\"default\"] = FileStorage; //# sourceMappingURL=FileStorage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3Qvc3RvcmFnZS9GaWxlU3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxLQUFBQyxhQUFBQyxtQkFBQUEsQ0FBQTtBQUNBLE1BQUFDLE9BQUFGLGFBQUFDLG1CQUFBQSxDQUFBO0FBY0E7O0lBR0EsTUFBYUU7SUFVVEMsWUFBWUMsT0FBZTtRQUN2QixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0osS0FBS0ssSUFBSSxDQUFDRixTQUFTO1FBQ3JDLElBQUksQ0FBQ0csV0FBVyxHQUFHTixLQUFLSyxJQUFJLENBQUNGLFNBQVM7UUFDdEMsSUFBSSxDQUFDSSxPQUFPLEdBQUdQLEtBQUtLLElBQUksQ0FBQ0YsU0FBUztRQUNsQyxJQUFJLENBQUNLLFFBQVEsR0FBR1IsS0FBS0ssSUFBSSxDQUFDRixTQUFTO1FBQ25DLElBQUksQ0FBQ00sU0FBUyxHQUFHVCxLQUFLSyxJQUFJLENBQUNGLFNBQVM7UUFDcEMsSUFBSSxDQUFDTyxZQUFZLEdBQUdWLEtBQUtLLElBQUksQ0FBQ0YsU0FBUztRQUN2QyxJQUFJLENBQUNRLFVBQVUsR0FBR1gsS0FBS0ssSUFBSSxDQUFDRixTQUFTO0lBQ3pDO0lBRUEsTUFBTVMsYUFBVTtRQUNaLE1BQU1mLEdBQUdnQixLQUFLLENBQUMsSUFBSSxDQUFDVCxVQUFVLEVBQUU7WUFBRVUsV0FBVztRQUFJO1FBQ2pELE1BQU1qQixHQUFHZ0IsS0FBSyxDQUFDLElBQUksQ0FBQ1AsV0FBVyxFQUFFO1lBQUVRLFdBQVc7UUFBSTtRQUNsRCxNQUFNakIsR0FBR2dCLEtBQUssQ0FBQyxJQUFJLENBQUNOLE9BQU8sRUFBRTtZQUFFTyxXQUFXO1FBQUk7UUFDOUMsTUFBTWpCLEdBQUdnQixLQUFLLENBQUMsSUFBSSxDQUFDTCxRQUFRLEVBQUU7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LFVBQVUsRUFBRTtZQUNuRCxPQUFPZ0IsS0FBS0ssS0FBSyxDQUFDRjtRQUN0QixFQUFFLE9BQU07WUFDSixPQUFPO2dCQUNIYixNQUFNO2dCQUNOQyxVQUFVO2dCQUNWQyxNQUFNO2dCQUNOQyxRQUFROztRQUVoQjtJQUNKO0lBRUEsTUFBTUMsV0FBV0QsTUFBNEI7UUFDekMsTUFBTXZCLEdBQUc2QixTQUFTLENBQUMsSUFBSSxDQUFDZixVQUFVLEVBQUVnQixLQUFLQyxTQUFTLENBQUNSLFFBQVEsTUFBTTtJQUNyRTs7QUF4UkprRixtQkFBQSxHQUFBckc7QUEyUkFxRyxrQkFBQSxHQUFlckciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9zdG9yYWdlL0ZpbGVTdG9yYWdlLnRzPzk1OTAiXSwibmFtZXMiOlsiZnMiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwicGF0aCIsIkZpbGVTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJiYXNlRGlyIiwiY29tbWl0c0RpciIsImpvaW4iLCJicmFuY2hlc0RpciIsInRhZ3NEaXIiLCJzdGFzaERpciIsInJlZmxvZ0RpciIsInNuYXBzaG90c0RpciIsImNvbmZpZ0ZpbGUiLCJpbml0aWFsaXplIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJhY2Nlc3MiLCJkZWZhdWx0Q29uZmlnIiwiSEVBRCIsImJyYW5jaGVzIiwidGFncyIsImNvbmZpZyIsInNhdmVDb25maWciLCJzYXZlQ29tbWl0IiwiY29tbWl0IiwiZmlsZVBhdGgiLCJpZCIsIndyaXRlRmlsZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRDb21taXQiLCJjb250ZW50IiwicmVhZEZpbGUiLCJwYXJzZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJhdXRob3IiLCJnZXRDb21taXRzIiwiaWRzIiwiY29tbWl0cyIsInB1c2giLCJzYXZlQnJhbmNoIiwiYnJhbmNoIiwibmFtZSIsImdldEJyYW5jaCIsImxpc3RCcmFuY2hlcyIsImZpbGVzIiwicmVhZGRpciIsImZpbGUiLCJlbmRzV2l0aCIsInJlcGxhY2UiLCJkZWxldGVCcmFuY2giLCJ1bmxpbmsiLCJzYXZlVGFnIiwidGFnIiwiZ2V0VGFnIiwiY3JlYXRlZEF0IiwidGFnZ2VyIiwibGlzdFRhZ3MiLCJmaWx0ZXIiLCJtYXRjaGVzVGFnRmlsdGVyIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImRlbGV0ZVRhZyIsInBhdHRlcm4iLCJpbmNsdWRlcyIsImFmdGVyRGF0ZSIsImJlZm9yZURhdGUiLCJhbm5vdGF0ZWRPbmx5IiwidHlwZSIsInNhdmVTdGFzaCIsInN0YXNoIiwiZ2V0U3Rhc2giLCJsaXN0U3Rhc2hlcyIsInN0YXNoZXMiLCJkZWxldGVTdGFzaCIsImFkZFJlZmxvZ0VudHJ5IiwiZW50cnkiLCJsaW5lIiwiYXBwZW5kRmlsZSIsImdldFJlZmxvZyIsIm9wdGlvbnMiLCJsaW5lcyIsInRyaW0iLCJzcGxpdCIsImwiLCJlbnRyaWVzIiwibWFwIiwicmVmTmFtZSIsImUiLCJyZWYiLCJzaW5jZSIsInVudGlsIiwibWF4Q291bnQiLCJzbGljZSIsInJldmVyc2UiLCJzYXZlU25hcHNob3QiLCJjb21taXRJZCIsInNuYXBzaG90IiwiZ2V0U25hcHNob3QiLCJnZXRDb25maWciLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/storage/FileStorage.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/mongodb","vendor-chunks/tr46","vendor-chunks/ioredis","vendor-chunks/bson","vendor-chunks/whatwg-url","vendor-chunks/@ioredis","vendor-chunks/debug","vendor-chunks/lodash.defaults","vendor-chunks/aws4","vendor-chunks/redis-parser","vendor-chunks/punycode","vendor-chunks/webidl-conversions","vendor-chunks/denque","vendor-chunks/mongodb-connection-string-url","vendor-chunks/@mongodb-js","vendor-chunks/cluster-key-slot","vendor-chunks/lodash.isarguments","vendor-chunks/memory-pager","vendor-chunks/redis-errors","vendor-chunks/ms","vendor-chunks/supports-color","vendor-chunks/sparse-bitfield","vendor-chunks/standard-as-callback","vendor-chunks/has-flag"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Frollback%2Froute&page=%2Fapi%2Fvcs%2Frollback%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Frollback%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();