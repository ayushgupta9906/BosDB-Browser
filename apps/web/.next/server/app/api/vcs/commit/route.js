"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/vcs/commit/route";
exports.ids = ["app/api/vcs/commit/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("fs/promises");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Fcommit%2Froute&page=%2Fapi%2Fvcs%2Fcommit%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Fcommit%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Fcommit%2Froute&page=%2Fapi%2Fvcs%2Fcommit%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Fcommit%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_commit_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/vcs/commit/route.ts */ \"(rsc)/./src/app/api/vcs/commit/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/vcs/commit/route\",\n        pathname: \"/api/vcs/commit\",\n        filename: \"route\",\n        bundlePath: \"app/api/vcs/commit/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\Arush Gupta\\\\Downloads\\\\BosDB-Browser\\\\apps\\\\web\\\\src\\\\app\\\\api\\\\vcs\\\\commit\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Arush_Gupta_Downloads_BosDB_Browser_apps_web_src_app_api_vcs_commit_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/vcs/commit/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ2Y3MlMkZjb21taXQlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnZjcyUyRmNvbW1pdCUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnZjcyUyRmNvbW1pdCUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNBcnVzaCUyMEd1cHRhJTVDRG93bmxvYWRzJTVDQm9zREItQnJvd3NlciU1Q2FwcHMlNUN3ZWIlNUNzcmMlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q0FydXNoJTIwR3VwdGElNUNEb3dubG9hZHMlNUNCb3NEQi1Ccm93c2VyJTVDYXBwcyU1Q3dlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD1zdGFuZGFsb25lJnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ2lEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8/YTEzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxBcnVzaCBHdXB0YVxcXFxEb3dubG9hZHNcXFxcQm9zREItQnJvd3NlclxcXFxhcHBzXFxcXHdlYlxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFx2Y3NcXFxcY29tbWl0XFxcXHJvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcInN0YW5kYWxvbmVcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdmNzL2NvbW1pdC9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3Zjcy9jb21taXRcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL3Zjcy9jb21taXQvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxBcnVzaCBHdXB0YVxcXFxEb3dubG9hZHNcXFxcQm9zREItQnJvd3NlclxcXFxhcHBzXFxcXHdlYlxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFx2Y3NcXFxcY29tbWl0XFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS92Y3MvY29tbWl0L3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Fcommit%2Froute&page=%2Fapi%2Fvcs%2Fcommit%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Fcommit%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/vcs/commit/route.ts":
/*!*****************************************!*\
  !*** ./src/app/api/vcs/commit/route.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bosdb/version-control */ \"(rsc)/../../packages/version-control/dist/index.js\");\n/* harmony import */ var _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n// POST /api/vcs/commit - Create a commit\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { connectionId, message, author, changes, snapshot } = body;\n        if (!connectionId || !message) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing required fields\"\n            }, {\n                status: 400\n            });\n        }\n        // Initialize VCS\n        const vcsPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), \".bosdb-vcs\", connectionId);\n        const storage = new _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.FileStorage(vcsPath);\n        await storage.initialize();\n        const vc = (0,_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.createVersionControl)(connectionId, storage);\n        // Ensure initialized and state is loaded\n        await vc.initialize();\n        await vc.loadHEAD();\n        // Use provided author or default\n        const commitAuthor = author || {\n            name: \"System User\",\n            email: \"user@bosdb.com\",\n            timestamp: new Date()\n        };\n        // Create commit\n        const result = await vc.commit(message, {\n            ...commitAuthor,\n            timestamp: new Date()\n        }, changes || [], snapshot || {\n            schema: {\n                tables: {}\n            },\n            data: {\n                tables: {}\n            },\n            timestamp: new Date()\n        });\n        if (!result.success) {\n            console.error(\"Commit failed:\", result.error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: result.error || \"Commit failed\"\n            }, {\n                status: 500\n            });\n        }\n        // Remove only the committed changes from pending\n        const pendingPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(vcsPath, \"pending.json\");\n        try {\n            const pendingData = await fs__WEBPACK_IMPORTED_MODULE_3__.promises.readFile(pendingPath, \"utf-8\");\n            const pending = JSON.parse(pendingData);\n            // Filter out the changes that were just committed\n            // Match by operation, target, and query for accurate removal\n            const remainingChanges = pending.changes.filter((pendingChange)=>{\n                return !changes.some((committedChange)=>pendingChange.operation === committedChange.operation && pendingChange.target === committedChange.target && pendingChange.query === committedChange.query);\n            });\n            await fs__WEBPACK_IMPORTED_MODULE_3__.promises.writeFile(pendingPath, JSON.stringify({\n                changes: remainingChanges\n            }, null, 2));\n        } catch (error) {\n            // If pending file doesn't exist or has issues, just create empty one\n            await fs__WEBPACK_IMPORTED_MODULE_3__.promises.writeFile(pendingPath, JSON.stringify({\n                changes: []\n            }));\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            commit: result.data\n        });\n    } catch (error) {\n        console.error(\"Commit API error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: String(error)\n        }, {\n            status: 500\n        });\n    }\n}\n// GET /api/vcs/commit?connectionId=xxx - Get commit history\nasync function GET(request) {\n    const searchParams = request.nextUrl.searchParams;\n    const connectionId = searchParams.get(\"connectionId\");\n    if (!connectionId) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Connection ID required\"\n        }, {\n            status: 400\n        });\n    }\n    try {\n        const vcsPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), \".bosdb-vcs\", connectionId);\n        await fs__WEBPACK_IMPORTED_MODULE_3__.promises.mkdir(vcsPath, {\n            recursive: true\n        });\n        const storage = new _bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.FileStorage(vcsPath);\n        try {\n            await storage.initialize();\n        } catch  {\n        // Already initialized\n        }\n        const vc = (0,_bosdb_version_control__WEBPACK_IMPORTED_MODULE_1__.createVersionControl)(connectionId, storage);\n        // Ensure initialized and state is loaded\n        await vc.initialize();\n        await vc.loadHEAD();\n        const result = await vc.log({\n            maxCount: 50\n        });\n        if (!result.success) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                commits: []\n            });\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            commits: result.data || []\n        });\n    } catch (error) {\n        console.error(\"Get commits error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            commits: []\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1pxQixRQUFRckIsS0FBSyxDQUFDLHNCQUFzQkE7UUFDcEMsT0FBT2YscURBQVlBLENBQUNTLElBQUksQ0FBQztZQUFFcUQsU0FBUyxFQUFFO1FBQUM7SUFDM0M7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi9zcmMvYXBwL2FwaS92Y3MvY29tbWl0L3JvdXRlLnRzPzQ2NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgY3JlYXRlVmVyc2lvbkNvbnRyb2wgfSBmcm9tICdAYm9zZGIvdmVyc2lvbi1jb250cm9sJztcclxuaW1wb3J0IHsgRmlsZVN0b3JhZ2UgfSBmcm9tICdAYm9zZGIvdmVyc2lvbi1jb250cm9sJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xyXG5cclxuLy8gUE9TVCAvYXBpL3Zjcy9jb21taXQgLSBDcmVhdGUgYSBjb21taXRcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xyXG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbklkLCBtZXNzYWdlLCBhdXRob3IsIGNoYW5nZXMsIHNuYXBzaG90IH0gPSBib2R5O1xyXG5cclxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25JZCB8fCAhbWVzc2FnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzJyB9LCB7IHN0YXR1czogNDAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBWQ1NcclxuICAgICAgICBjb25zdCB2Y3NQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuYm9zZGItdmNzJywgY29ubmVjdGlvbklkKTtcclxuICAgICAgICBjb25zdCBzdG9yYWdlID0gbmV3IEZpbGVTdG9yYWdlKHZjc1BhdGgpO1xyXG4gICAgICAgIGF3YWl0IHN0b3JhZ2UuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCB2YyA9IGNyZWF0ZVZlcnNpb25Db250cm9sKGNvbm5lY3Rpb25JZCwgc3RvcmFnZSk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBpbml0aWFsaXplZCBhbmQgc3RhdGUgaXMgbG9hZGVkXHJcbiAgICAgICAgYXdhaXQgdmMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGF3YWl0ICh2YyBhcyBhbnkpLmxvYWRIRUFEKCk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBwcm92aWRlZCBhdXRob3Igb3IgZGVmYXVsdFxyXG4gICAgICAgIGNvbnN0IGNvbW1pdEF1dGhvciA9IGF1dGhvciB8fCB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTeXN0ZW0gVXNlcicsXHJcbiAgICAgICAgICAgIGVtYWlsOiAndXNlckBib3NkYi5jb20nLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY29tbWl0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmMuY29tbWl0KFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICB7IC4uLmNvbW1pdEF1dGhvciwgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH0sXHJcbiAgICAgICAgICAgIGNoYW5nZXMgfHwgW10sXHJcbiAgICAgICAgICAgIHNuYXBzaG90IHx8IHsgc2NoZW1hOiB7IHRhYmxlczoge30gfSwgZGF0YTogeyB0YWJsZXM6IHt9IH0sIHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb21taXQgZmFpbGVkOicsIHJlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0NvbW1pdCBmYWlsZWQnIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgY29tbWl0dGVkIGNoYW5nZXMgZnJvbSBwZW5kaW5nXHJcbiAgICAgICAgY29uc3QgcGVuZGluZ1BhdGggPSBwYXRoLmpvaW4odmNzUGF0aCwgJ3BlbmRpbmcuanNvbicpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdEYXRhID0gYXdhaXQgZnMucmVhZEZpbGUocGVuZGluZ1BhdGgsICd1dGYtOCcpO1xyXG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gSlNPTi5wYXJzZShwZW5kaW5nRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBjaGFuZ2VzIHRoYXQgd2VyZSBqdXN0IGNvbW1pdHRlZFxyXG4gICAgICAgICAgICAvLyBNYXRjaCBieSBvcGVyYXRpb24sIHRhcmdldCwgYW5kIHF1ZXJ5IGZvciBhY2N1cmF0ZSByZW1vdmFsXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0NoYW5nZXMgPSBwZW5kaW5nLmNoYW5nZXMuZmlsdGVyKChwZW5kaW5nQ2hhbmdlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhY2hhbmdlcy5zb21lKChjb21taXR0ZWRDaGFuZ2U6IGFueSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hhbmdlLm9wZXJhdGlvbiA9PT0gY29tbWl0dGVkQ2hhbmdlLm9wZXJhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDaGFuZ2UudGFyZ2V0ID09PSBjb21taXR0ZWRDaGFuZ2UudGFyZ2V0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoYW5nZS5xdWVyeSA9PT0gY29tbWl0dGVkQ2hhbmdlLnF1ZXJ5XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwZW5kaW5nUGF0aCwgSlNPTi5zdHJpbmdpZnkoeyBjaGFuZ2VzOiByZW1haW5pbmdDaGFuZ2VzIH0sIG51bGwsIDIpKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBJZiBwZW5kaW5nIGZpbGUgZG9lc24ndCBleGlzdCBvciBoYXMgaXNzdWVzLCBqdXN0IGNyZWF0ZSBlbXB0eSBvbmVcclxuICAgICAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHBlbmRpbmdQYXRoLCBKU09OLnN0cmluZ2lmeSh7IGNoYW5nZXM6IFtdIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHN1Y2Nlc3M6IHRydWUsIGNvbW1pdDogcmVzdWx0LmRhdGEgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbW1pdCBBUEkgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBTdHJpbmcoZXJyb3IpIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIEdFVCAvYXBpL3Zjcy9jb21taXQ/Y29ubmVjdGlvbklkPXh4eCAtIEdldCBjb21taXQgaGlzdG9yeVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSByZXF1ZXN0Lm5leHRVcmwuc2VhcmNoUGFyYW1zO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbklkID0gc2VhcmNoUGFyYW1zLmdldCgnY29ubmVjdGlvbklkJyk7XHJcblxyXG4gICAgaWYgKCFjb25uZWN0aW9uSWQpIHtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ0Nvbm5lY3Rpb24gSUQgcmVxdWlyZWQnIH0sIHsgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB2Y3NQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICcuYm9zZGItdmNzJywgY29ubmVjdGlvbklkKTtcclxuICAgICAgICBhd2FpdCBmcy5ta2Rpcih2Y3NQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IG5ldyBGaWxlU3RvcmFnZSh2Y3NQYXRoKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZS5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgaW5pdGlhbGl6ZWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZjID0gY3JlYXRlVmVyc2lvbkNvbnRyb2woY29ubmVjdGlvbklkLCBzdG9yYWdlKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGluaXRpYWxpemVkIGFuZCBzdGF0ZSBpcyBsb2FkZWRcclxuICAgICAgICBhd2FpdCB2Yy5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgYXdhaXQgKHZjIGFzIGFueSkubG9hZEhFQUQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmMubG9nKHsgbWF4Q291bnQ6IDUwIH0pO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGNvbW1pdHM6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgY29tbWl0czogcmVzdWx0LmRhdGEgfHwgW10gfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dldCBjb21taXRzIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBjb21taXRzOiBbXSB9KTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiY3JlYXRlVmVyc2lvbkNvbnRyb2wiLCJGaWxlU3RvcmFnZSIsInBhdGgiLCJwcm9taXNlcyIsImZzIiwiUE9TVCIsInJlcXVlc3QiLCJib2R5IiwianNvbiIsImNvbm5lY3Rpb25JZCIsIm1lc3NhZ2UiLCJhdXRob3IiLCJjaGFuZ2VzIiwic25hcHNob3QiLCJlcnJvciIsInN0YXR1cyIsInZjc1BhdGgiLCJqb2luIiwicHJvY2VzcyIsImN3ZCIsInN0b3JhZ2UiLCJpbml0aWFsaXplIiwidmMiLCJsb2FkSEVBRCIsImNvbW1pdEF1dGhvciIsIm5hbWUiLCJlbWFpbCIsInRpbWVzdGFtcCIsIkRhdGUiLCJyZXN1bHQiLCJjb21taXQiLCJzY2hlbWEiLCJ0YWJsZXMiLCJkYXRhIiwic3VjY2VzcyIsImNvbnNvbGUiLCJwZW5kaW5nUGF0aCIsInBlbmRpbmdEYXRhIiwicmVhZEZpbGUiLCJwZW5kaW5nIiwiSlNPTiIsInBhcnNlIiwicmVtYWluaW5nQ2hhbmdlcyIsImZpbHRlciIsInBlbmRpbmdDaGFuZ2UiLCJzb21lIiwiY29tbWl0dGVkQ2hhbmdlIiwib3BlcmF0aW9uIiwidGFyZ2V0IiwicXVlcnkiLCJ3cml0ZUZpbGUiLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJHRVQiLCJzZWFyY2hQYXJhbXMiLCJuZXh0VXJsIiwiZ2V0IiwibWtkaXIiLCJyZWN1cnNpdmUiLCJsb2ciLCJtYXhDb3VudCIsImNvbW1pdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/vcs/commit/route.ts\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/BisectService.js":
/*!*****************************************************************!*\
  !*** ../../packages/version-control/dist/core/BisectService.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BisectService = void 0;\n/**\n * Bisect Service - Binary search to find when a bug was introduced\n */ class BisectService {\n    constructor(storage){\n        this.currentSession = null;\n        this.storage = storage;\n    }\n    /**\n     * Start a bisect session\n     */ async start(goodCommitId, badCommitId) {\n        try {\n            if (this.currentSession) {\n                return {\n                    success: false,\n                    error: \"Bisect session already active\"\n                };\n            }\n            // Get all commits between good and bad\n            const commits = await this.getCommitRange(goodCommitId, badCommitId);\n            if (commits.length === 0) {\n                return {\n                    success: false,\n                    error: \"No commits between good and bad\"\n                };\n            }\n            // Start in the middle\n            const middleIndex = Math.floor(commits.length / 2);\n            this.currentSession = {\n                id: this.generateBisectId(),\n                goodCommits: [\n                    goodCommitId\n                ],\n                badCommits: [\n                    badCommitId\n                ],\n                currentCommit: commits[middleIndex].id,\n                remainingCommits: commits.map((c)=>c.id),\n                status: \"ACTIVE\"\n            };\n            return {\n                success: true,\n                data: this.currentSession\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Bisect start failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Mark current commit as good\n     */ async markGood() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.goodCommits.push(this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Mark good failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Mark current commit as bad\n     */ async markBad() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.badCommits.push(this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Mark bad failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Skip current commit\n     */ async skip() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            // Remove current commit from consideration\n            this.currentSession.remainingCommits = this.currentSession.remainingCommits.filter((id)=>id !== this.currentSession.currentCommit);\n            return this.nextStep();\n        } catch (error) {\n            return {\n                success: false,\n                error: `Skip failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Reset/abort bisect session\n     */ async reset() {\n        try {\n            if (!this.currentSession) {\n                return {\n                    success: false,\n                    error: \"No active bisect session\"\n                };\n            }\n            this.currentSession.status = \"ABORTED\";\n            this.currentSession = null;\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Reset failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Get current bisect session\n     */ getSession() {\n        return this.currentSession;\n    }\n    async nextStep() {\n        if (!this.currentSession) {\n            return {\n                success: false,\n                error: \"No active session\"\n            };\n        }\n        // Filter remaining commits based on good/bad commits\n        const remaining = await this.filterCommits(this.currentSession.remainingCommits, this.currentSession.goodCommits, this.currentSession.badCommits);\n        if (remaining.length === 0) {\n            // Found the first bad commit\n            this.currentSession.status = \"FOUND\";\n            this.currentSession.firstBadCommit = this.currentSession.badCommits[this.currentSession.badCommits.length - 1];\n            const session = {\n                ...this.currentSession\n            };\n            this.currentSession = null;\n            return {\n                success: true,\n                data: session\n            };\n        }\n        if (remaining.length === 1) {\n            // Only one commit left - this is the culprit\n            this.currentSession.status = \"FOUND\";\n            this.currentSession.firstBadCommit = remaining[0];\n            const session = {\n                ...this.currentSession\n            };\n            this.currentSession = null;\n            return {\n                success: true,\n                data: session\n            };\n        }\n        // Continue bisecting - choose middle commit\n        const middleIndex = Math.floor(remaining.length / 2);\n        this.currentSession.currentCommit = remaining[middleIndex];\n        this.currentSession.remainingCommits = remaining;\n        return {\n            success: true,\n            data: this.currentSession\n        };\n    }\n    async getCommitRange(goodCommitId, badCommitId) {\n        const commits = [];\n        let currentId = badCommitId;\n        while(currentId && currentId !== goodCommitId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.push(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async filterCommits(allCommits, goodCommits, badCommits) {\n        // Simplified filtering - in production would use commit graph analysis\n        return allCommits.filter((id)=>!goodCommits.includes(id) && !badCommits.includes(id));\n    }\n    generateBisectId() {\n        return `bisect-${Date.now()}`;\n    }\n    /**\n     * Estimate remaining steps\n     */ getRemainingSteps() {\n        if (!this.currentSession) return 0;\n        return Math.ceil(Math.log2(this.currentSession.remainingCommits.length));\n    }\n}\nexports.BisectService = BisectService;\nexports[\"default\"] = BisectService; //# sourceMappingURL=BisectService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9CaXNlY3RTZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBUUE7O0lBR0EsTUFBYUE7SUFJVEMsWUFBWUMsT0FBOEI7UUFGbEMsS0FBQUMsY0FBYyxHQUF5QjtRQUczQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNRSxNQUFNQyxZQUFvQixFQUFFQyxXQUFtQjtRQUNqRCxJQUFJO1lBQ0EsSUFBSSxJQUFJLENBQUNILGNBQWMsRUFBRTtnQkFDckIsT0FBTztvQkFBRUksU0FBUztvQkFBT0MsT0FBTztnQkFBK0I7WUFDbkU7WUFFQSx1Q0FBdUM7WUFDdkMsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDTCxjQUFjQztZQUV4RCxJQUFJRyxRQUFRRSxNQUFNLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFBRUosU0FBUztvQkFBT0MsT0FBTztnQkFBaUM7WUFDckU7WUFFQSxzQkFBc0I7WUFDdEIsTUFBTUksY0FBY0MsS0FBS0MsS0FBSyxDQUFDTCxRQUFRRSxNQUFNLEdBQUc7WUFFaEQsSUFBSSxDQUFDUixjQUFjLEdBQUc7Z0JBQ2xCWSxJQUFJLElBQUksQ0FBQ0MsZ0JBQWdCO2dCQUN6QkMsYUFBYTtvQkFBQ1o7aUJBQWE7Z0JBQzNCYSxZQUFZO29CQUFDWjtpQkFBWTtnQkFDekJhLGVBQWVWLE9BQU8sQ0FBQ0csWUFBWSxDQUFDRyxFQUFFO2dCQUN0Q0ssa0JBQWtCWCxRQUFRWSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRVAsRUFBRTtnQkFDekNRLFFBQVE7O1lBR1osT0FBTztnQkFBRWhCLFNBQVM7Z0JBQU1pQixNQUFNLElBQUksQ0FBQ3JCLGNBQWM7WUFBQTtRQUNyRCxFQUFFLE9BQU9LLE9BQU87WUFDWixPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPLHdCQUF3QkEsTUFBSyxDQUFFO1lBQUE7UUFDbkU7SUFD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LFNBQVMsQ0FBQyxFQUFFLElBQUk7UUFDdkM7UUFFQSxPQUFPaEMsUUFBUWlDLE9BQU87SUFDMUI7SUFFUSxNQUFNUCxjQUNWUSxVQUFvQixFQUNwQjFCLFdBQXFCLEVBQ3JCQyxVQUFvQjtRQUVwQix1RUFBdUU7UUFDdkUsT0FBT3lCLFdBQVdiLE1BQU0sQ0FDcEIsQ0FBQ2YsS0FBTyxDQUFDRSxZQUFZMkIsUUFBUSxDQUFDN0IsT0FBTyxDQUFDRyxXQUFXMEIsUUFBUSxDQUFDN0I7SUFFbEU7SUFFUUMsbUJBQWdCO1FBQ3BCLE9BQU8sVUFBVTZCLEtBQUtDLEdBQUcsR0FBRSxDQUFFO0lBQ2pDO0lBRUE7O1FBR0FDLG9CQUFpQjtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUM1QyxjQUFjLEVBQUUsT0FBTztRQUNqQyxPQUFPVSxLQUFLbUMsSUFBSSxDQUFDbkMsS0FBS29DLElBQUksQ0FBQyxJQUFJLENBQUM5QyxjQUFjLENBQUNpQixnQkFBZ0IsQ0FBQ1QsTUFBTTtJQUMxRTs7QUF2TUp1QyxxQkFBQSxHQUFBbEQ7QUEwTUFrRCxrQkFBQSxHQUFlbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9jb3JlL0Jpc2VjdFNlcnZpY2UudHM/NzFmNiJdLCJuYW1lcyI6WyJCaXNlY3RTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJzdG9yYWdlIiwiY3VycmVudFNlc3Npb24iLCJzdGFydCIsImdvb2RDb21taXRJZCIsImJhZENvbW1pdElkIiwic3VjY2VzcyIsImVycm9yIiwiY29tbWl0cyIsImdldENvbW1pdFJhbmdlIiwibGVuZ3RoIiwibWlkZGxlSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJpZCIsImdlbmVyYXRlQmlzZWN0SWQiLCJnb29kQ29tbWl0cyIsImJhZENvbW1pdHMiLCJjdXJyZW50Q29tbWl0IiwicmVtYWluaW5nQ29tbWl0cyIsIm1hcCIsImMiLCJzdGF0dXMiLCJkYXRhIiwibWFya0dvb2QiLCJwdXNoIiwibmV4dFN0ZXAiLCJtYXJrQmFkIiwic2tpcCIsImZpbHRlciIsInJlc2V0IiwidW5kZWZpbmVkIiwiZ2V0U2Vzc2lvbiIsInJlbWFpbmluZyIsImZpbHRlckNvbW1pdHMiLCJmaXJzdEJhZENvbW1pdCIsInNlc3Npb24iLCJjdXJyZW50SWQiLCJjb21taXQiLCJnZXRDb21taXQiLCJwYXJlbnRJZHMiLCJyZXZlcnNlIiwiYWxsQ29tbWl0cyIsImluY2x1ZGVzIiwiRGF0ZSIsIm5vdyIsImdldFJlbWFpbmluZ1N0ZXBzIiwiY2VpbCIsImxvZzIiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/BisectService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/BlameService.js":
/*!****************************************************************!*\
  !*** ../../packages/version-control/dist/core/BlameService.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BlameService = void 0;\n/**\n * Blame Service - Track who changed each part of the database\n */ class BlameService {\n    constructor(storage){\n        this.storage = storage;\n    }\n    /**\n     * Get blame information for a table\n     */ async blameTable(tableName, commitId, options) {\n        try {\n            const commits = await this.getCommitsAffectingTable(tableName, commitId);\n            const lines = await this.buildBlameLines(tableName, commits);\n            const blameInfo = {\n                table: tableName,\n                lines\n            };\n            return {\n                success: true,\n                data: blameInfo\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Blame failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Get blame information for a specific column\n     */ async blameColumn(tableName, columnName, commitId) {\n        try {\n            const commits = await this.getCommitsAffectingColumn(tableName, columnName, commitId);\n            const lines = await this.buildBlameLines(`${tableName}.${columnName}`, commits);\n            const blameInfo = {\n                table: tableName,\n                column: columnName,\n                lines\n            };\n            return {\n                success: true,\n                data: blameInfo\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Blame failed: ${error}`\n            };\n        }\n    }\n    async getCommitsAffectingTable(tableName, commitId) {\n        const commits = [];\n        let currentId = commitId;\n        while(currentId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Check if this commit affects the table\n            const affectsTable = commit.changes.some((change)=>change.type === \"SCHEMA\" && change.target === tableName || change.type === \"DATA\" && change.tableName === tableName);\n            if (affectsTable) {\n                commits.push(commit);\n            }\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async getCommitsAffectingColumn(tableName, columnName, commitId) {\n        const commits = [];\n        let currentId = commitId;\n        while(currentId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Check if this commit affects the column\n            const affectsColumn = commit.changes.some((change)=>{\n                if (change.type === \"SCHEMA\" && change.target === tableName) {\n                    const schemaChange = change;\n                    return schemaChange.columnChanges?.some((cc)=>cc.columnName === columnName);\n                }\n                return false;\n            });\n            if (affectsColumn) {\n                commits.push(commit);\n            }\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits.reverse();\n    }\n    async buildBlameLines(target, commits) {\n        const lines = [];\n        for(let i = 0; i < commits.length; i++){\n            const commit = commits[i];\n            const age = Math.floor((Date.now() - commit.timestamp.getTime()) / (1000 * 60 * 60 * 24));\n            const line = {\n                lineNumber: i + 1,\n                content: commit.changes[0]?.description || \"\",\n                commit,\n                author: commit.author,\n                age\n            };\n            lines.push(line);\n        }\n        return lines;\n    }\n    /**\n     * Get summary of who contributed to a table\n     */ async getContributors(tableName, commitId) {\n        try {\n            const commits = await this.getCommitsAffectingTable(tableName, commitId);\n            const contributorMap = new Map();\n            for (const commit of commits){\n                const authorKey = `${commit.author.name} <${commit.author.email}>`;\n                contributorMap.set(authorKey, (contributorMap.get(authorKey) || 0) + 1);\n            }\n            return {\n                success: true,\n                data: contributorMap\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get contributors: ${error}`\n            };\n        }\n    }\n}\nexports.BlameService = BlameService;\nexports[\"default\"] = BlameService; //# sourceMappingURL=BlameService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9CbGFtZVNlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFVQTs7SUFHQSxNQUFhQTtJQUdUQyxZQUFZQyxPQUE4QjtRQUN0QyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNQyxXQUNGQyxTQUFpQixFQUNqQkMsUUFBZ0IsRUFDaEJDLE9BQXNCO1FBRXRCLElBQUk7WUFDQSxNQUFNQyxVQUFVLE1BQU0sSUFBSSxDQUFDQyx3QkFBd0IsQ0FBQ0osV0FBV0M7WUFFL0QsTUFBTUksUUFBcUIsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ04sV0FBV0c7WUFFakUsTUFBTUksWUFBdUI7Z0JBQ3pCQyxPQUFPUjtnQkFDUEs7O1lBR0osT0FBTztnQkFBRUksU0FBUztnQkFBTUMsTUFBTUg7WUFBUztRQUMzQyxFQUFFLE9BQU9JLE9BQU87WUFDWixPQUFPO2dCQUFFRixTQUFTO2dCQUFPRSxPQUFPLGlCQUFpQkEsTUFBSyxDQUFFO1lBQUE7UUFDNUQ7SUFDSjtJQUVBOztRQUdBLE1BQU1DLFlBQ0ZaLFNBQWlCLEVBQ2pCYSxVQUFrQixFQUNsQlosUUFBZ0I7UUFFaEIsSUFBSTtZQUNBLE1BQU1FLFVBQVUsTUFBTSxJQUFJLENBQUNXLHlCQUF5QixDQUFDZCxXQUFXYSxZQUFZWjtZQUU1RSxNQUFNSSxRQUFxQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDLEdBQUdOLFVBQVMsR0FBSWEsV0FBVSxDQUFFLEVBQUVWO1lBRXBGLE1BQU1JLFlBQXVCO2dCQUN6QkMsT0FBT1I7Z0JBQ1BlLFFBQVFGO2dCQUNSUjs7WUFHSixPQUFPO2dCQUFFSSxTQUFTO2dCQUFNQyxNQUFNSDtZQUFTO1FBQzNDLEVBQUUsT0FBT0ksT0FBTztZQUNaLE9BQU87Z0JBQUVGLFNBQVM7Z0JBQU9FLE9BQU8saUJBQWlCQSxNQUFLLENBQUU7WUFBQTtRQUM1RDtJQUNKO0lBRVEsTUFB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O1lBQ1osT0FBTztnQkFBRUYsU0FBUztnQkFBT0UsT0FBTywrQkFBK0JBLE1BQUssQ0FBRTtZQUFBO1FBQzFFO0lBQ0o7O0FBaEtKMkMsb0JBQUEsR0FBQTFEO0FBbUtBMEQsa0JBQUEsR0FBZTFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9CbGFtZVNlcnZpY2UudHM/NzA3ZiJdLCJuYW1lcyI6WyJCbGFtZVNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInN0b3JhZ2UiLCJibGFtZVRhYmxlIiwidGFibGVOYW1lIiwiY29tbWl0SWQiLCJvcHRpb25zIiwiY29tbWl0cyIsImdldENvbW1pdHNBZmZlY3RpbmdUYWJsZSIsImxpbmVzIiwiYnVpbGRCbGFtZUxpbmVzIiwiYmxhbWVJbmZvIiwidGFibGUiLCJzdWNjZXNzIiwiZGF0YSIsImVycm9yIiwiYmxhbWVDb2x1bW4iLCJjb2x1bW5OYW1lIiwiZ2V0Q29tbWl0c0FmZmVjdGluZ0NvbHVtbiIsImNvbHVtbiIsImN1cnJlbnRJZCIsImNvbW1pdCIsImdldENvbW1pdCIsImFmZmVjdHNUYWJsZSIsImNoYW5nZXMiLCJzb21lIiwiY2hhbmdlIiwidHlwZSIsInRhcmdldCIsInB1c2giLCJwYXJlbnRJZHMiLCJyZXZlcnNlIiwiYWZmZWN0c0NvbHVtbiIsInNjaGVtYUNoYW5nZSIsImNvbHVtbkNoYW5nZXMiLCJjYyIsImkiLCJsZW5ndGgiLCJhZ2UiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwiZ2V0VGltZSIsImxpbmUiLCJsaW5lTnVtYmVyIiwiY29udGVudCIsImRlc2NyaXB0aW9uIiwiYXV0aG9yIiwiZ2V0Q29udHJpYnV0b3JzIiwiY29udHJpYnV0b3JNYXAiLCJNYXAiLCJhdXRob3JLZXkiLCJuYW1lIiwiZW1haWwiLCJzZXQiLCJnZXQiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/BlameService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/PatchService.js":
/*!****************************************************************!*\
  !*** ../../packages/version-control/dist/core/PatchService.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PatchService = void 0;\n/**\n * Patch Service - Export and import changesets\n */ class PatchService {\n    constructor(storage){\n        this.storage = storage;\n    }\n    /**\n     * Generate a patch from a commit\n     */ async generatePatch(commitId) {\n        try {\n            const commit = await this.storage.getCommit(commitId);\n            if (!commit) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const patch = await this.createPatchFromCommit(commit);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Generate patch failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Generate a patch from a range of commits\n     */ async generatePatchRange(fromCommit, toCommit) {\n        try {\n            const commits = await this.getCommitRange(fromCommit, toCommit);\n            if (commits.length === 0) {\n                return {\n                    success: false,\n                    error: \"No commits in range\"\n                };\n            }\n            const patch = await this.createPatchFromCommits(commits);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Generate patch range failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Apply a patch\n     */ async applyPatch(patch, options) {\n        try {\n            if (options?.check) {\n                // Dry run - just check if patch can be applied\n                const canApply = await this.checkPatch(patch);\n                return {\n                    success: true,\n                    data: {\n                        success: canApply,\n                        appliedPatches: canApply ? patch.commits.length : 0,\n                        failedPatches: canApply ? 0 : patch.commits.length,\n                        conflicts: []\n                    }\n                };\n            }\n            const result = await this.applyPatchInternal(patch, options);\n            return {\n                success: true,\n                data: result\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Apply patch failed: ${error}`\n            };\n        }\n    }\n    /**\n     * Export patch to formatted string\n     */ exportPatch(patch) {\n        const lines = [];\n        // Header\n        lines.push(`From ${patch.metadata?.baseCommitId || \"unknown\"} ${new Date().toISOString()}`);\n        lines.push(`From: ${patch.metadata?.createdBy || \"unknown\"}`);\n        lines.push(`Date: ${patch.metadata?.createdAt.toISOString() || new Date().toISOString()}`);\n        lines.push(`Subject: ${patch.metadata?.description || \"No description\"}`);\n        lines.push(\"\");\n        // Commits\n        for (const commit of patch.commits){\n            lines.push(`commit ${commit.id}`);\n            lines.push(`Author: ${commit.author.name} <${commit.author.email}>`);\n            lines.push(`Date: ${commit.timestamp.toISOString()}`);\n            lines.push(\"\");\n            lines.push(`    ${commit.message}`);\n            lines.push(\"\");\n            // Changes\n            for (const change of commit.changes){\n                lines.push(`    ${change.type}: ${change.description}`);\n            }\n            lines.push(\"\");\n        }\n        // Diffs\n        for (const diff of patch.diffs){\n            lines.push(`diff --git a/${diff.fromCommitId} b/${diff.toCommitId}`);\n            lines.push(`--- a/${diff.fromCommitId}`);\n            lines.push(`+++ b/${diff.toCommitId}`);\n            for (const change of diff.schemaChanges){\n                const prefix = change.operation === \"CREATE\" ? \"+\" : change.operation === \"DROP\" ? \"-\" : \" \";\n                lines.push(`${prefix} ${change.description}`);\n            }\n            for (const change of diff.dataChanges){\n                const prefix = change.operation === \"INSERT\" ? \"+\" : change.operation === \"DELETE\" ? \"-\" : \" \";\n                lines.push(`${prefix} ${change.description}`);\n            }\n            lines.push(\"\");\n        }\n        return lines.join(\"\\n\");\n    }\n    /**\n     * Import patch from formatted string\n     */ async importPatch(patchContent) {\n        try {\n            const patch = await this.parsePatch(patchContent);\n            return {\n                success: true,\n                data: patch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Import patch failed: ${error}`\n            };\n        }\n    }\n    async createPatchFromCommit(commit) {\n        const patch = {\n            id: `patch-${commit.id}`,\n            commits: [\n                commit\n            ],\n            diffs: [],\n            format: \"UNIFIED\",\n            content: \"\",\n            metadata: {\n                createdAt: new Date(),\n                createdBy: commit.author.name,\n                description: commit.message,\n                baseCommitId: commit.parentIds[0] || \"\"\n            }\n        };\n        patch.content = this.exportPatch(patch);\n        return patch;\n    }\n    async createPatchFromCommits(commits) {\n        const patch = {\n            id: `patch-${Date.now()}`,\n            commits,\n            diffs: [],\n            format: \"UNIFIED\",\n            content: \"\",\n            metadata: {\n                createdAt: new Date(),\n                createdBy: commits[0]?.author.name || \"unknown\",\n                description: `Patch from ${commits.length} commits`,\n                baseCommitId: commits[0]?.parentIds[0] || \"\"\n            }\n        };\n        patch.content = this.exportPatch(patch);\n        return patch;\n    }\n    async getCommitRange(fromCommit, toCommit) {\n        const commits = [];\n        let currentId = toCommit;\n        while(currentId && currentId !== fromCommit){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.unshift(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n    async checkPatch(patch) {\n        // Simplified check - in production would verify all changes can be applied\n        return true;\n    }\n    async applyPatchInternal(patch, options) {\n        let appliedPatches = 0;\n        let failedPatches = 0;\n        const conflicts = [];\n        for (const commit of patch.commits){\n            try {\n                // Apply commit changes\n                await this.storage.saveCommit(commit);\n                appliedPatches++;\n            } catch (error) {\n                failedPatches++;\n            }\n        }\n        return {\n            success: failedPatches === 0,\n            appliedPatches,\n            failedPatches,\n            conflicts\n        };\n    }\n    async parsePatch(content) {\n        // Simplified parser - in production would parse Git patch format\n        const lines = content.split(\"\\n\");\n        const patch = {\n            id: `patch-${Date.now()}`,\n            commits: [],\n            diffs: [],\n            format: \"UNIFIED\",\n            content\n        };\n        return patch;\n    }\n    /**\n     * Generate patch statistics\n     */ getPatchStats(patch) {\n        const affectedTables = new Set();\n        let changeCount = 0;\n        for (const commit of patch.commits){\n            changeCount += commit.changes.length;\n            for (const change of commit.changes){\n                affectedTables.add(change.target);\n            }\n        }\n        return {\n            commitCount: patch.commits.length,\n            changeCount,\n            affectedTables\n        };\n    }\n}\nexports.PatchService = PatchService;\nexports[\"default\"] = PatchService; //# sourceMappingURL=PatchService.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9QYXRjaFNlcnZpY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFXQTs7SUFHQSxNQUFhQTtJQUdUQyxZQUFZQyxPQUE4QjtRQUN0QyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFFQTs7UUFHQSxNQUFNQyxjQUFjQyxRQUFnQjtRQUNoQyxJQUFJO1lBQ0EsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLENBQUNGO1lBQzVDLElBQUksQ0FBQ0MsUUFBUTtnQkFDVCxPQUFPO29CQUFFRSxTQUFTO29CQUFPQyxPQUFPO2dCQUFrQjtZQUN0RDtZQUVBLE1BQU1DLFFBQVEsTUFBTSxJQUFJLENBQUNDLHFCQUFxQixDQUFDTDtZQUMvQyxPQUFPO2dCQUFFRSxTQUFTO2dCQUFNSSxNQUFNRjtZQUFLO1FBQ3ZDLEVBQUUsT0FBT0QsT0FBTztZQUNaLE9BQU87Z0JBQUVELFNBQVM7Z0JBQU9DLE9BQU8sMEJBQTBCQSxNQUFLLENBQUU7WUFBQTtRQUNyRTtJQUNKO0lBRUE7O1FBR0EsTUFBTUksbUJBQW1CQyxVQUFrQixFQUFFQyxRQUFnQjtRQUN6RCxJQUFJO1lBQ0EsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDSCxZQUFZQztZQUN0RCxJQUFJQyxRQUFRRSxNQUFNLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFBRVYsU0FBUztvQkFBT0MsT0FBTztnQkFBcUI7WUFDekQ7WUFFQSxNQUFNQyxRQUFRLE1BQU0sSUFBSSxDQUFDUyxzQkFBc0IsQ0FBQ0g7WUFDaEQsT0FBTztnQkFBRVIsU0FBUztnQkFBTUksTUFBTUY7WUFBSztRQUN2QyxFQUFFLE9BQU9ELE9BQU87WUFDWixPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPLGdDQUFnQ0EsTUFBSyxDQUFFO1lBQUE7UUFDM0U7SUFDSjtJQUVBOztRQUdBLE1BQU1XLFdBQ0ZWLEtBQVksRUFDWlcsT0FBc0I7UUFFdEIsSUFBSTtZQUNBLElBQUlBLFNBQVNDLE9BQU87Z0JBQ2hCLCtDQUErQztnQkFDL0MsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ0MsVUFBVSxDQUFDZDtnQkFDdkMsT0FBTztvQkFDSEYsU0FBUztvQkFDVEksTUFBTTt3QkFDRkosU0FBU2U7d0JBQ1RFLGdCQUFnQkYsV0FBV2IsTUFBTU0sT0FBTyxDQUFDRSxNQUFNLEdBQUc7d0JBQ2xEUSxlQUFlSCxXQUFXLElBQUliLE1BQU1NLE9BQU8sQ0FBQ0UsTUFBTTt3QkFDbERTLFdBQVcsRUFBRTs7O1lBR3pCO1lBRUEsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNuQixPQUFPVztZQUNwRCxPQUFPO2dCQUFFYixTQUFTO2dCQUFNSSxNQUFNZ0I7WUFBTTtRQUN4QyxFQUFFLE9BQU9uQixPQUFPO1lBQ1osT0FBTztnQkFBRUQsU0FBUztnQkFBT0MsT0FBTyx1QkFBdUJBLE1BQUssQ0FBRTtZQUFBO1FBQ2xFO0lBQ0o7SUFFQTs7UUFHQXFCLFlBQVlwQixLQUFZO1FBQ3BCLE1BQU1xQixRQUFrQixFQUFFO1FBRTFCLFNBQVM7UUFDVEEsTUFBTUMsSUFBSSxDQUFDLFFBQVF0QixNQUFNdUIsUUFBUSxFQUFFQyxnQkFBZ0IsVUFBUyxHQUFJLElBQUlDLE9BQU9DLFdBQVcsR0FBRSxDQUFFO1FBQzFGTCxNQUFNQyxJQUFJLENBQUMsU0FBU3RCLE1BQU11QixRQUFRLEVBQUVJLGFBQWEsVUFBUyxDQUFFO1FBQzVETixNQUFNQyxJQUFJLENBQUMsU0FBU3RCLE1BQU11QixRQUFRLEVBQUVLLFVBQVVGLGlCQUFpQixJQUFJRCxPQUFPQyxXQUFXLEdBQUUsQ0FBRTtRQUN6RkwsTUFBTUMsSUFBSSxDQUFDLFlBQVl0QixNQUFNdUIsUUFBUSxFQUFFTSxlQUFlLGlCQUFnQixDQUFFO1FBQ3hFUixNQUFNQyxJQUFJLENBQUM7UUFFWCxVQUFVO1FBQ1YsS0FBSyxNQUFNMUIsVUFBVUksTUFBTU0sT0FBTyxDQUFFO1lBQ2hDZSxNQUFNQyxJQUFJLENBQUMsVUFBVTFCLE9BQU9rQyxFQUFFLEVBQUU7WUFDaENULE1BQU1DLElBQUksQ0FBQyxXQUFXMUIsT0FBT21DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLcEMsT0FBT21DLE1BQU0sQ0FBQ0UsS0FBSyxHQUFHO1lBQ25FWixNQUFNQyxJQUFJLENBQUMsU0FBUzFCLE9BQU9zQyxTQUFTLENBQUNSLFdBQVcsR0FBRSxDQUFFO1lBQ3BETCxNQUFNQyxJQUFJLENBQUM7WUFDWEQsTUFBTUMsSUFBSSxDQUFDLE9BQU8xQixPQUFPdUMsT0FBTyxFQUFFO1lBQ2xDZCxNQUFNQyxJQUFJLENBQUM7WUFFWCxVQUFVO1lBQ1YsS0FBSyxNQUFNYyxVQUFVeEMsT0FBT3lDLE9BQU8sQ0FBRTtnQkFDakNoQixNQUFNQyxJQUFJLENBQUMsT0FBT2MsT0FBT0UsSUFBSSxLQUFLRixPQUFPUCxXQUFXLEVBQUU7WUFDMUQ7WUFDQVIsTUFBTUMsSUFBSSxDQUFDO1FBQ2Y7UUFFQSxRQUFRO1FBQ1IsS0FBSyxNQUFNaUIsUUFBUXZDLE1BQU13QyxLQUFLLENBQUU7WUFDNUJuQixNQUFNQyxJQUFJLENBQUMsZ0JBQWdCaUIsS0FBS0UsWUFBWSxNQUFNRixLQUFLRyxVQUFVLEVBQUU7WUFDbkVyQixNQUFNQyxJQUFJLENBQUMsU0FBU2lCLEtBQUtFLFlBQVksRUFBRTtZQUN2Q3BCLE1BQU1DLElBQUksQ0FBQyxTQUFTaUIsS0FBS0csVUFBVSxFQUFFO1lBRXJDLEtBQUssTUFBTU4sVUFBVUcsS0FBS0ksYUFBYSxDQUFFO2dCQUNyQyxNQUFNQyxTQUFTUixPQUFPUyxTQUFTLEtBQUssV0FBVyxNQUFNVCxPQUFPUyxTQUFTLEtBQUssU0FBUyxNQUFNO2dCQUN6RnhCLE1BQU1DLElBQUksQ0FBQyxHQUFHc0IsT0FBTSxHQUFJUixPQUFPUCxXQUFXLEVBQUU7WUFDaEQ7WUFFQSxLQUFLLE1BQU1PLFVBQVVHLEtBQUtPLFdBQVcsQ0FBRTtnQkFDbkMsTUFBTUYsU0FBU1IsT0FBT1MsU0FBUyxLQUFLLFdBQVcsTUFBTVQsT0FBT1MsU0FBUyxLQUFLLFdBQVcsTUFBTTtnQkFDM0Z4QixNQUFNQyxJQUFJLENBQUMsR0FBR3NCLE9BQU0sR0FBSVIsT0FBT1AsV0FBVyxFQUFFO1lBQ2hEO1lBRUFSLE1BQU1DLElBQUksQ0FBQztRQUNmO1FBRUEsT0FBT0QsTUFBTTBCLElBQUksQ0FBQztJQUN0QjtJQUVBOztRQUdBLE1BQU1DLFlBQVlDLFlBQW9CO1FBQ2xDLElBQUk7WUFDQSxNQUFNakQsUUFBUSxNQUFNLElBQUksQ0FBQ2tELFVBQVUsQ0FBQ0Q7WUFDcEMsT0FBTztnQkFBRW5ELFNBQVM7Z0JBQU1JLE1BQU1GO1lBQUs7UUFDdkMsRUFBRSxPQUFPRCxPQUFPO1lBQ1osT0FBTztnQkFBRUQsU0FBUztnQkFBT0MsT0FBTyx3QkFBd0JBLE1BQUssQ0FBRTtZQUFBO1FBQ25FO0lBQ0o7SUFFUSxNQUFNRSxzQkFBc0JMLE1BQWM7UUFDOUMsTUFBTUksUUFBZTtZQUNqQjhCLElBQUksU0FBU2xDLE9BQU9rQyxFQUFFLEVBQUU7WUFDeEJ4QixTQUFTO2dCQUFDVjthQUFPO1lBQ2pCNEMsT0FBTyxFQUFFO1lBQ1RXLFFBQVE7WUFDUkMsU0FBUztZQUNUN0IsVUFBVTtnQkFDTkssV0FBVyxJQUFJSDtnQkFDZkUsV0FBVy9CLE9BQU9tQyxNQUFNLENBQUNDLElBQUk7Z0JBQzdCSCxhQUFhakMsT0FBT3VDLE9BQU87Z0JBQzNCWCxjQUFjNUIsT0FBT3lELFNBQVMsQ0FBQyxFQUFFLElBQUk7OztRQUk3Q3JELE1BQU1vRCxPQUFPLEdBQUcsSUFBSSxDQUFDaEMsV0FBVyxDQUFDcEI7UUFDakMsT0FBT0E7SUFDWDtJQUVRLE1BQU1TLHVCQUF1QkgsT0FBaUI7UUFDbEQsTUFBTU4sUUFBZTtZQUNqQjhCLElBQUksU0FBU0wsS0FBSzZCLEdBQUcsR0FBRSxDQUFFO1lBQ3pCaEQ7WUFDQWtDLE9BQU8sRUFBRTtZQUNUVyxRQUFRO1lBQ1JDLFNBQVM7WUFDVDdCLFVBQVU7Z0JBQ05LLFdBQVcsSUFBSUg7Z0JBQ2ZFLFdBQVdyQixPQUFPLENBQUMsRUFBRSxFQUFFeUIsT0FBT0MsUUFBUTtnQkFDdENILGFBQWEsY0FBY3ZCLFFBQVFFLE1BQU0sVUFBVTtnQkFDbkRnQixjQUFjbEIsT0FBTyxDQUFDLEVBQUUsRUFBRStDLFNBQVMsQ0FBQyxFQUFFLElBQUk7OztRQUlsRHJELE1BQU1vRCxPQUFPLEdBQUcsSUFBSSxDQUFDaEMsV0FBVyxDQUFDcEI7UUFDakMsT0FBT0E7SUFDWDtJQUVRLE1BQU1PLGVBQWVILFVBQWtCLEVBQUVDLFFBQWdCO1FBQzdELE1BQU1DLFVBQW9CLEVBQUU7UUFDNUIsSUFBSWlELFlBQVlsRDtRQUVoQixNQUFPa0QsYUFBYUEsY0FBY25ELFdBQVk7WUFDMUMsTUFBTVIsU0FBUyxNQUFNLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLENBQUMwRDtZQUM1QyxJQUFJLENBQUMzRCxRQUFRO1lBQ2JVLFFBQVFrRCxPQUFPLENBQUM1RDtZQUNoQjJELFlBQVkzRCxPQUFPeUQsU0FBUyxDQUFDLEVBQUUsSUFBSTtRQUN2QztRQUVBLE9BQU8vQztJQUNYO0lBRVEsTUFBTVEsV0FBV2QsS0FBWTtRQUNqQywyRUFBMkU7UUFDM0UsT0FBTztJQUNYO0lBRVEsTUFBTW1CLG1CQUNWbkIsS0FBWSxFQUNaVyxPQUFzQjtRQUV0QixJQUFJSSxpQkFBaUI7UUFDckIsSUFBSUMsZ0JBQWdCO1FBQ3BCLE1BQU1DLFlBQW1CLEVBQUU7UUFFM0IsS0FBSyxNQUFNckIsVUFBVUksTUFBTU0sT0FBTyxDQUFFO1lBQ2hDLElBQUk7Z0JBQ0EsdUJBQXVCO2dCQUN2QixNQUFNLElBQUksQ0FBQ2IsT0FBTyxDQUFDZ0UsVUFBVSxDQUFDN0Q7Z0JBQzlCbUI7WUFDSixFQUFFLE9BQU9oQixPQUFPO2dCQUNaaUI7WUFDSjtRQUNKO1FBRUEsT0FBTztZQUNIbEIsU0FBU2tCLGtCQUFrQjtZQUMzQkQ7WUFDQUM7WUFDQUM7O0lBRVI7SUFFUSxNQUFNaUMsV0FBV0UsT0FBZTtRQUNwQyxpRUFBaUU7UUFDakUsTUFBTS9CLFFBQVErQixRQUFRTSxLQUFLLENBQUM7UUFFNUIsTUFBTTFELFFBQWU7WUFDakI4QixJQUFJLFNBQVNMLEtBQUs2QixHQUFHLEdBQUUsQ0FBRTtZQUN6QmhELFNBQVMsRUFBRTtZQUNYa0MsT0FBTyxFQUFFO1lBQ1RXLFFBQVE7WUFDUkM7O1FBR0osT0FBT3BEO0lBQ1g7SUFFQTs7UUFHQTJELGNBQWMzRCxLQUFZO1FBS3RCLE1BQU00RCxpQkFBaUIsSUFBSUM7UUFDM0IsSUFBSUMsY0FBYztRQUVsQixLQUFLLE1BQU1sRSxVQUFVSSxNQUFNTSxPQUFPLENBQUU7WUFDaEN3RCxlQUFlbEUsT0FBT3lDLE9BQU8sQ0FBQzdCLE1BQU07WUFDcEMsS0FBSyxNQUFNNEIsVUFBVXhDLE9BQU95QyxPQUFPLENBQUU7Z0JBQ2pDdUIsZUFBZUcsR0FBRyxDQUFDM0IsT0FBTzRCLE1BQU07WUFDcEM7UUFDSjtRQUVBLE9BQU87WUFDSEMsYUFBYWpFLE1BQU1NLE9BQU8sQ0FBQ0UsTUFBTTtZQUNqQ3NEO1lBQ0FGOztJQUVSOztBQTlQSk0sb0JBQUEsR0FBQTNFO0FBaVFBMkUsa0JBQUEsR0FBZTNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9QYXRjaFNlcnZpY2UudHM/NmE2ZCJdLCJuYW1lcyI6WyJQYXRjaFNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInN0b3JhZ2UiLCJnZW5lcmF0ZVBhdGNoIiwiY29tbWl0SWQiLCJjb21taXQiLCJnZXRDb21taXQiLCJzdWNjZXNzIiwiZXJyb3IiLCJwYXRjaCIsImNyZWF0ZVBhdGNoRnJvbUNvbW1pdCIsImRhdGEiLCJnZW5lcmF0ZVBhdGNoUmFuZ2UiLCJmcm9tQ29tbWl0IiwidG9Db21taXQiLCJjb21taXRzIiwiZ2V0Q29tbWl0UmFuZ2UiLCJsZW5ndGgiLCJjcmVhdGVQYXRjaEZyb21Db21taXRzIiwiYXBwbHlQYXRjaCIsIm9wdGlvbnMiLCJjaGVjayIsImNhbkFwcGx5IiwiY2hlY2tQYXRjaCIsImFwcGxpZWRQYXRjaGVzIiwiZmFpbGVkUGF0Y2hlcyIsImNvbmZsaWN0cyIsInJlc3VsdCIsImFwcGx5UGF0Y2hJbnRlcm5hbCIsImV4cG9ydFBhdGNoIiwibGluZXMiLCJwdXNoIiwibWV0YWRhdGEiLCJiYXNlQ29tbWl0SWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVkQnkiLCJjcmVhdGVkQXQiLCJkZXNjcmlwdGlvbiIsImlkIiwiYXV0aG9yIiwibmFtZSIsImVtYWlsIiwidGltZXN0YW1wIiwibWVzc2FnZSIsImNoYW5nZSIsImNoYW5nZXMiLCJ0eXBlIiwiZGlmZiIsImRpZmZzIiwiZnJvbUNvbW1pdElkIiwidG9Db21taXRJZCIsInNjaGVtYUNoYW5nZXMiLCJwcmVmaXgiLCJvcGVyYXRpb24iLCJkYXRhQ2hhbmdlcyIsImpvaW4iLCJpbXBvcnRQYXRjaCIsInBhdGNoQ29udGVudCIsInBhcnNlUGF0Y2giLCJmb3JtYXQiLCJjb250ZW50IiwicGFyZW50SWRzIiwibm93IiwiY3VycmVudElkIiwidW5zaGlmdCIsInNhdmVDb21taXQiLCJzcGxpdCIsImdldFBhdGNoU3RhdHMiLCJhZmZlY3RlZFRhYmxlcyIsIlNldCIsImNoYW5nZUNvdW50IiwiYWRkIiwidGFyZ2V0IiwiY29tbWl0Q291bnQiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/PatchService.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/VersionControlManager.js":
/*!*************************************************************************!*\
  !*** ../../packages/version-control/dist/core/VersionControlManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.VersionControlManager = void 0;\n/**\n * Main Version Control Manager\n * Implements all Git-like operations for database version control\n */ class VersionControlManager {\n    constructor(database, storage){\n        this.currentBranch = \"main\";\n        this.database = database;\n        this.storage = storage;\n    }\n    // ============ Initialization ============\n    async initialize() {\n        try {\n            // Check if already initialized by trying to get branches\n            const existingBranches = await this.storage.listBranches();\n            if (existingBranches.length > 0) {\n                await this.loadHEAD();\n                return {\n                    success: true,\n                    data: undefined\n                };\n            }\n            // Initialize repository\n            const config = {\n                HEAD: \"main\",\n                branches: {\n                    main: {\n                        name: \"main\",\n                        commitId: \"\",\n                        protected: true\n                    }\n                },\n                tags: {},\n                config: {\n                    core: {\n                        autoGc: true,\n                        logAllRefUpdates: true\n                    }\n                }\n            };\n            await this.storage.saveConfig(config);\n            // Explicitly save the main branch object to the branches directory\n            await this.storage.saveBranch({\n                name: \"main\",\n                commitId: \"\",\n                protected: true\n            });\n            this.currentBranch = \"main\"; // Sync instance state\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to initialize repository: ${error}`\n            };\n        }\n    }\n    /**\n     * Load the current branch from storage config\n     * Call this after getting an existing repo to sync instance state\n     */ async loadHEAD() {\n        try {\n            const config = await this.storage.getConfig();\n            this.currentBranch = config.HEAD || \"main\";\n        } catch  {\n            this.currentBranch = \"main\";\n        }\n    }\n    // ============ Core Commit Operations ============\n    async commit(message, author, changes, snapshot) {\n        try {\n            const config = await this.storage.getConfig();\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            const parentIds = branch.commitId ? [\n                branch.commitId\n            ] : [];\n            const commitId = this.generateCommitId();\n            const commit = {\n                id: commitId,\n                message,\n                author,\n                timestamp: new Date(),\n                parentIds,\n                treeId: commitId,\n                changes,\n                branchName: this.currentBranch\n            };\n            // Save commit and snapshot\n            await this.storage.saveCommit(commit);\n            await this.storage.saveSnapshot(commitId, snapshot);\n            // Update branch\n            branch.commitId = commitId;\n            await this.storage.saveBranch(branch);\n            // Add reflog entry\n            await this.addReflogEntry(\"COMMIT\", branch.name, parentIds[0] || \"\", commitId, `commit: ${message}`);\n            return {\n                success: true,\n                data: commit\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Commit failed: ${error}`\n            };\n        }\n    }\n    // ============ Branch Operations ============\n    async createBranch(name, fromCommit) {\n        try {\n            const branches = await this.storage.listBranches();\n            if (branches.find((b)=>b.name === name)) {\n                return {\n                    success: false,\n                    error: `Branch ${name} already exists`\n                };\n            }\n            const currentBranch = await this.storage.getBranch(this.currentBranch);\n            const commitId = fromCommit || currentBranch?.commitId || \"\";\n            const branch = {\n                name,\n                commitId,\n                protected: false\n            };\n            await this.storage.saveBranch(branch);\n            return {\n                success: true,\n                data: branch\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to create branch: ${error}`\n            };\n        }\n    }\n    async checkout(branchName) {\n        try {\n            const branch = await this.storage.getBranch(branchName);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: `Branch ${branchName} not found`\n                };\n            }\n            const oldBranch = this.currentBranch;\n            const oldCommit = (await this.storage.getBranch(oldBranch))?.commitId || \"\";\n            this.currentBranch = branchName;\n            const config = await this.storage.getConfig();\n            config.HEAD = branchName;\n            await this.storage.saveConfig(config);\n            await this.addReflogEntry(\"CHECKOUT\", branchName, oldCommit, branch.commitId, `checkout: moving from ${oldBranch} to ${branchName}`);\n            // Handle branches with no commits yet (empty commitId)\n            if (!branch.commitId) {\n                return {\n                    success: true,\n                    data: null\n                }; // No snapshot, but checkout succeeded\n            }\n            const snapshot = await this.storage.getSnapshot(branch.commitId);\n            // Snapshot might not exist for new branches - that's OK\n            return {\n                success: true,\n                data: snapshot || null\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Checkout failed: ${error}`\n            };\n        }\n    }\n    async deleteBranch(name, force = false) {\n        try {\n            if (name === this.currentBranch) {\n                return {\n                    success: false,\n                    error: \"Cannot delete current branch\"\n                };\n            }\n            const branch = await this.storage.getBranch(name);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: `Branch ${name} not found`\n                };\n            }\n            if (branch.protected && !force) {\n                return {\n                    success: false,\n                    error: `Branch ${name} is protected`\n                };\n            }\n            await this.storage.deleteBranch(name);\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to delete branch: ${error}`\n            };\n        }\n    }\n    async listBranches() {\n        try {\n            const branches = await this.storage.listBranches();\n            return {\n                success: true,\n                data: branches\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list branches: ${error}`\n            };\n        }\n    }\n    // ============ Tag Operations ============\n    async createTag(name, commitId, message, tagger) {\n        try {\n            const existingTag = await this.storage.getTag(name);\n            if (existingTag) {\n                return {\n                    success: false,\n                    error: `Tag ${name} already exists`\n                };\n            }\n            const tag = {\n                name,\n                commitId,\n                type: message ? \"ANNOTATED\" : \"LIGHTWEIGHT\",\n                message,\n                tagger,\n                createdAt: new Date()\n            };\n            await this.storage.saveTag(tag);\n            return {\n                success: true,\n                data: tag\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to create tag: ${error}`\n            };\n        }\n    }\n    async deleteTag(name) {\n        try {\n            await this.storage.deleteTag(name);\n            return {\n                success: true,\n                data: undefined\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to delete tag: ${error}`\n            };\n        }\n    }\n    async listTags(filter) {\n        try {\n            const tags = await this.storage.listTags(filter);\n            return {\n                success: true,\n                data: tags\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list tags: ${error}`\n            };\n        }\n    }\n    async checkoutTag(tagName) {\n        try {\n            const tag = await this.storage.getTag(tagName);\n            if (!tag) {\n                return {\n                    success: false,\n                    error: `Tag ${tagName} not found`\n                };\n            }\n            const snapshot = await this.storage.getSnapshot(tag.commitId);\n            if (!snapshot) {\n                return {\n                    success: false,\n                    error: \"Snapshot not found\"\n                };\n            }\n            await this.addReflogEntry(\"CHECKOUT\", \"HEAD\", \"\", tag.commitId, `checkout: checking out tag ${tagName}`);\n            return {\n                success: true,\n                data: snapshot\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to checkout tag: ${error}`\n            };\n        }\n    }\n    // ============ Stash Operations ============\n    async stash(message, author, changes, options) {\n        try {\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            const stash = {\n                id: this.generateStashId(),\n                message: message || `WIP on ${this.currentBranch}`,\n                branchName: this.currentBranch,\n                parentCommitId: branch.commitId,\n                changes,\n                author,\n                createdAt: new Date()\n            };\n            await this.storage.saveStash(stash);\n            return {\n                success: true,\n                data: stash\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash failed: ${error}`\n            };\n        }\n    }\n    async stashPop() {\n        try {\n            const stashes = await this.storage.listStashes();\n            if (stashes.length === 0) {\n                return {\n                    success: false,\n                    error: \"No stashes found\"\n                };\n            }\n            const latestStash = stashes[stashes.length - 1];\n            await this.storage.deleteStash(latestStash.id);\n            return {\n                success: true,\n                data: latestStash.changes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash pop failed: ${error}`\n            };\n        }\n    }\n    async stashApply(stashId) {\n        try {\n            let stash;\n            if (stashId) {\n                stash = await this.storage.getStash(stashId);\n            } else {\n                const stashes = await this.storage.listStashes();\n                stash = stashes[stashes.length - 1] || null;\n            }\n            if (!stash) {\n                return {\n                    success: false,\n                    error: \"Stash not found\"\n                };\n            }\n            return {\n                success: true,\n                data: stash.changes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Stash apply failed: ${error}`\n            };\n        }\n    }\n    async listStashes() {\n        try {\n            const stashes = await this.storage.listStashes();\n            return {\n                success: true,\n                data: stashes\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to list stashes: ${error}`\n            };\n        }\n    }\n    // ============ Merge Operations ============\n    async merge(sourceBranch, options) {\n        try {\n            const source = await this.storage.getBranch(sourceBranch);\n            const target = await this.storage.getBranch(this.currentBranch);\n            if (!source || !target) {\n                return {\n                    success: false,\n                    error: \"Branch not found\"\n                };\n            }\n            // Get commits\n            const sourceCommit = await this.storage.getCommit(source.commitId);\n            const targetCommit = target.commitId ? await this.storage.getCommit(target.commitId) : null;\n            if (!sourceCommit) {\n                return {\n                    success: false,\n                    error: \"Source commit not found\"\n                };\n            }\n            // Check for fast-forward\n            if (options?.noFastForward !== true) {\n                const canFastForward = await this.canFastForward(target.commitId, source.commitId);\n                if (canFastForward) {\n                    target.commitId = source.commitId;\n                    await this.storage.saveBranch(target);\n                    return {\n                        success: true,\n                        data: {\n                            success: true,\n                            commitId: source.commitId,\n                            conflicts: [],\n                            strategy: \"FAST_FORWARD\",\n                            message: \"Fast-forward merge\"\n                        }\n                    };\n                }\n            }\n            // Perform 3-way merge\n            const mergeResult = await this.performMerge(targetCommit, sourceCommit, options);\n            await this.addReflogEntry(\"MERGE\", this.currentBranch, target.commitId, mergeResult.commitId || \"\", `merge ${sourceBranch}: ${mergeResult.message}`);\n            return {\n                success: true,\n                data: mergeResult\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Merge failed: ${error}`\n            };\n        }\n    }\n    async performMerge(targetCommit, sourceCommit, options) {\n        // Simplified merge implementation\n        // In production, would implement proper 3-way merge algorithm\n        const conflicts = await this.detectConflicts(targetCommit, sourceCommit);\n        if (conflicts.length > 0 && !options?.allowConflicts) {\n            return {\n                success: false,\n                conflicts,\n                strategy: options?.strategy || \"RECURSIVE\",\n                message: \"Merge conflicts detected\"\n            };\n        }\n        // Create merge commit\n        const mergeCommit = {\n            id: this.generateCommitId(),\n            message: options?.message || `Merge branch '${sourceCommit.id}'`,\n            author: sourceCommit.author,\n            timestamp: new Date(),\n            parentIds: [\n                targetCommit?.id || \"\",\n                sourceCommit.id\n            ],\n            treeId: sourceCommit.treeId,\n            changes: sourceCommit.changes\n        };\n        await this.storage.saveCommit(mergeCommit);\n        return {\n            success: true,\n            commitId: mergeCommit.id,\n            conflicts: [],\n            strategy: options?.strategy || \"RECURSIVE\",\n            message: \"Merge successful\"\n        };\n    }\n    async detectConflicts(commit1, commit2) {\n        // Simplified conflict detection\n        return [];\n    }\n    async canFastForward(baseCommitId, targetCommitId) {\n        if (!baseCommitId) return true;\n        // Simplified: in production, would check if target is descendant of base\n        return false;\n    }\n    // ============ Cherry-Pick Operation ============\n    async cherryPick(commitId, options) {\n        try {\n            const commit = await this.storage.getCommit(commitId);\n            if (!commit) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const currentBranch = await this.storage.getBranch(this.currentBranch);\n            if (!currentBranch) {\n                return {\n                    success: false,\n                    error: \"Current branch not found\"\n                };\n            }\n            // Create new commit with same changes\n            const newCommit = {\n                id: this.generateCommitId(),\n                message: commit.message,\n                author: commit.author,\n                timestamp: new Date(),\n                parentIds: [\n                    currentBranch.commitId\n                ],\n                treeId: commit.treeId,\n                changes: commit.changes\n            };\n            await this.storage.saveCommit(newCommit);\n            if (!options?.noCommit) {\n                currentBranch.commitId = newCommit.id;\n                await this.storage.saveBranch(currentBranch);\n            }\n            await this.addReflogEntry(\"CHERRY_PICK\", this.currentBranch, currentBranch.commitId, newCommit.id, `cherry-pick: ${commit.message}`);\n            return {\n                success: true,\n                data: {\n                    success: true,\n                    newCommitId: newCommit.id,\n                    conflicts: [],\n                    skipped: false\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Cherry-pick failed: ${error}`\n            };\n        }\n    }\n    // ============ Rebase Operation ============\n    async rebase(upstreamBranch, options) {\n        try {\n            const upstream = await this.storage.getBranch(upstreamBranch);\n            const current = await this.storage.getBranch(this.currentBranch);\n            if (!upstream || !current) {\n                return {\n                    success: false,\n                    error: \"Branch not found\"\n                };\n            }\n            const commits = await this.getCommitsBetween(upstream.commitId, current.commitId);\n            const rebasedCommits = [];\n            for (const commit of commits){\n                const result = await this.cherryPick(commit.id, {\n                    noCommit: false\n                });\n                if (!result.success || !result.data.newCommitId) {\n                    return {\n                        success: false,\n                        error: \"Rebase failed during cherry-pick\"\n                    };\n                }\n                rebasedCommits.push(result.data.newCommitId);\n            }\n            await this.addReflogEntry(\"REBASE\", this.currentBranch, current.commitId, rebasedCommits[rebasedCommits.length - 1] || \"\", `rebase: onto ${upstreamBranch}`);\n            return {\n                success: true,\n                data: {\n                    success: true,\n                    newHeadCommitId: rebasedCommits[rebasedCommits.length - 1],\n                    rebasedCommits,\n                    conflicts: [],\n                    aborted: false\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Rebase failed: ${error}`\n            };\n        }\n    }\n    async getCommitsBetween(baseCommitId, headCommitId) {\n        // Simplified: in production would traverse commit graph\n        const commits = [];\n        let currentId = headCommitId;\n        while(currentId && currentId !== baseCommitId){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            commits.unshift(commit);\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n    // ============ Diff Operation ============\n    async diff(fromCommit, toCommit, options) {\n        try {\n            const from = await this.storage.getCommit(fromCommit);\n            const to = await this.storage.getCommit(toCommit);\n            if (!from || !to) {\n                return {\n                    success: false,\n                    error: \"Commit not found\"\n                };\n            }\n            const fromSnapshot = await this.storage.getSnapshot(from.treeId);\n            const toSnapshot = await this.storage.getSnapshot(to.treeId);\n            if (!fromSnapshot || !toSnapshot) {\n                return {\n                    success: false,\n                    error: \"Snapshot not found\"\n                };\n            }\n            const diff = this.computeDiff(fromSnapshot, toSnapshot);\n            return {\n                success: true,\n                data: diff\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Diff failed: ${error}`\n            };\n        }\n    }\n    computeDiff(from, to) {\n        const schemaChanges = [];\n        const dataChanges = [];\n        // Simplified diff computation\n        // In production would compare schemas and data in detail\n        return {\n            fromCommitId: \"\",\n            toCommitId: \"\",\n            schemaChanges,\n            dataChanges,\n            viewChanges: [],\n            indexChanges: [],\n            summary: {\n                filesChanged: 0,\n                insertions: 0,\n                deletions: 0,\n                modifications: 0\n            }\n        };\n    }\n    // ============ Reflog Operations ============\n    async getReflog(options) {\n        try {\n            const entries = await this.storage.getReflog(options);\n            return {\n                success: true,\n                data: entries\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get reflog: ${error}`\n            };\n        }\n    }\n    async addReflogEntry(action, ref, oldCommitId, newCommitId, message) {\n        const config = await this.storage.getConfig();\n        if (config.config.core?.logAllRefUpdates !== false) {\n            const userAuthor = config.config.user ? {\n                ...config.config.user,\n                timestamp: new Date()\n            } : {\n                name: \"System\",\n                email: \"\",\n                timestamp: new Date()\n            };\n            const entry = {\n                id: Date.now(),\n                ref,\n                oldCommitId,\n                newCommitId,\n                action,\n                message,\n                author: userAuthor,\n                timestamp: new Date()\n            };\n            await this.storage.addReflogEntry(entry);\n        }\n    }\n    // ============ Helper Methods ============\n    generateCommitId() {\n        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    generateStashId() {\n        return `stash@{${Date.now()}}`;\n    }\n    async getCurrentBranch() {\n        // Always read from storage to be accurate across requests\n        try {\n            const config = await this.storage.getConfig();\n            this.currentBranch = config.HEAD || \"main\";\n        } catch  {\n        // Keep current value if storage fails\n        }\n        return this.currentBranch;\n    }\n    async getHEAD() {\n        try {\n            const config = await this.storage.getConfig();\n            return {\n                success: true,\n                data: config.HEAD\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Failed to get HEAD: ${error}`\n            };\n        }\n    }\n    async log(options) {\n        try {\n            const branch = await this.storage.getBranch(this.currentBranch);\n            if (!branch || !branch.commitId) {\n                return {\n                    success: true,\n                    data: []\n                };\n            }\n            const commits = await this.getCommitHistory(branch.commitId, options);\n            return {\n                success: true,\n                data: commits\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: `Log failed: ${error}`\n            };\n        }\n    }\n    async getCommitHistory(commitId, options) {\n        const commits = [];\n        let currentId = commitId;\n        let count = 0;\n        const maxCount = options?.maxCount || 100;\n        while(currentId && count < maxCount){\n            const commit = await this.storage.getCommit(currentId);\n            if (!commit) break;\n            // Apply filters\n            if (options?.author && commit.author.name !== options.author) {\n                currentId = commit.parentIds[0] || \"\";\n                continue;\n            }\n            if (options?.since && commit.timestamp < options.since) break;\n            if (options?.until && commit.timestamp > options.until) {\n                currentId = commit.parentIds[0] || \"\";\n                continue;\n            }\n            commits.push(commit);\n            count++;\n            currentId = commit.parentIds[0] || \"\";\n        }\n        return commits;\n    }\n}\nexports.VersionControlManager = VersionControlManager;\nexports[\"default\"] = VersionControlManager; //# sourceMappingURL=VersionControlManager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS9WZXJzaW9uQ29udHJvbE1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFrQ0E7OztJQUlBLE1BQWFBO0lBS1RDLFlBQVlDLFFBQWdCLEVBQUVDLE9BQThCO1FBRnBELEtBQUFDLGFBQWEsR0FBVztRQUc1QixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ25CO0lBRUEsMkNBQTJDO0lBRTNDLE1BQU1FLGFBQVU7UUFDWixJQUFJO1lBQ0EseURBQXlEO1lBQ3pELE1BQU1DLG1CQUFtQixNQUFNLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxZQUFZO1lBQ3hELElBQUlELGlCQUFpQkUsTUFBTSxHQUFHLEdBQUc7Z0JBQzdCLE1BQU0sSUFBSSxDQUFDQyxRQUFRO2dCQUNuQixPQUFPO29CQUFFQyxTQUFTO29CQUFNQyxNQUFNQztnQkFBUztZQUMzQztZQUVBLHdCQUF3QjtZQUN4QixNQUFNQyxTQUErQjtnQkFDakNDLE1BQU07Z0JBQ05DLFVBQVU7b0JBQ05DLE1BQU07d0JBQ0ZDLE1BQU07d0JBQ05DLFVBQVU7d0JBQ1ZDLFdBQVc7OztnQkFHbkJDLE1BQU07Z0JBQ05QLFFBQVE7b0JBQ0pRLE1BQU07d0JBQ0ZDLFFBQVE7d0JBQ1JDLGtCQUFrQjs7OztZQUs5QixNQUFNLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ3FCLFVBQVUsQ0FBQ1g7WUFFOUIsbUVBQW1FO1lBQ25FLE1BQU0sSUFBSSxDQUFDVixPQUFPLENBQUNzQixVQUFVLENBQUM7Z0JBQzFCUixNQUFNO2dCQUNOQyxVQUFVO2dCQUNWQyxXQUFXOztZQUdmLElBQUksQ0FBQ2YsYUFBYSxHQUFHLFFBQVEsc0JBQXNCO1lBQ25ELE9BQU87Z0JBQUVNLFNBQVM7Z0JBQU1DLE1BQU1DO1lBQVM7UUFDM0MsRUFBRSxPQUFPYyxPQUFPO1lBQ1osT0FBTztnQkFDSGhCLFNBQVM7Z0JBQ1Rn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Z0ssa0JBQUEsR0FBZWhLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJvc2RiL3dlYi8uLi8uLi9zcmMvY29yZS9WZXJzaW9uQ29udHJvbE1hbmFnZXIudHM/YWYzMiJdLCJuYW1lcyI6WyJWZXJzaW9uQ29udHJvbE1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsImRhdGFiYXNlIiwic3RvcmFnZSIsImN1cnJlbnRCcmFuY2giLCJpbml0aWFsaXplIiwiZXhpc3RpbmdCcmFuY2hlcyIsImxpc3RCcmFuY2hlcyIsImxlbmd0aCIsImxvYWRIRUFEIiwic3VjY2VzcyIsImRhdGEiLCJ1bmRlZmluZWQiLCJjb25maWciLCJIRUFEIiwiYnJhbmNoZXMiLCJtYWluIiwibmFtZSIsImNvbW1pdElkIiwicHJvdGVjdGVkIiwidGFncyIsImNvcmUiLCJhdXRvR2MiLCJsb2dBbGxSZWZVcGRhdGVzIiwic2F2ZUNvbmZpZyIsInNhdmVCcmFuY2giLCJlcnJvciIsImdldENvbmZpZyIsImNvbW1pdCIsIm1lc3NhZ2UiLCJhdXRob3IiLCJjaGFuZ2VzIiwic25hcHNob3QiLCJicmFuY2giLCJnZXRCcmFuY2giLCJwYXJlbnRJZHMiLCJnZW5lcmF0ZUNvbW1pdElkIiwiaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidHJlZUlkIiwiYnJhbmNoTmFtZSIsInNhdmVDb21taXQiLCJzYXZlU25hcHNob3QiLCJhZGRSZWZsb2dFbnRyeSIsImNyZWF0ZUJyYW5jaCIsImZyb21Db21taXQiLCJmaW5kIiwiYiIsImNoZWNrb3V0Iiwib2xkQnJhbmNoIiwib2xkQ29tbWl0IiwiZ2V0U25hcHNob3QiLCJkZWxldGVCcmFuY2giLCJmb3JjZSIsImNyZWF0ZVRhZyIsInRhZ2dlciIsImV4aXN0aW5nVGFnIiwiZ2V0VGFnIiwidGFnIiwidHlwZSIsImNyZWF0ZWRBdCIsInNhdmVUYWciLCJkZWxldGVUYWciLCJsaXN0VGFncyIsImZpbHRlciIsImNoZWNrb3V0VGFnIiwidGFnTmFtZSIsInN0YXNoIiwib3B0aW9ucyIsImdlbmVyYXRlU3Rhc2hJZCIsInBhcmVudENvbW1pdElkIiwic2F2ZVN0YXNoIiwic3Rhc2hQb3AiLCJzdGFzaGVzIiwibGlzdFN0YXNoZXMiLCJsYXRlc3RTdGFzaCIsImRlbGV0ZVN0YXNoIiwic3Rhc2hBcHBseSIsInN0YXNoSWQiLCJnZXRTdGFzaCIsIm1lcmdlIiwic291cmNlQnJhbmNoIiwic291cmNlIiwidGFyZ2V0Iiwic291cmNlQ29tbWl0IiwiZ2V0Q29tbWl0IiwidGFyZ2V0Q29tbWl0Iiwibm9GYXN0Rm9yd2FyZCIsImNhbkZhc3RGb3J3YXJkIiwiY29uZmxpY3RzIiwic3RyYXRlZ3kiLCJtZXJnZVJlc3VsdCIsInBlcmZvcm1NZXJnZSIsImRldGVjdENvbmZsaWN0cyIsImFsbG93Q29uZmxpY3RzIiwibWVyZ2VDb21taXQiLCJjb21taXQxIiwiY29tbWl0MiIsImJhc2VDb21taXRJZCIsInRhcmdldENvbW1pdElkIiwiY2hlcnJ5UGljayIsIm5ld0NvbW1pdCIsIm5vQ29tbWl0IiwibmV3Q29tbWl0SWQiLCJza2lwcGVkIiwicmViYXNlIiwidXBzdHJlYW1CcmFuY2giLCJ1cHN0cmVhbSIsImN1cnJlbnQiLCJjb21taXRzIiwiZ2V0Q29tbWl0c0JldHdlZW4iLCJyZWJhc2VkQ29tbWl0cyIsInJlc3VsdCIsInB1c2giLCJuZXdIZWFkQ29tbWl0SWQiLCJhYm9ydGVkIiwiaGVhZENvbW1pdElkIiwiY3VycmVudElkIiwidW5zaGlmdCIsImRpZmYiLCJ0b0NvbW1pdCIsImZyb20iLCJ0byIsImZyb21TbmFwc2hvdCIsInRvU25hcHNob3QiLCJjb21wdXRlRGlmZiIsInNjaGVtYUNoYW5nZXMiLCJkYXRhQ2hhbmdlcyIsImZyb21Db21taXRJZCIsInRvQ29tbWl0SWQiLCJ2aWV3Q2hhbmdlcyIsImluZGV4Q2hhbmdlcyIsInN1bW1hcnkiLCJmaWxlc0NoYW5nZWQiLCJpbnNlcnRpb25zIiwiZGVsZXRpb25zIiwibW9kaWZpY2F0aW9ucyIsImdldFJlZmxvZyIsImVudHJpZXMiLCJhY3Rpb24iLCJyZWYiLCJvbGRDb21taXRJZCIsInVzZXJBdXRob3IiLCJ1c2VyIiwiZW1haWwiLCJlbnRyeSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImdldEN1cnJlbnRCcmFuY2giLCJnZXRIRUFEIiwibG9nIiwiZ2V0Q29tbWl0SGlzdG9yeSIsImNvdW50IiwibWF4Q291bnQiLCJzaW5jZSIsInVudGlsIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/core/types.js":
/*!*********************************************************!*\
  !*** ../../packages/version-control/dist/core/types.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Core types for database version control system\n * Implements all Git-like operations for databases\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvY29yZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9jb3JlL3R5cGVzLnRzPzZiMjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/core/types.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/index.js":
/*!****************************************************!*\
  !*** ../../packages/version-control/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * BosDB Version Control System\n * Advanced Git-like version control for databases\n *\n * @module @bosdb/version-control\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FEATURES = exports.VERSION = exports.VersionControl = exports.FileStorage = exports.PatchService = exports.BisectService = exports.BlameService = exports.VersionControlManager = void 0;\nexports.createVersionControl = createVersionControl;\n// Export all types\n__exportStar(__webpack_require__(/*! ./core/types */ \"(rsc)/../../packages/version-control/dist/core/types.js\"), exports);\n// Export core manager\nvar VersionControlManager_1 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nObject.defineProperty(exports, \"VersionControlManager\", ({\n    enumerable: true,\n    get: function() {\n        return VersionControlManager_1.VersionControlManager;\n    }\n}));\n// Export specialized services\nvar BlameService_1 = __webpack_require__(/*! ./core/BlameService */ \"(rsc)/../../packages/version-control/dist/core/BlameService.js\");\nObject.defineProperty(exports, \"BlameService\", ({\n    enumerable: true,\n    get: function() {\n        return BlameService_1.BlameService;\n    }\n}));\nvar BisectService_1 = __webpack_require__(/*! ./core/BisectService */ \"(rsc)/../../packages/version-control/dist/core/BisectService.js\");\nObject.defineProperty(exports, \"BisectService\", ({\n    enumerable: true,\n    get: function() {\n        return BisectService_1.BisectService;\n    }\n}));\nvar PatchService_1 = __webpack_require__(/*! ./core/PatchService */ \"(rsc)/../../packages/version-control/dist/core/PatchService.js\");\nObject.defineProperty(exports, \"PatchService\", ({\n    enumerable: true,\n    get: function() {\n        return PatchService_1.PatchService;\n    }\n}));\n// Export storage implementations\nvar FileStorage_1 = __webpack_require__(/*! ./storage/FileStorage */ \"(rsc)/../../packages/version-control/dist/storage/FileStorage.js\");\nObject.defineProperty(exports, \"FileStorage\", ({\n    enumerable: true,\n    get: function() {\n        return FileStorage_1.FileStorage;\n    }\n}));\n// Re-export default\nvar VersionControlManager_2 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nObject.defineProperty(exports, \"VersionControl\", ({\n    enumerable: true,\n    get: function() {\n        return __importDefault(VersionControlManager_2).default;\n    }\n}));\n/**\n * Create a new version control instance\n */ const VersionControlManager_3 = __webpack_require__(/*! ./core/VersionControlManager */ \"(rsc)/../../packages/version-control/dist/core/VersionControlManager.js\");\nfunction createVersionControl(database, storage) {\n    return new VersionControlManager_3.VersionControlManager(database, storage);\n}\n/**\n * Version information\n */ exports.VERSION = \"1.0.0\";\nexports.FEATURES = [\n    \"commits\",\n    \"branches\",\n    \"tags\",\n    \"stash\",\n    \"merge\",\n    \"cherry-pick\",\n    \"rebase\",\n    \"diff\",\n    \"blame\",\n    \"bisect\",\n    \"reflog\",\n    \"patches\"\n]; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkFBLDRCQUFBLEdBQUFDO0FBdkJBLG1CQUFtQjtBQUNuQkMsYUFBQUMsbUJBQUFBLENBQUEsZ0ZBQUFIO0FBRUEsc0JBQXNCO0FBQ3RCLElBQUFJLDBCQUFBRCxtQkFBQUEsQ0FBQTtBQUFTRSx5REFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBSix3QkFBQUsscUJBQXFCO0lBQUE7QUFBQTtBQUU5Qiw4QkFBOEI7QUFDOUIsSUFBQUMsaUJBQUFQLG1CQUFBQSxDQUFBO0FBQVNFLGdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BQUFFLGVBQUFDLFlBQVk7SUFBQTtBQUFBO0FBQ3JCLElBQUFDLGtCQUFBVCxtQkFBQUEsQ0FBQTtBQUFTRSxpREFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBSSxnQkFBQUMsYUFBYTtJQUFBO0FBQUE7QUFDdEIsSUFBQUMsaUJBQUFYLG1CQUFBQSxDQUFBO0FBQVNFLGdEQUFBO0lBQUFFLFlBQUE7SUFBQUMsS0FBQTtRQUFBLE9BQUFNLGVBQUFDLFlBQVk7SUFBQTtBQUFBO0FBRXJCLGlDQUFpQztBQUNqQyxJQUFBQyxnQkFBQWIsbUJBQUFBLENBQUE7QUFBU0UsK0NBQUE7SUFBQUUsWUFBQTtJQUFBQyxLQUFBO1FBQUEsT0FBQVEsY0FBQUMsV0FBVztJQUFBO0FBQUE7QUFFcEIsb0JBQW9CO0FBQ3BCLElBQUFDLDBCQUFBZixtQkFBQUEsQ0FBQTtBQUFTRSxrREFBQTtJQUFBRSxZQUFBO0lBQUFDLEtBQUE7UUFBQSxPQUFBVyxnQkFBQUQseUJBQUFFLE9BQU87SUFBQTtBQUFBO0FBRWhCOztJQUdBLE1BQUFDLDBCQUFBbEIsbUJBQUFBLENBQUE7QUFHQSxTQUFnQkYscUJBQ1pxQixRQUFnQixFQUNoQkMsT0FBOEI7SUFFOUIsT0FBTyxJQUFJRix3QkFBQVoscUJBQXFCLENBQUNhLFVBQVVDO0FBQy9DO0FBRUE7O0lBR2F2QixlQUFPLEdBQUc7QUFDVkEsZ0JBQVEsR0FBRztJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDTSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bib3NkYi93ZWIvLi4vc3JjL2luZGV4LnRzPzUyZDUiXSwibmFtZXMiOlsiZXhwb3J0cyIsImNyZWF0ZVZlcnNpb25Db250cm9sIiwiX19leHBvcnRTdGFyIiwicmVxdWlyZSIsIlZlcnNpb25Db250cm9sTWFuYWdlcl8xIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiVmVyc2lvbkNvbnRyb2xNYW5hZ2VyIiwiQmxhbWVTZXJ2aWNlXzEiLCJCbGFtZVNlcnZpY2UiLCJCaXNlY3RTZXJ2aWNlXzEiLCJCaXNlY3RTZXJ2aWNlIiwiUGF0Y2hTZXJ2aWNlXzEiLCJQYXRjaFNlcnZpY2UiLCJGaWxlU3RvcmFnZV8xIiwiRmlsZVN0b3JhZ2UiLCJWZXJzaW9uQ29udHJvbE1hbmFnZXJfMiIsIl9faW1wb3J0RGVmYXVsdCIsImRlZmF1bHQiLCJWZXJzaW9uQ29udHJvbE1hbmFnZXJfMyIsImRhdGFiYXNlIiwic3RvcmFnZSIsIlZFUlNJT04iLCJGRUFUVVJFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../packages/version-control/dist/storage/FileStorage.js":
/*!******************************************************************!*\
  !*** ../../packages/version-control/dist/storage/FileStorage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function() {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function(o) {\n            var ar = [];\n            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function(mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) {\n            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FileStorage = void 0;\nconst fs = __importStar(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\n/**\n * File-based storage implementation for version control\n */ class FileStorage {\n    constructor(baseDir){\n        this.baseDir = baseDir;\n        this.commitsDir = path.join(baseDir, \"commits\");\n        this.branchesDir = path.join(baseDir, \"branches\");\n        this.tagsDir = path.join(baseDir, \"tags\");\n        this.stashDir = path.join(baseDir, \"stash\");\n        this.reflogDir = path.join(baseDir, \"reflog\");\n        this.snapshotsDir = path.join(baseDir, \"snapshots\");\n        this.configFile = path.join(baseDir, \"config.json\");\n    }\n    async initialize() {\n        await fs.mkdir(this.commitsDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.branchesDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.tagsDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.stashDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.reflogDir, {\n            recursive: true\n        });\n        await fs.mkdir(this.snapshotsDir, {\n            recursive: true\n        });\n        // Only create default config if it doesn't already exist\n        try {\n            await fs.access(this.configFile);\n        } catch  {\n            const defaultConfig = {\n                HEAD: \"main\",\n                branches: {},\n                tags: {},\n                config: {}\n            };\n            await this.saveConfig(defaultConfig);\n        }\n    }\n    // Commit operations\n    async saveCommit(commit) {\n        const filePath = path.join(this.commitsDir, `${commit.id}.json`);\n        await fs.writeFile(filePath, JSON.stringify(commit, null, 2));\n    }\n    async getCommit(id) {\n        try {\n            const filePath = path.join(this.commitsDir, `${id}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const commit = JSON.parse(content);\n            // Convert timestamp strings back to Date objects\n            commit.timestamp = new Date(commit.timestamp);\n            commit.author.timestamp = new Date(commit.author.timestamp);\n            return commit;\n        } catch  {\n            return null;\n        }\n    }\n    async getCommits(ids) {\n        const commits = [];\n        for (const id of ids){\n            const commit = await this.getCommit(id);\n            if (commit) commits.push(commit);\n        }\n        return commits;\n    }\n    // Branch operations\n    async saveBranch(branch) {\n        const filePath = path.join(this.branchesDir, `${branch.name}.json`);\n        await fs.writeFile(filePath, JSON.stringify(branch, null, 2));\n    }\n    async getBranch(name) {\n        try {\n            const filePath = path.join(this.branchesDir, `${name}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            return JSON.parse(content);\n        } catch  {\n            return null;\n        }\n    }\n    async listBranches() {\n        try {\n            const files = await fs.readdir(this.branchesDir);\n            const branches = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const name = file.replace(\".json\", \"\");\n                    const branch = await this.getBranch(name);\n                    if (branch) branches.push(branch);\n                }\n            }\n            return branches;\n        } catch  {\n            return [];\n        }\n    }\n    async deleteBranch(name) {\n        const filePath = path.join(this.branchesDir, `${name}.json`);\n        await fs.unlink(filePath);\n    }\n    // Tag operations\n    async saveTag(tag) {\n        const filePath = path.join(this.tagsDir, `${tag.name}.json`);\n        await fs.writeFile(filePath, JSON.stringify(tag, null, 2));\n    }\n    async getTag(name) {\n        try {\n            const filePath = path.join(this.tagsDir, `${name}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const tag = JSON.parse(content);\n            tag.createdAt = new Date(tag.createdAt);\n            if (tag.tagger) tag.tagger.timestamp = new Date(tag.tagger.timestamp);\n            return tag;\n        } catch  {\n            return null;\n        }\n    }\n    async listTags(filter) {\n        try {\n            const files = await fs.readdir(this.tagsDir);\n            const tags = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const name = file.replace(\".json\", \"\");\n                    const tag = await this.getTag(name);\n                    if (tag && this.matchesTagFilter(tag, filter)) {\n                        tags.push(tag);\n                    }\n                }\n            }\n            return tags.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n        } catch  {\n            return [];\n        }\n    }\n    async deleteTag(name) {\n        const filePath = path.join(this.tagsDir, `${name}.json`);\n        await fs.unlink(filePath);\n    }\n    matchesTagFilter(tag, filter) {\n        if (!filter) return true;\n        if (filter.pattern && !tag.name.includes(filter.pattern)) return false;\n        if (filter.afterDate && tag.createdAt < filter.afterDate) return false;\n        if (filter.beforeDate && tag.createdAt > filter.beforeDate) return false;\n        if (filter.annotatedOnly && tag.type !== \"ANNOTATED\") return false;\n        return true;\n    }\n    // Stash operations\n    async saveStash(stash) {\n        const filePath = path.join(this.stashDir, `${stash.id}.json`);\n        await fs.writeFile(filePath, JSON.stringify(stash, null, 2));\n    }\n    async getStash(id) {\n        try {\n            const filePath = path.join(this.stashDir, `${id}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const stash = JSON.parse(content);\n            stash.createdAt = new Date(stash.createdAt);\n            stash.author.timestamp = new Date(stash.author.timestamp);\n            return stash;\n        } catch  {\n            return null;\n        }\n    }\n    async listStashes() {\n        try {\n            const files = await fs.readdir(this.stashDir);\n            const stashes = [];\n            for (const file of files){\n                if (file.endsWith(\".json\")) {\n                    const id = file.replace(\".json\", \"\");\n                    const stash = await this.getStash(id);\n                    if (stash) stashes.push(stash);\n                }\n            }\n            return stashes.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n        } catch  {\n            return [];\n        }\n    }\n    async deleteStash(id) {\n        const filePath = path.join(this.stashDir, `${id}.json`);\n        await fs.unlink(filePath);\n    }\n    // Reflog operations\n    async addReflogEntry(entry) {\n        const filePath = path.join(this.reflogDir, `reflog.jsonl`);\n        const line = JSON.stringify(entry) + \"\\n\";\n        await fs.appendFile(filePath, line);\n    }\n    async getReflog(options) {\n        try {\n            const filePath = path.join(this.reflogDir, `reflog.jsonl`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const lines = content.trim().split(\"\\n\").filter((l)=>l);\n            let entries = lines.map((line)=>{\n                const entry = JSON.parse(line);\n                entry.timestamp = new Date(entry.timestamp);\n                entry.author.timestamp = new Date(entry.author.timestamp);\n                return entry;\n            });\n            // Apply filters\n            if (options?.refName) {\n                entries = entries.filter((e)=>e.ref === options.refName);\n            }\n            if (options?.since) {\n                entries = entries.filter((e)=>e.timestamp >= options.since);\n            }\n            if (options?.until) {\n                entries = entries.filter((e)=>e.timestamp <= options.until);\n            }\n            if (options?.maxCount) {\n                entries = entries.slice(-options.maxCount);\n            }\n            return entries.reverse();\n        } catch  {\n            return [];\n        }\n    }\n    // Snapshot operations\n    async saveSnapshot(commitId, snapshot) {\n        const filePath = path.join(this.snapshotsDir, `${commitId}.json`);\n        await fs.writeFile(filePath, JSON.stringify(snapshot, null, 2));\n    }\n    async getSnapshot(commitId) {\n        try {\n            const filePath = path.join(this.snapshotsDir, `${commitId}.json`);\n            const content = await fs.readFile(filePath, \"utf-8\");\n            const snapshot = JSON.parse(content);\n            snapshot.timestamp = new Date(snapshot.timestamp);\n            return snapshot;\n        } catch  {\n            return null;\n        }\n    }\n    // Config operations\n    async getConfig() {\n        try {\n            const content = await fs.readFile(this.configFile, \"utf-8\");\n            return JSON.parse(content);\n        } catch  {\n            return {\n                HEAD: \"main\",\n                branches: {},\n                tags: {},\n                config: {}\n            };\n        }\n    }\n    async saveConfig(config) {\n        await fs.writeFile(this.configFile, JSON.stringify(config, null, 2));\n    }\n}\nexports.FileStorage = FileStorage;\nexports[\"default\"] = FileStorage; //# sourceMappingURL=FileStorage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vcGFja2FnZXMvdmVyc2lvbi1jb250cm9sL2Rpc3Qvc3RvcmFnZS9GaWxlU3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxLQUFBQyxhQUFBQyxtQkFBQUEsQ0FBQTtBQUNBLE1BQUFDLE9BQUFGLGFBQUFDLG1CQUFBQSxDQUFBO0FBY0E7O0lBR0EsTUFBYUU7SUFVVEMsWUFBWUMsT0FBZTtRQUN2QixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0osS0FBS0ssSUFBSSxDQUFDRixTQUFTO1FBQ3JDLElBQUksQ0FBQ0csV0FBVyxHQUFHTixLQUFLSyxJQUFJLENBQUNGLFNBQVM7UUFDdEMsSUFBSSxDQUFDSSxPQUFPLEdBQUdQLEtBQUtLLElBQUksQ0FBQ0YsU0FBUztRQUNsQyxJQUFJLENBQUNLLFFBQVEsR0FBR1IsS0FBS0ssSUFBSSxDQUFDRixTQUFTO1FBQ25DLElBQUksQ0FBQ00sU0FBUyxHQUFHVCxLQUFLSyxJQUFJLENBQUNGLFNBQVM7UUFDcEMsSUFBSSxDQUFDTyxZQUFZLEdBQUdWLEtBQUtLLElBQUksQ0FBQ0YsU0FBUztRQUN2QyxJQUFJLENBQUNRLFVBQVUsR0FBR1gsS0FBS0ssSUFBSSxDQUFDRixTQUFTO0lBQ3pDO0lBRUEsTUFBTVMsYUFBVTtRQUNaLE1BQU1mLEdBQUdnQixLQUFLLENBQUMsSUFBSSxDQUFDVCxVQUFVLEVBQUU7WUFBRVUsV0FBVztRQUFJO1FBQ2pELE1BQU1qQixHQUFHZ0IsS0FBSyxDQUFDLElBQUksQ0FBQ1AsV0FBVyxFQUFFO1lBQUVRLFdBQVc7UUFBSTtRQUNsRCxNQUFNakIsR0FBR2dCLEtBQUssQ0FBQyxJQUFJLENBQUNOLE9BQU8sRUFBRTtZQUFFTyxXQUFXO1FBQUk7UUFDOUMsTUFBTWpCLEdBQUdnQixLQUFLLENBQUMsSUFBSSxDQUFDTCxRQUFRLEVBQUU7WUFBRU0sV0FBVztRQUFJO1FBQy9DLE1BQU1qQixHQUFHZ0IsS0FBSyxDQUFDLElBQUksQ0FBQ0osU0FBUyxFQUFFO1lBQUVLLFdBQVc7UUFBSTtRQUNoRCxNQUFNakIsR0FBR2dCLEtBQUssQ0FBQyxJQUFJLENBQUNILFlBQVksRUFBRTtZQUFFSSxXQUFXO1FBQUk7UUFFbkQseURBQXlEO1FBQ3pELElBQUk7WUFDQSxNQUFNakIsR0FBR2tCLE1BQU0sQ0FBQyxJQUFJLENBQUNKLFVBQVU7UUFDbkMsRUFBRSxPQUFNO1lBQ0osTUFBTUssZ0JBQXNDO2dCQUN4Q0MsTUFBTTtnQkFDTkMsVUFBVTtnQkFDVkMsTUFBTTtnQkFDTkMsUUFBUTs7WUFFWixNQUFNLElBQUksQ0FBQ0MsVUFBVSxDQUFDTDtRQUMxQjtJQUNKO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1NLFdBQVdDLE1BQWM7UUFDM0IsTUFBTUMsV0FBV3hCLEtBQUtLLElBQUksQ0FBQyxJQUFJLENBQUNELFVBQVUsRUFBRSxHQUFHbUIsT0FBT0UsRUFBRSxPQUFPO1FBQy9ELE1BQU01QixHQUFHNkIsU0FBUyxDQUFDRixVQUFVRyxLQUFLQyxTQUFTLENBQUNMLFFBQVEsTUFBTTtJQUM5RDtJQUVBLE1BQU1NLFVBQVVKLEVBQVU7UUFDdEIsSUFBSTtZQUNBLE1BQU1ELFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUUsR0FBR3FCLEdBQUUsTUFBTztZQUN4RCxNQUFNSyxVQUFVLE1BQU1qQyxHQUFHa0MsUUFBUSxDQUFDUCxVQUFVO1lBQzVDLE1BQU1ELFNBQVNJLEtBQUtLLEtBQUssQ0FBQ0Y7WUFDMUIsaURBQWlEO1lBQ2pEUCxPQUFPVSxTQUFTLEdBQUcsSUFBSUMsS0FBS1gsT0FBT1UsU0FBUztZQUM1Q1YsT0FBT1ksTUFBTSxDQUFDRixTQUFTLEdBQUcsSUFBSUMsS0FBS1gsT0FBT1ksTUFBTSxDQUFDRixTQUFTO1lBQzFELE9BQU9WO1FBQ1gsRUFBRSxPQUFNO1lBQ0osT0FBTztRQUNYO0lBQ0o7SUFFQSxNQUFNYSxXQUFXQyxHQUFhO1FBQzFCLE1BQU1DLFVBQW9CLEVBQUU7UUFDNUIsS0FBSyxNQUFNYixNQUFNWSxJQUFLO1lBQ2xCLE1BQU1kLFNBQVMsTUFBTSxJQUFJLENBQUNNLFNBQVMsQ0FBQ0o7WUFDcEMsSUFBSUYsUUFBUWUsUUFBUUMsSUFBSSxDQUFDaEI7UUFDN0I7UUFDQSxPQUFPZTtJQUNYO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1FLFdBQVdDLE1BQWM7UUFDM0IsTUFBTWpCLFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDQyxXQUFXLEVBQUUsR0FBR21DLE9BQU9DLElBQUksT0FBTztRQUNsRSxNQUFNN0MsR0FBRzZCLFNBQVMsQ0FBQ0YsVUFBVUcsS0FBS0MsU0FBUyxDQUFDYSxRQUFRLE1BQU07SUFDOUQ7SUFFQSxNQUFNRSxVQUFVRCxJQUFZO1FBQ3hCLElBQUk7WUFDQSxNQUFNbEIsV0FBV3hCLEtBQUtLLElBQUksQ0FBQyxJQUFJLENBQUNDLFdBQVcsRUFBRSxHQUFHb0MsS0FBSSxNQUFPO1lBQzNELE1BQU1aLFVBQVUsTUFBTWpDLEdBQUdrQyxRQUFRLENBQUNQLFVBQVU7WUFDNUMsT0FBT0csS0FBS0ssS0FBSyxDQUFDRjtRQUN0QixFQUFFLE9BQU07WUFDSixPQUFPO1FBQ1g7SUFDSjtJQUVBLE1BQU1jLGVBQVk7UUFDZCxJQUFJO1lBQ0EsTUFBTUMsUUFBUSxNQUFNaEQsR0FBR2lELE9BQU8sQ0FBQyxJQUFJLENBQUN4QyxXQUFXO1lBQy9DLE1BQU1ZLFdBQXFCLEVBQUU7WUFDN0IsS0FBSyxNQUFNNkIsUUFBUUYsTUFBTztnQkFDdEIsSUFBSUUsS0FBS0MsUUFBUSxDQUFDLFVBQVU7b0JBQ3hCLE1BQU1OLE9BQU9LLEtBQUtFLE9BQU8sQ0FBQyxTQUFTO29CQUNuQyxNQUFNUixTQUFTLE1BQU0sSUFBSSxDQUFDRSxTQUFTLENBQUNEO29CQUNwQyxJQUFJRCxRQUFRdkIsU0FBU3FCLElBQUksQ0FBQ0U7Z0JBQzlCO1lBQ0o7WUFDQSxPQUFPdkI7UUFDWCxFQUFFLE9BQU07WUFDSixPQUFPLEVBQUU7UUFDYjtJQUNKO0lBRUEsTUFBTWdDLGFBQWFSLElBQVk7UUFDM0IsTUFBTWxCLFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDQyxXQUFXLEVBQUUsR0FBR29DLEtBQUksTUFBTztRQUMzRCxNQUFNN0MsR0FBR3NELE1BQU0sQ0FBQzNCO0lBQ3BCO0lBRUEsaUJBQWlCO0lBQ2pCLE1BQU00QixRQUFRQyxHQUFRO1FBQ2xCLE1BQU03QixXQUFXeEIsS0FBS0ssSUFBSSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUc4QyxJQUFJWCxJQUFJLE9BQU87UUFDM0QsTUFBTTdDLEdBQUc2QixTQUFTLENBQUNGLFVBQVVHLEtBQUtDLFNBQVMsQ0FBQ3lCLEtBQUssTUFBTTtJQUMzRDtJQUVBLE1BQU1DLE9BQU9aLElBQVk7UUFDckIsSUFBSTtZQUNBLE1BQU1sQixXQUFXeEIsS0FBS0ssSUFBSSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdtQyxLQUFJLE1BQU87WUFDdkQsTUFBTVosVUFBVSxNQUFNakMsR0FBR2tDLFFBQVEsQ0FBQ1AsVUFBVTtZQUM1QyxNQUFNNkIsTUFBTTFCLEtBQUtLLEtBQUssQ0FBQ0Y7WUFDdkJ1QixJQUFJRSxTQUFTLEdBQUcsSUFBSXJCLEtBQUttQixJQUFJRSxTQUFTO1lBQ3RDLElBQUlGLElBQUlHLE1BQU0sRUFBRUgsSUFBSUcsTUFBTSxDQUFDdkIsU0FBUyxHQUFHLElBQUlDLEtBQUttQixJQUFJRyxNQUFNLENBQUN2QixTQUFTO1lBQ3BFLE9BQU9vQjtRQUNYLEVBQUUsT0FBTTtZQUNKLE9BQU87UUFDWDtJQUNKO0lBRUEsTUFBTUksU0FBU0MsTUFBa0I7UUFDN0IsSUFBSTtZQUNBLE1BQU1iLFFBQVEsTUFBTWhELEdBQUdpRCxPQUFPLENBQUMsSUFBSSxDQUFDdkMsT0FBTztZQUMzQyxNQUFNWSxPQUFjLEVBQUU7WUFDdEIsS0FBSyxNQUFNNEIsUUFBUUYsTUFBTztnQkFDdEIsSUFBSUUsS0FBS0MsUUFBUSxDQUFDLFVBQVU7b0JBQ3hCLE1BQU1OLE9BQU9LLEtBQUtFLE9BQU8sQ0FBQyxTQUFTO29CQUNuQyxNQUFNSSxNQUFNLE1BQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNaO29CQUM5QixJQUFJVyxPQUFPLElBQUksQ0FBQ00sZ0JBQWdCLENBQUNOLEtBQUtLLFNBQVM7d0JBQzNDdkMsS0FBS29CLElBQUksQ0FBQ2M7b0JBQ2Q7Z0JBQ0o7WUFDSjtZQUNBLE9BQU9sQyxLQUFLeUMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVQLFNBQVMsQ0FBQ1EsT0FBTyxLQUFLRixFQUFFTixTQUFTLENBQUNRLE9BQU87UUFDMUUsRUFBRSxPQUFNO1lBQ0osT0FBTyxFQUFFO1FBQ2I7SUFDSjtJQUVBLE1BQU1DLFVBQVV0QixJQUFZO1FBQ3hCLE1BQU1sQixXQUFXeEIsS0FBS0ssSUFBSSxDQUFDLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdtQyxLQUFJLE1BQU87UUFDdkQsTUFBTTdDLEdBQUdzRCxNQUFNLENBQUMzQjtJQUNwQjtJQUVRbUMsaUJBQWlCTixHQUFRLEVBQUVLLE1BQWtCO1FBQ2pELElBQUksQ0FBQ0EsUUFBUSxPQUFPO1FBRXBCLElBQUlBLE9BQU9PLE9BQU8sSUFBSSxDQUFDWixJQUFJWCxJQUFJLENBQUN3QixRQUFRLENBQUNSLE9BQU9PLE9BQU8sR0FBRyxPQUFPO1FBQ2pFLElBQUlQLE9BQU9TLFNBQVMsSUFBSWQsSUFBSUUsU0FBUyxHQUFHRyxPQUFPUyxTQUFTLEVBQUUsT0FBTztRQUNqRSxJQUFJVCxPQUFPVSxVQUFVLElBQUlmLElBQUlFLFNBQVMsR0FBR0csT0FBT1UsVUFBVSxFQUFFLE9BQU87UUFDbkUsSUFBSVYsT0FBT1csYUFBYSxJQUFJaEIsSUFBSWlCLElBQUksS0FBSyxhQUFhLE9BQU87UUFFN0QsT0FBTztJQUNYO0lBRUEsbUJBQW1CO0lBQ25CLE1BQU1DLFVBQVVDLEtBQVk7UUFDeEIsTUFBTWhELFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDRyxRQUFRLEVBQUUsR0FBR2dFLE1BQU0vQyxFQUFFLE9BQU87UUFDNUQsTUFBTTVCLEdBQUc2QixTQUFTLENBQUNGLFVBQVVHLEtBQUtDLFNBQVMsQ0FBQzRDLE9BQU8sTUFBTTtJQUM3RDtJQUVBLE1BQU1DLFNBQVNoRCxFQUFVO1FBQ3JCLElBQUk7WUFDQSxNQUFNRCxXQUFXeEIsS0FBS0ssSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxFQUFFLEdBQUdpQixHQUFFLE1BQU87WUFDdEQsTUFBTUssVUFBVSxNQUFNakMsR0FBR2tDLFFBQVEsQ0FBQ1AsVUFBVTtZQUM1QyxNQUFNZ0QsUUFBUTdDLEtBQUtLLEtBQUssQ0FBQ0Y7WUFDekIwQyxNQUFNakIsU0FBUyxHQUFHLElBQUlyQixLQUFLc0MsTUFBTWpCLFNBQVM7WUFDMUNpQixNQUFNckMsTUFBTSxDQUFDRixTQUFTLEdBQUcsSUFBSUMsS0FBS3NDLE1BQU1yQyxNQUFNLENBQUNGLFNBQVM7WUFDeEQsT0FBT3VDO1FBQ1gsRUFBRSxPQUFNO1lBQ0osT0FBTztRQUNYO0lBQ0o7SUFFQSxNQUFNRSxjQUFXO1FBQ2IsSUFBSTtZQUNBLE1BQU03QixRQUFRLE1BQU1oRCxHQUFHaUQsT0FBTyxDQUFDLElBQUksQ0FBQ3RDLFFBQVE7WUFDNUMsTUFBTW1FLFVBQW1CLEVBQUU7WUFDM0IsS0FBSyxNQUFNNUIsUUFBUUYsTUFBTztnQkFDdEIsSUFBSUUsS0FBS0MsUUFBUSxDQUFDLFVBQVU7b0JBQ3hCLE1BQU12QixLQUFLc0IsS0FBS0UsT0FBTyxDQUFDLFNBQVM7b0JBQ2pDLE1BQU11QixRQUFRLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNoRDtvQkFDbEMsSUFBSStDLE9BQU9HLFFBQVFwQyxJQUFJLENBQUNpQztnQkFDNUI7WUFDSjtZQUNBLE9BQU9HLFFBQVFmLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFTixTQUFTLENBQUNRLE9BQU8sS0FBS0QsRUFBRVAsU0FBUyxDQUFDUSxPQUFPO1FBQzdFLEVBQUUsT0FBTTtZQUNKLE9BQU8sRUFBRTtRQUNiO0lBQ0o7SUFFQSxNQUFNYSxZQUFZbkQsRUFBVTtRQUN4QixNQUFNRCxXQUFXeEIsS0FBS0ssSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxFQUFFLEdBQUdpQixHQUFFLE1BQU87UUFDdEQsTUFBTTVCLEdBQUdzRCxNQUFNLENBQUMzQjtJQUNwQjtJQUVBLG9CQUFvQjtJQUNwQixNQUFNcUQsZUFBZUMsS0FBa0I7UUFDbkMsTUFBTXRELFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDSSxTQUFTLEVBQUUsY0FBYztRQUN6RCxNQUFNc0UsT0FBT3BELEtBQUtDLFNBQVMsQ0FBQ2tELFNBQVM7UUFDckMsTUFBTWpGLEdBQUdtRixVQUFVLENBQUN4RCxVQUFVdUQ7SUFDbEM7SUFFQSxNQUFNRSxVQUFVQyxPQUF1QjtRQUNuQyxJQUFJO1lBQ0EsTUFBTTFELFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDSSxTQUFTLEVBQUUsY0FBYztZQUN6RCxNQUFNcUIsVUFBVSxNQUFNakMsR0FBR2tDLFFBQVEsQ0FBQ1AsVUFBVTtZQUM1QyxNQUFNMkQsUUFBUXJELFFBQVFzRCxJQUFJLEdBQUdDLEtBQUssQ0FBQyxNQUFNM0IsTUFBTSxDQUFDNEIsQ0FBQUEsSUFBS0E7WUFFckQsSUFBSUMsVUFBeUJKLE1BQU1LLEdBQUcsQ0FBQ1QsQ0FBQUE7Z0JBQ25DLE1BQU1ELFFBQVFuRCxLQUFLSyxLQUFLLENBQUMrQztnQkFDekJELE1BQU03QyxTQUFTLEdBQUcsSUFBSUMsS0FBSzRDLE1BQU03QyxTQUFTO2dCQUMxQzZDLE1BQU0zQyxNQUFNLENBQUNGLFNBQVMsR0FBRyxJQUFJQyxLQUFLNEMsTUFBTTNDLE1BQU0sQ0FBQ0YsU0FBUztnQkFDeEQsT0FBTzZDO1lBQ1g7WUFFQSxnQkFBZ0I7WUFDaEIsSUFBSUksU0FBU08sU0FBUztnQkFDbEJGLFVBQVVBLFFBQVE3QixNQUFNLENBQUNnQyxDQUFBQSxJQUFLQSxFQUFFQyxHQUFHLEtBQUtULFFBQVFPLE9BQU87WUFDM0Q7WUFDQSxJQUFJUCxTQUFTVSxPQUFPO2dCQUNoQkwsVUFBVUEsUUFBUTdCLE1BQU0sQ0FBQ2dDLENBQUFBLElBQUtBLEVBQUV6RCxTQUFTLElBQUlpRCxRQUFRVSxLQUFNO1lBQy9EO1lBQ0EsSUFBSVYsU0FBU1csT0FBTztnQkFDaEJOLFVBQVVBLFFBQVE3QixNQUFNLENBQUNnQyxDQUFBQSxJQUFLQSxFQUFFekQsU0FBUyxJQUFJaUQsUUFBUVcsS0FBTTtZQUMvRDtZQUNBLElBQUlYLFNBQVNZLFVBQVU7Z0JBQ25CUCxVQUFVQSxRQUFRUSxLQUFLLENBQUMsQ0FBQ2IsUUFBUVksUUFBUTtZQUM3QztZQUVBLE9BQU9QLFFBQVFTLE9BQU87UUFDMUIsRUFBRSxPQUFNO1lBQ0osT0FBTyxFQUFFO1FBQ2I7SUFDSjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNQyxhQUFhQyxRQUFnQixFQUFFQyxRQUEwQjtRQUMzRCxNQUFNM0UsV0FBV3hCLEtBQUtLLElBQUksQ0FBQyxJQUFJLENBQUNLLFlBQVksRUFBRSxHQUFHd0YsU0FBUSxNQUFPO1FBQ2hFLE1BQU1yRyxHQUFHNkIsU0FBUyxDQUFDRixVQUFVRyxLQUFLQyxTQUFTLENBQUN1RSxVQUFVLE1BQU07SUFDaEU7SUFFQSxNQUFNQyxZQUFZRixRQUFnQjtRQUM5QixJQUFJO1lBQ0EsTUFBTTFFLFdBQVd4QixLQUFLSyxJQUFJLENBQUMsSUFBSSxDQUFDSyxZQUFZLEVBQUUsR0FBR3dGLFNBQVEsTUFBTztZQUNoRSxNQUFNcEUsVUFBVSxNQUFNakMsR0FBR2tDLFFBQVEsQ0FBQ1AsVUFBVTtZQUM1QyxNQUFNMkUsV0FBV3hFLEtBQUtLLEtBQUssQ0FBQ0Y7WUFDNUJxRSxTQUFTbEUsU0FBUyxHQUFHLElBQUlDLEtBQUtpRSxTQUFTbEUsU0FBUztZQUNoRCxPQUFPa0U7UUFDWCxFQUFFLE9BQU07WUFDSixPQUFPO1FBQ1g7SUFDSjtJQUVBLG9CQUFvQjtJQUNwQixNQUFNRSxZQUFTO1FBQ1gsSUFBSTtZQUNBLE1BQU12RSxVQUFVLE1BQU1qQyxHQUFHa0MsUUFBUSxDQUFDLElBQUksQ0FBQ3BCLFVBQVUsRUFBRTtZQUNuRCxPQUFPZ0IsS0FBS0ssS0FBSyxDQUFDRjtRQUN0QixFQUFFLE9BQU07WUFDSixPQUFPO2dCQUNIYixNQUFNO2dCQUNOQyxVQUFVO2dCQUNWQyxNQUFNO2dCQUNOQyxRQUFROztRQUVoQjtJQUNKO0lBRUEsTUFBTUMsV0FBV0QsTUFBNEI7UUFDekMsTUFBTXZCLEdBQUc2QixTQUFTLENBQUMsSUFBSSxDQUFDZixVQUFVLEVBQUVnQixLQUFLQyxTQUFTLENBQUNSLFFBQVEsTUFBTTtJQUNyRTs7QUF4UkprRixtQkFBQSxHQUFBckc7QUEyUkFxRyxrQkFBQSxHQUFlckciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYm9zZGIvd2ViLy4uLy4uL3NyYy9zdG9yYWdlL0ZpbGVTdG9yYWdlLnRzPzk1OTAiXSwibmFtZXMiOlsiZnMiLCJfX2ltcG9ydFN0YXIiLCJyZXF1aXJlIiwicGF0aCIsIkZpbGVTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJiYXNlRGlyIiwiY29tbWl0c0RpciIsImpvaW4iLCJicmFuY2hlc0RpciIsInRhZ3NEaXIiLCJzdGFzaERpciIsInJlZmxvZ0RpciIsInNuYXBzaG90c0RpciIsImNvbmZpZ0ZpbGUiLCJpbml0aWFsaXplIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJhY2Nlc3MiLCJkZWZhdWx0Q29uZmlnIiwiSEVBRCIsImJyYW5jaGVzIiwidGFncyIsImNvbmZpZyIsInNhdmVDb25maWciLCJzYXZlQ29tbWl0IiwiY29tbWl0IiwiZmlsZVBhdGgiLCJpZCIsIndyaXRlRmlsZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRDb21taXQiLCJjb250ZW50IiwicmVhZEZpbGUiLCJwYXJzZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJhdXRob3IiLCJnZXRDb21taXRzIiwiaWRzIiwiY29tbWl0cyIsInB1c2giLCJzYXZlQnJhbmNoIiwiYnJhbmNoIiwibmFtZSIsImdldEJyYW5jaCIsImxpc3RCcmFuY2hlcyIsImZpbGVzIiwicmVhZGRpciIsImZpbGUiLCJlbmRzV2l0aCIsInJlcGxhY2UiLCJkZWxldGVCcmFuY2giLCJ1bmxpbmsiLCJzYXZlVGFnIiwidGFnIiwiZ2V0VGFnIiwiY3JlYXRlZEF0IiwidGFnZ2VyIiwibGlzdFRhZ3MiLCJmaWx0ZXIiLCJtYXRjaGVzVGFnRmlsdGVyIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImRlbGV0ZVRhZyIsInBhdHRlcm4iLCJpbmNsdWRlcyIsImFmdGVyRGF0ZSIsImJlZm9yZURhdGUiLCJhbm5vdGF0ZWRPbmx5IiwidHlwZSIsInNhdmVTdGFzaCIsInN0YXNoIiwiZ2V0U3Rhc2giLCJsaXN0U3Rhc2hlcyIsInN0YXNoZXMiLCJkZWxldGVTdGFzaCIsImFkZFJlZmxvZ0VudHJ5IiwiZW50cnkiLCJsaW5lIiwiYXBwZW5kRmlsZSIsImdldFJlZmxvZyIsIm9wdGlvbnMiLCJsaW5lcyIsInRyaW0iLCJzcGxpdCIsImwiLCJlbnRyaWVzIiwibWFwIiwicmVmTmFtZSIsImUiLCJyZWYiLCJzaW5jZSIsInVudGlsIiwibWF4Q291bnQiLCJzbGljZSIsInJldmVyc2UiLCJzYXZlU25hcHNob3QiLCJjb21taXRJZCIsInNuYXBzaG90IiwiZ2V0U25hcHNob3QiLCJnZXRDb25maWciLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../packages/version-control/dist/storage/FileStorage.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvcs%2Fcommit%2Froute&page=%2Fapi%2Fvcs%2Fcommit%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvcs%2Fcommit%2Froute.ts&appDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CArush%20Gupta%5CDownloads%5CBosDB-Browser%5Capps%5Cweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();